<!DOCTYPE html>
<html>
  <head>
  <title>如何开展灰盒测试[1]：灰盒测试优缺点分析 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      如何开展灰盒测试[1]：灰盒测试优缺点分析  
  
    
      
    
  
  
俺在忽悠某个技术领域的玩意儿之前，通常先要分析一下优缺点——这样才能调动大伙儿的积极性嘛。所以，  本系列  第1帖，咱们先分析一下灰盒测试的优缺点。 
       
         ★几个基本概念 
  首先，把一些基本概念，简单通俗地说一下。如果觉得俺解释得不够好，不够细，可以自己去查维基百科（洋文的介绍在“  这里  ”；看不懂洋文的，可以看“  中文的条目  ”（可惜中文的不够全，偏偏缺了“灰盒测试”这一节）。        ◇黑盒测试 
  通俗来说：黑盒测试不关注软件内部的实现细节。他仅仅把被测试的软件当成一个整体来处理，只关注软件的外在表现，不关注内部细节。典型的黑盒测试，就是光拿着鼠标操作一下用户界面，看看功能是否满足要求。        ◇白盒测试 
  白盒测试与黑盒测试相反，重点关注软件内部的实现细节（比如代码覆盖率等）。        ◇灰盒测试 
  如果你是从事开发或者测试的行当，应该已经听过黑盒测试与白盒测试这2个概念。但对灰盒测试，或许比较耳生。单纯从名称上来看，灰盒测试是介于黑盒测试与白盒测试之间的一种测试方式。  这种测试方式，主要用于多模块构成的稍微复杂的软件系统。在灰盒测试中，重点关注软件系统内部模块的边界（接口）。这里所说的“接口”是广义的，包含有各种形式。对于进程内的模块，其接口可能是动态库的导出函数；对于进程级的模块，其接口可能是各种IPC（进程间通讯）机制；对于涉及数据库的软件系统，其接口可能是数据库的表结构......        ◇“灰盒测试”与“黑盒测试”的区别 
  两者的如下：  如果某软件包含多个模块，当你使用黑盒测试时，你只要关心整个软件系统的边界，无需关心软件系统内部各个模块之间如何协作。  而如果使用灰盒测试，你就需要关心模块与模块之间的交互。这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“白盒测试”的区别 
  两者的区别如下：  但是，在灰盒测试中，你还是【无需】关心模块内部的实现细节。对于软件系统的【内部模块】，灰盒测试依然把它当成一个黑盒来看待。  而白盒测试则不同，还需要再深入地了解【内部】模块的实现细节。所以，这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“单元测试”的区别 
  两者的区别如下：  刚才看到有网友在评论中问到此问题，俺补充一下。  首先，在进行单元测试前，需要先写一些测试代码（行话叫“桩代码”，洋文叫“stub”）。一般来说，测试代码与被测试代码采用【同种语言】（比如 Java 的单元测试通常也用 Java 来写），且测试代码和被测试代码之间的耦合很紧密。因此，单元测试通常由开发人员来完成的——测试人员的能力未必能胜任。  其次，单元测试的颗粒度会更细（会细到模块内部的类一级、函数一级），而灰盒测试仅仅到【模块一级】。         ★相对于黑盒测试的优点 
  灰盒测试相对黑盒测试的优点，其实有不少，俺挑几个重要的来说说。        ◇测试可以及早介入 
  由于黑盒测试把整个软件系统当成一个整体来测试。如果系统的某个关键模块还没有完工，那测试人员就无法对整个系统进行测试，只好闲着没事干。而灰盒测试是针对模块的边界进行，模块开发完一个就测试一个。        ◇有助于测试人员理解系统结构 
  为了进行灰盒测试，测试人员首先要熟悉内部模块之间的协作机制。在熟悉的过程中，“顺便”也就对整个系统（及其结构）有一个初步的、宏观的认识。这有助于测试人员发现一些系统结构方面的 Bug。  而对于黑盒测试来说，由于测试人员不清楚软件系统的内部结构，难以发现一些结构性的缺陷。        ◇有助于管理层了解真实的开发进度 
  一些复杂的大系统，经常会发生开发进度失控的情况。因为很多开发人员有报喜不报忧的倾向。当某个开发人员号称自己的工作已经完成了90%，往往意味着他/她还要花同样多的时间来完成剩下的10%。这导致负责项目管理的人，无法了解开发的真实进度。  由于灰盒测试针对对每一个模块进行，而且测试人员会从一个客观的角度来反馈模块的完成情况，这非常有利于管理层了解整个系统的真实完成情况。        ◇可以构造更好的测试用例 
  如果仅仅用黑盒的方式测试系统的外部边界（通常是用户界面），有很多软件缺陷是不容易发现的。俺分别拿“B/S系统”和“C/S系统”来举例。  假设开发一个复杂的 Windows 桌面软件。那么，这个软件通常【不会】只有一个 EXE 文件。它可能会有若干个 EXE 文件以及若干个 DLL 文件。假如某个 DLL 提供的导出函数，没有按照约定对输入参数进行有效性判断（比如指针是否为空），那你用黑盒测试的方式，难以暴露出这种缺陷。而灰盒测试就容易发现此类问题（具体如何发现，请看后续的“接口测试实战——测试进程内的模块接口”）。  假如你开发的是一个 Web 应用系统，那么，这种系统的服务端多半会提供若干个 Web 接口用于被客户端调用。假如某个 Web 接口存在"安全性问题/并发性问题/健壮性问题/XX 问题"，你单纯用黑盒测试的手段，同样难以发现；而灰盒测试就可以搞定（灰盒测试是如何搞定的，请看后续的《  接口测试实战——测试跨主机的模块接口  》）。        ◇利于提升测试人员能力 
  很多公司搞的黑盒测试，就是让测试人员用鼠标（键盘都难得用）操作用户界面。在这种的环境里，测试人员干的活，很多都是重复性的体力劳动，技术能力难以得到提高。  而如果搞灰盒测试，测试人员就需要多懂一点技术背景知识，必要时还得写点测试脚本，对测试人员的能力提升很有好处。         ★相对于白盒测试的好处 
  灰盒测试相对白盒测试的好处，比较容易概括。简单来说，就是白盒测试较费钱（研发成本较高）。这多出来的研发成本，体现在如下几个方面。        ◇首先，招聘成本较高 
  在人才市场上，100个应聘的测试人员中，未必能够找到一个合适的白盒测试人员。至少从俺及周围同事的面试经历来看，难得碰到具备白盒测试能力的人。所以，你可能要花很长时间才能找到合适的人，时间成本浪费掉了。        ◇其次，培训成本较高 
  可能有同学会说，招不到就内部培养呗。这个说起来容易，但是培训也是有成本的。而且周期还不短，同样要耗费时间成本。        ◇再其次，人力成本较高 
  物以稀为贵是一条普遍的经济学规律。由于能搞白盒测试的家伙是稀有动物，你自然不能给他/她开太低的薪水。否则人家待不了多久就跑路了。薪水开得高了，人力成本自然也就提高了。         ★其它的一些好处 
  前面拿灰盒测试分别跟黑盒/白盒进行了对比，列举了一些优点。  还有另外一些优点，和黑盒/白盒没啥关系，单独列在这里。        ◇顺便强化开发文档 
  对于一个复杂的软件系统，模块之间的接口是很重要的，因此捏，接口文档也是很重要滴。而开发人员不爱写文档/不爱更新文档，（在软件业内）已经是臭名昭著了。很多软件开发到后期，模块之间的接口文档要么没有，要么和代码实现严重脱节。  但是，如果引入测试人员对模块之间的接口进行测试，就可以有效防止此种弊端。因为测试人员在测试前，首先要看模块间的接口文档，然后再根据接口文档设计测试用例，最后再执行用例。因此，一旦接口文档和代码实现不符，立马就露馅了。        ◇有助于推进“自动化测试” 
  灰盒测试如果落实到位，还可以跟自动化测试相结合。一旦做到这点，可以大大提升测试的效率，进而大大提升软件的质量。（如何进行自动化的灰盒测试，后面的帖子会细谈）         ★灰盒测试有啥缺点？ 
  当然，凡事都有优点和缺点，灰盒测试自然也不例外。下面列举它的主要缺点。        ◇不适用于简单的系统 
  所谓的简单系统，就是简单到总共只有一个模块。由于灰盒测试关注于系统内部模块之间的交互。如果某个系统简单到只有一个模块，那就没必要进行灰盒测试了。        ◇对测试人员的要求比黑盒测试高 
  从上面的介绍来看，灰盒测试要求测试人员清楚系统内部由哪些模块构成，模块之间如何协作。因此，对测试的要求就提高了。因此，会带来一定的培训成本。不过捏，依照俺的经验，培训难度不大。稍微有点基础的测试人员，都可以在短期培训之后胜任。        ◇不如白盒测试深入 
  显然，灰盒不如白盒那么深入。不过捏，考虑到灰盒测试相比白盒测试有显著的成本优势，该缺点不是太明显。         ★总结 
  总而言之，言而总之，灰盒测试是一个很不错的东东，其优点明显而缺点容易克服。另外，俺前后在两家公司的研发部门推行过，效果不错的说。大伙儿值得去尝试一下。今天光说了优缺点对比，在  下一个帖子  ，俺具体介绍一下，开展灰盒测试之前，管理上有哪些准备工作。     回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2010/11/grey-box-testing-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      如何开展灰盒测试[1]：灰盒测试优缺点分析  
  
    
      
    
  
  
俺在忽悠某个技术领域的玩意儿之前，通常先要分析一下优缺点——这样才能调动大伙儿的积极性嘛。所以，  本系列  第1帖，咱们先分析一下灰盒测试的优缺点。 
       
         ★几个基本概念 
  首先，把一些基本概念，简单通俗地说一下。如果觉得俺解释得不够好，不够细，可以自己去查维基百科（洋文的介绍在“  这里  ”；看不懂洋文的，可以看“  中文的条目  ”（可惜中文的不够全，偏偏缺了“灰盒测试”这一节）。        ◇黑盒测试 
  通俗来说：黑盒测试不关注软件内部的实现细节。他仅仅把被测试的软件当成一个整体来处理，只关注软件的外在表现，不关注内部细节。典型的黑盒测试，就是光拿着鼠标操作一下用户界面，看看功能是否满足要求。        ◇白盒测试 
  白盒测试与黑盒测试相反，重点关注软件内部的实现细节（比如代码覆盖率等）。        ◇灰盒测试 
  如果你是从事开发或者测试的行当，应该已经听过黑盒测试与白盒测试这2个概念。但对灰盒测试，或许比较耳生。单纯从名称上来看，灰盒测试是介于黑盒测试与白盒测试之间的一种测试方式。  这种测试方式，主要用于多模块构成的稍微复杂的软件系统。在灰盒测试中，重点关注软件系统内部模块的边界（接口）。这里所说的“接口”是广义的，包含有各种形式。对于进程内的模块，其接口可能是动态库的导出函数；对于进程级的模块，其接口可能是各种IPC（进程间通讯）机制；对于涉及数据库的软件系统，其接口可能是数据库的表结构......        ◇“灰盒测试”与“黑盒测试”的区别 
  两者的如下：  如果某软件包含多个模块，当你使用黑盒测试时，你只要关心整个软件系统的边界，无需关心软件系统内部各个模块之间如何协作。  而如果使用灰盒测试，你就需要关心模块与模块之间的交互。这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“白盒测试”的区别 
  两者的区别如下：  但是，在灰盒测试中，你还是【无需】关心模块内部的实现细节。对于软件系统的【内部模块】，灰盒测试依然把它当成一个黑盒来看待。  而白盒测试则不同，还需要再深入地了解【内部】模块的实现细节。所以，这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“单元测试”的区别 
  两者的区别如下：  刚才看到有网友在评论中问到此问题，俺补充一下。  首先，在进行单元测试前，需要先写一些测试代码（行话叫“桩代码”，洋文叫“stub”）。一般来说，测试代码与被测试代码采用【同种语言】（比如 Java 的单元测试通常也用 Java 来写），且测试代码和被测试代码之间的耦合很紧密。因此，单元测试通常由开发人员来完成的——测试人员的能力未必能胜任。  其次，单元测试的颗粒度会更细（会细到模块内部的类一级、函数一级），而灰盒测试仅仅到【模块一级】。         ★相对于黑盒测试的优点 
  灰盒测试相对黑盒测试的优点，其实有不少，俺挑几个重要的来说说。        ◇测试可以及早介入 
  由于黑盒测试把整个软件系统当成一个整体来测试。如果系统的某个关键模块还没有完工，那测试人员就无法对整个系统进行测试，只好闲着没事干。而灰盒测试是针对模块的边界进行，模块开发完一个就测试一个。        ◇有助于测试人员理解系统结构 
  为了进行灰盒测试，测试人员首先要熟悉内部模块之间的协作机制。在熟悉的过程中，“顺便”也就对整个系统（及其结构）有一个初步的、宏观的认识。这有助于测试人员发现一些系统结构方面的 Bug。  而对于黑盒测试来说，由于测试人员不清楚软件系统的内部结构，难以发现一些结构性的缺陷。        ◇有助于管理层了解真实的开发进度 
  一些复杂的大系统，经常会发生开发进度失控的情况。因为很多开发人员有报喜不报忧的倾向。当某个开发人员号称自己的工作已经完成了90%，往往意味着他/她还要花同样多的时间来完成剩下的10%。这导致负责项目管理的人，无法了解开发的真实进度。  由于灰盒测试针对对每一个模块进行，而且测试人员会从一个客观的角度来反馈模块的完成情况，这非常有利于管理层了解整个系统的真实完成情况。        ◇可以构造更好的测试用例 
  如果仅仅用黑盒的方式测试系统的外部边界（通常是用户界面），有很多软件缺陷是不容易发现的。俺分别拿“B/S系统”和“C/S系统”来举例。  假设开发一个复杂的 Windows 桌面软件。那么，这个软件通常【不会】只有一个 EXE 文件。它可能会有若干个 EXE 文件以及若干个 DLL 文件。假如某个 DLL 提供的导出函数，没有按照约定对输入参数进行有效性判断（比如指针是否为空），那你用黑盒测试的方式，难以暴露出这种缺陷。而灰盒测试就容易发现此类问题（具体如何发现，请看后续的“接口测试实战——测试进程内的模块接口”）。  假如你开发的是一个 Web 应用系统，那么，这种系统的服务端多半会提供若干个 Web 接口用于被客户端调用。假如某个 Web 接口存在"安全性问题/并发性问题/健壮性问题/XX 问题"，你单纯用黑盒测试的手段，同样难以发现；而灰盒测试就可以搞定（灰盒测试是如何搞定的，请看后续的《  接口测试实战——测试跨主机的模块接口  》）。        ◇利于提升测试人员能力 
  很多公司搞的黑盒测试，就是让测试人员用鼠标（键盘都难得用）操作用户界面。在这种的环境里，测试人员干的活，很多都是重复性的体力劳动，技术能力难以得到提高。  而如果搞灰盒测试，测试人员就需要多懂一点技术背景知识，必要时还得写点测试脚本，对测试人员的能力提升很有好处。         ★相对于白盒测试的好处 
  灰盒测试相对白盒测试的好处，比较容易概括。简单来说，就是白盒测试较费钱（研发成本较高）。这多出来的研发成本，体现在如下几个方面。        ◇首先，招聘成本较高 
  在人才市场上，100个应聘的测试人员中，未必能够找到一个合适的白盒测试人员。至少从俺及周围同事的面试经历来看，难得碰到具备白盒测试能力的人。所以，你可能要花很长时间才能找到合适的人，时间成本浪费掉了。        ◇其次，培训成本较高 
  可能有同学会说，招不到就内部培养呗。这个说起来容易，但是培训也是有成本的。而且周期还不短，同样要耗费时间成本。        ◇再其次，人力成本较高 
  物以稀为贵是一条普遍的经济学规律。由于能搞白盒测试的家伙是稀有动物，你自然不能给他/她开太低的薪水。否则人家待不了多久就跑路了。薪水开得高了，人力成本自然也就提高了。         ★其它的一些好处 
  前面拿灰盒测试分别跟黑盒/白盒进行了对比，列举了一些优点。  还有另外一些优点，和黑盒/白盒没啥关系，单独列在这里。        ◇顺便强化开发文档 
  对于一个复杂的软件系统，模块之间的接口是很重要的，因此捏，接口文档也是很重要滴。而开发人员不爱写文档/不爱更新文档，（在软件业内）已经是臭名昭著了。很多软件开发到后期，模块之间的接口文档要么没有，要么和代码实现严重脱节。  但是，如果引入测试人员对模块之间的接口进行测试，就可以有效防止此种弊端。因为测试人员在测试前，首先要看模块间的接口文档，然后再根据接口文档设计测试用例，最后再执行用例。因此，一旦接口文档和代码实现不符，立马就露馅了。        ◇有助于推进“自动化测试” 
  灰盒测试如果落实到位，还可以跟自动化测试相结合。一旦做到这点，可以大大提升测试的效率，进而大大提升软件的质量。（如何进行自动化的灰盒测试，后面的帖子会细谈）         ★灰盒测试有啥缺点？ 
  当然，凡事都有优点和缺点，灰盒测试自然也不例外。下面列举它的主要缺点。        ◇不适用于简单的系统 
  所谓的简单系统，就是简单到总共只有一个模块。由于灰盒测试关注于系统内部模块之间的交互。如果某个系统简单到只有一个模块，那就没必要进行灰盒测试了。        ◇对测试人员的要求比黑盒测试高 
  从上面的介绍来看，灰盒测试要求测试人员清楚系统内部由哪些模块构成，模块之间如何协作。因此，对测试的要求就提高了。因此，会带来一定的培训成本。不过捏，依照俺的经验，培训难度不大。稍微有点基础的测试人员，都可以在短期培训之后胜任。        ◇不如白盒测试深入 
  显然，灰盒不如白盒那么深入。不过捏，考虑到灰盒测试相比白盒测试有显著的成本优势，该缺点不是太明显。         ★总结 
  总而言之，言而总之，灰盒测试是一个很不错的东东，其优点明显而缺点容易克服。另外，俺前后在两家公司的研发部门推行过，效果不错的说。大伙儿值得去尝试一下。今天光说了优缺点对比，在  下一个帖子  ，俺具体介绍一下，开展灰盒测试之前，管理上有哪些准备工作。     回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2010/11/grey-box-testing-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="如何开展灰盒测试[1]：灰盒测试优缺点分析" />
    <meta property="twitter:title" content="如何开展灰盒测试[1]：灰盒测试优缺点分析" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17499)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2010%2F11%2Fgrey-box-testing-1.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html&text=如何开展灰盒测试[1]：灰盒测试优缺点分析&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html&title=如何开展灰盒测试[1]：灰盒测试优缺点分析" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html&title=如何开展灰盒测试[1]：灰盒测试优缺点分析" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=如何开展灰盒测试[1]：灰盒测试优缺点分析&body=

      如何开展灰盒测试[1]：灰盒测试优缺点分析  
  
    
      
    
  
  
俺在忽悠某个技术领域的玩意儿之前，通常先要分析一下优缺点——这样才能调动大伙儿的积极性嘛。所以，  本系列  第1帖，咱们先分析一下灰盒测试的优缺点。 
       
         ★几个基本概念 
  首先，把一些基本概念，简单通俗地说一下。如果觉得俺解释得不够好，不够细，可以自己去查维基百科（洋文的介绍在“  这里  ”；看不懂洋文的，可以看“  中文的条目  ”（可惜中文的不够全，偏偏缺了“灰盒测试”这一节）。        ◇黑盒测试 
  通俗来说：黑盒测试不关注软件内部的实现细节。他仅仅把被测试的软件当成一个整体来处理，只关注软件的外在表现，不关注内部细节。典型的黑盒测试，就是光拿着鼠标操作一下用户界面，看看功能是否满足要求。        ◇白盒测试 
  白盒测试与黑盒测试相反，重点关注软件内部的实现细节（比如代码覆盖率等）。        ◇灰盒测试 
  如果你是从事开发或者测试的行当，应该已经听过黑盒测试与白盒测试这2个概念。但对灰盒测试，或许比较耳生。单纯从名称上来看，灰盒测试是介于黑盒测试与白盒测试之间的一种测试方式。  这种测试方式，主要用于多模块构成的稍微复杂的软件系统。在灰盒测试中，重点关注软件系统内部模块的边界（接口）。这里所说的“接口”是广义的，包含有各种形式。对于进程内的模块，其接口可能是动态库的导出函数；对于进程级的模块，其接口可能是各种IPC（进程间通讯）机制；对于涉及数据库的软件系统，其接口可能是数据库的表结构......        ◇“灰盒测试”与“黑盒测试”的区别 
  两者的如下：  如果某软件包含多个模块，当你使用黑盒测试时，你只要关心整个软件系统的边界，无需关心软件系统内部各个模块之间如何协作。  而如果使用灰盒测试，你就需要关心模块与模块之间的交互。这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“白盒测试”的区别 
  两者的区别如下：  但是，在灰盒测试中，你还是【无需】关心模块内部的实现细节。对于软件系统的【内部模块】，灰盒测试依然把它当成一个黑盒来看待。  而白盒测试则不同，还需要再深入地了解【内部】模块的实现细节。所以，这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“单元测试”的区别 
  两者的区别如下：  刚才看到有网友在评论中问到此问题，俺补充一下。  首先，在进行单元测试前，需要先写一些测试代码（行话叫“桩代码”，洋文叫“stub”）。一般来说，测试代码与被测试代码采用【同种语言】（比如 Java 的单元测试通常也用 Java 来写），且测试代码和被测试代码之间的耦合很紧密。因此，单元测试通常由开发人员来完成的——测试人员的能力未必能胜任。  其次，单元测试的颗粒度会更细（会细到模块内部的类一级、函数一级），而灰盒测试仅仅到【模块一级】。         ★相对于黑盒测试的优点 
  灰盒测试相对黑盒测试的优点，其实有不少，俺挑几个重要的来说说。        ◇测试可以及早介入 
  由于黑盒测试把整个软件系统当成一个整体来测试。如果系统的某个关键模块还没有完工，那测试人员就无法对整个系统进行测试，只好闲着没事干。而灰盒测试是针对模块的边界进行，模块开发完一个就测试一个。        ◇有助于测试人员理解系统结构 
  为了进行灰盒测试，测试人员首先要熟悉内部模块之间的协作机制。在熟悉的过程中，“顺便”也就对整个系统（及其结构）有一个初步的、宏观的认识。这有助于测试人员发现一些系统结构方面的 Bug。  而对于黑盒测试来说，由于测试人员不清楚软件系统的内部结构，难以发现一些结构性的缺陷。        ◇有助于管理层了解真实的开发进度 
  一些复杂的大系统，经常会发生开发进度失控的情况。因为很多开发人员有报喜不报忧的倾向。当某个开发人员号称自己的工作已经完成了90%，往往意味着他/她还要花同样多的时间来完成剩下的10%。这导致负责项目管理的人，无法了解开发的真实进度。  由于灰盒测试针对对每一个模块进行，而且测试人员会从一个客观的角度来反馈模块的完成情况，这非常有利于管理层了解整个系统的真实完成情况。        ◇可以构造更好的测试用例 
  如果仅仅用黑盒的方式测试系统的外部边界（通常是用户界面），有很多软件缺陷是不容易发现的。俺分别拿“B/S系统”和“C/S系统”来举例。  假设开发一个复杂的 Windows 桌面软件。那么，这个软件通常【不会】只有一个 EXE 文件。它可能会有若干个 EXE 文件以及若干个 DLL 文件。假如某个 DLL 提供的导出函数，没有按照约定对输入参数进行有效性判断（比如指针是否为空），那你用黑盒测试的方式，难以暴露出这种缺陷。而灰盒测试就容易发现此类问题（具体如何发现，请看后续的“接口测试实战——测试进程内的模块接口”）。  假如你开发的是一个 Web 应用系统，那么，这种系统的服务端多半会提供若干个 Web 接口用于被客户端调用。假如某个 Web 接口存在"安全性问题/并发性问题/健壮性问题/XX 问题"，你单纯用黑盒测试的手段，同样难以发现；而灰盒测试就可以搞定（灰盒测试是如何搞定的，请看后续的《  接口测试实战——测试跨主机的模块接口  》）。        ◇利于提升测试人员能力 
  很多公司搞的黑盒测试，就是让测试人员用鼠标（键盘都难得用）操作用户界面。在这种的环境里，测试人员干的活，很多都是重复性的体力劳动，技术能力难以得到提高。  而如果搞灰盒测试，测试人员就需要多懂一点技术背景知识，必要时还得写点测试脚本，对测试人员的能力提升很有好处。         ★相对于白盒测试的好处 
  灰盒测试相对白盒测试的好处，比较容易概括。简单来说，就是白盒测试较费钱（研发成本较高）。这多出来的研发成本，体现在如下几个方面。        ◇首先，招聘成本较高 
  在人才市场上，100个应聘的测试人员中，未必能够找到一个合适的白盒测试人员。至少从俺及周围同事的面试经历来看，难得碰到具备白盒测试能力的人。所以，你可能要花很长时间才能找到合适的人，时间成本浪费掉了。        ◇其次，培训成本较高 
  可能有同学会说，招不到就内部培养呗。这个说起来容易，但是培训也是有成本的。而且周期还不短，同样要耗费时间成本。        ◇再其次，人力成本较高 
  物以稀为贵是一条普遍的经济学规律。由于能搞白盒测试的家伙是稀有动物，你自然不能给他/她开太低的薪水。否则人家待不了多久就跑路了。薪水开得高了，人力成本自然也就提高了。         ★其它的一些好处 
  前面拿灰盒测试分别跟黑盒/白盒进行了对比，列举了一些优点。  还有另外一些优点，和黑盒/白盒没啥关系，单独列在这里。        ◇顺便强化开发文档 
  对于一个复杂的软件系统，模块之间的接口是很重要的，因此捏，接口文档也是很重要滴。而开发人员不爱写文档/不爱更新文档，（在软件业内）已经是臭名昭著了。很多软件开发到后期，模块之间的接口文档要么没有，要么和代码实现严重脱节。  但是，如果引入测试人员对模块之间的接口进行测试，就可以有效防止此种弊端。因为测试人员在测试前，首先要看模块间的接口文档，然后再根据接口文档设计测试用例，最后再执行用例。因此，一旦接口文档和代码实现不符，立马就露馅了。        ◇有助于推进“自动化测试” 
  灰盒测试如果落实到位，还可以跟自动化测试相结合。一旦做到这点，可以大大提升测试的效率，进而大大提升软件的质量。（如何进行自动化的灰盒测试，后面的帖子会细谈）         ★灰盒测试有啥缺点？ 
  当然，凡事都有优点和缺点，灰盒测试自然也不例外。下面列举它的主要缺点。        ◇不适用于简单的系统 
  所谓的简单系统，就是简单到总共只有一个模块。由于灰盒测试关注于系统内部模块之间的交互。如果某个系统简单到只有一个模块，那就没必要进行灰盒测试了。        ◇对测试人员的要求比黑盒测试高 
  从上面的介绍来看，灰盒测试要求测试人员清楚系统内部由哪些模块构成，模块之间如何协作。因此，对测试的要求就提高了。因此，会带来一定的培训成本。不过捏，依照俺的经验，培训难度不大。稍微有点基础的测试人员，都可以在短期培训之后胜任。        ◇不如白盒测试深入 
  显然，灰盒不如白盒那么深入。不过捏，考虑到灰盒测试相比白盒测试有显著的成本优势，该缺点不是太明显。         ★总结 
  总而言之，言而总之，灰盒测试是一个很不错的东东，其优点明显而缺点容易克服。另外，俺前后在两家公司的研发部门推行过，效果不错的说。大伙儿值得去尝试一下。今天光说了优缺点对比，在  下一个帖子  ，俺具体介绍一下，开展灰盒测试之前，管理上有哪些准备工作。     回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2010/11/grey-box-testing-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html&title=如何开展灰盒测试[1]：灰盒测试优缺点分析&caption=

      如何开展灰盒测试[1]：灰盒测试优缺点分析  
  
    
      
    
  
  
俺在忽悠某个技术领域的玩意儿之前，通常先要分析一下优缺点——这样才能调动大伙儿的积极性嘛。所以，  本系列  第1帖，咱们先分析一下灰盒测试的优缺点。 
       
         ★几个基本概念 
  首先，把一些基本概念，简单通俗地说一下。如果觉得俺解释得不够好，不够细，可以自己去查维基百科（洋文的介绍在“  这里  ”；看不懂洋文的，可以看“  中文的条目  ”（可惜中文的不够全，偏偏缺了“灰盒测试”这一节）。        ◇黑盒测试 
  通俗来说：黑盒测试不关注软件内部的实现细节。他仅仅把被测试的软件当成一个整体来处理，只关注软件的外在表现，不关注内部细节。典型的黑盒测试，就是光拿着鼠标操作一下用户界面，看看功能是否满足要求。        ◇白盒测试 
  白盒测试与黑盒测试相反，重点关注软件内部的实现细节（比如代码覆盖率等）。        ◇灰盒测试 
  如果你是从事开发或者测试的行当，应该已经听过黑盒测试与白盒测试这2个概念。但对灰盒测试，或许比较耳生。单纯从名称上来看，灰盒测试是介于黑盒测试与白盒测试之间的一种测试方式。  这种测试方式，主要用于多模块构成的稍微复杂的软件系统。在灰盒测试中，重点关注软件系统内部模块的边界（接口）。这里所说的“接口”是广义的，包含有各种形式。对于进程内的模块，其接口可能是动态库的导出函数；对于进程级的模块，其接口可能是各种IPC（进程间通讯）机制；对于涉及数据库的软件系统，其接口可能是数据库的表结构......        ◇“灰盒测试”与“黑盒测试”的区别 
  两者的如下：  如果某软件包含多个模块，当你使用黑盒测试时，你只要关心整个软件系统的边界，无需关心软件系统内部各个模块之间如何协作。  而如果使用灰盒测试，你就需要关心模块与模块之间的交互。这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“白盒测试”的区别 
  两者的区别如下：  但是，在灰盒测试中，你还是【无需】关心模块内部的实现细节。对于软件系统的【内部模块】，灰盒测试依然把它当成一个黑盒来看待。  而白盒测试则不同，还需要再深入地了解【内部】模块的实现细节。所以，这是灰盒测试与黑盒测试的区别。        ◇“灰盒测试”与“单元测试”的区别 
  两者的区别如下：  刚才看到有网友在评论中问到此问题，俺补充一下。  首先，在进行单元测试前，需要先写一些测试代码（行话叫“桩代码”，洋文叫“stub”）。一般来说，测试代码与被测试代码采用【同种语言】（比如 Java 的单元测试通常也用 Java 来写），且测试代码和被测试代码之间的耦合很紧密。因此，单元测试通常由开发人员来完成的——测试人员的能力未必能胜任。  其次，单元测试的颗粒度会更细（会细到模块内部的类一级、函数一级），而灰盒测试仅仅到【模块一级】。         ★相对于黑盒测试的优点 
  灰盒测试相对黑盒测试的优点，其实有不少，俺挑几个重要的来说说。        ◇测试可以及早介入 
  由于黑盒测试把整个软件系统当成一个整体来测试。如果系统的某个关键模块还没有完工，那测试人员就无法对整个系统进行测试，只好闲着没事干。而灰盒测试是针对模块的边界进行，模块开发完一个就测试一个。        ◇有助于测试人员理解系统结构 
  为了进行灰盒测试，测试人员首先要熟悉内部模块之间的协作机制。在熟悉的过程中，“顺便”也就对整个系统（及其结构）有一个初步的、宏观的认识。这有助于测试人员发现一些系统结构方面的 Bug。  而对于黑盒测试来说，由于测试人员不清楚软件系统的内部结构，难以发现一些结构性的缺陷。        ◇有助于管理层了解真实的开发进度 
  一些复杂的大系统，经常会发生开发进度失控的情况。因为很多开发人员有报喜不报忧的倾向。当某个开发人员号称自己的工作已经完成了90%，往往意味着他/她还要花同样多的时间来完成剩下的10%。这导致负责项目管理的人，无法了解开发的真实进度。  由于灰盒测试针对对每一个模块进行，而且测试人员会从一个客观的角度来反馈模块的完成情况，这非常有利于管理层了解整个系统的真实完成情况。        ◇可以构造更好的测试用例 
  如果仅仅用黑盒的方式测试系统的外部边界（通常是用户界面），有很多软件缺陷是不容易发现的。俺分别拿“B/S系统”和“C/S系统”来举例。  假设开发一个复杂的 Windows 桌面软件。那么，这个软件通常【不会】只有一个 EXE 文件。它可能会有若干个 EXE 文件以及若干个 DLL 文件。假如某个 DLL 提供的导出函数，没有按照约定对输入参数进行有效性判断（比如指针是否为空），那你用黑盒测试的方式，难以暴露出这种缺陷。而灰盒测试就容易发现此类问题（具体如何发现，请看后续的“接口测试实战——测试进程内的模块接口”）。  假如你开发的是一个 Web 应用系统，那么，这种系统的服务端多半会提供若干个 Web 接口用于被客户端调用。假如某个 Web 接口存在"安全性问题/并发性问题/健壮性问题/XX 问题"，你单纯用黑盒测试的手段，同样难以发现；而灰盒测试就可以搞定（灰盒测试是如何搞定的，请看后续的《  接口测试实战——测试跨主机的模块接口  》）。        ◇利于提升测试人员能力 
  很多公司搞的黑盒测试，就是让测试人员用鼠标（键盘都难得用）操作用户界面。在这种的环境里，测试人员干的活，很多都是重复性的体力劳动，技术能力难以得到提高。  而如果搞灰盒测试，测试人员就需要多懂一点技术背景知识，必要时还得写点测试脚本，对测试人员的能力提升很有好处。         ★相对于白盒测试的好处 
  灰盒测试相对白盒测试的好处，比较容易概括。简单来说，就是白盒测试较费钱（研发成本较高）。这多出来的研发成本，体现在如下几个方面。        ◇首先，招聘成本较高 
  在人才市场上，100个应聘的测试人员中，未必能够找到一个合适的白盒测试人员。至少从俺及周围同事的面试经历来看，难得碰到具备白盒测试能力的人。所以，你可能要花很长时间才能找到合适的人，时间成本浪费掉了。        ◇其次，培训成本较高 
  可能有同学会说，招不到就内部培养呗。这个说起来容易，但是培训也是有成本的。而且周期还不短，同样要耗费时间成本。        ◇再其次，人力成本较高 
  物以稀为贵是一条普遍的经济学规律。由于能搞白盒测试的家伙是稀有动物，你自然不能给他/她开太低的薪水。否则人家待不了多久就跑路了。薪水开得高了，人力成本自然也就提高了。         ★其它的一些好处 
  前面拿灰盒测试分别跟黑盒/白盒进行了对比，列举了一些优点。  还有另外一些优点，和黑盒/白盒没啥关系，单独列在这里。        ◇顺便强化开发文档 
  对于一个复杂的软件系统，模块之间的接口是很重要的，因此捏，接口文档也是很重要滴。而开发人员不爱写文档/不爱更新文档，（在软件业内）已经是臭名昭著了。很多软件开发到后期，模块之间的接口文档要么没有，要么和代码实现严重脱节。  但是，如果引入测试人员对模块之间的接口进行测试，就可以有效防止此种弊端。因为测试人员在测试前，首先要看模块间的接口文档，然后再根据接口文档设计测试用例，最后再执行用例。因此，一旦接口文档和代码实现不符，立马就露馅了。        ◇有助于推进“自动化测试” 
  灰盒测试如果落实到位，还可以跟自动化测试相结合。一旦做到这点，可以大大提升测试的效率，进而大大提升软件的质量。（如何进行自动化的灰盒测试，后面的帖子会细谈）         ★灰盒测试有啥缺点？ 
  当然，凡事都有优点和缺点，灰盒测试自然也不例外。下面列举它的主要缺点。        ◇不适用于简单的系统 
  所谓的简单系统，就是简单到总共只有一个模块。由于灰盒测试关注于系统内部模块之间的交互。如果某个系统简单到只有一个模块，那就没必要进行灰盒测试了。        ◇对测试人员的要求比黑盒测试高 
  从上面的介绍来看，灰盒测试要求测试人员清楚系统内部由哪些模块构成，模块之间如何协作。因此，对测试的要求就提高了。因此，会带来一定的培训成本。不过捏，依照俺的经验，培训难度不大。稍微有点基础的测试人员，都可以在短期培训之后胜任。        ◇不如白盒测试深入 
  显然，灰盒不如白盒那么深入。不过捏，考虑到灰盒测试相比白盒测试有显著的成本优势，该缺点不是太明显。         ★总结 
  总而言之，言而总之，灰盒测试是一个很不错的东东，其优点明显而缺点容易克服。另外，俺前后在两家公司的研发部门推行过，效果不错的说。大伙儿值得去尝试一下。今天光说了优缺点对比，在  下一个帖子  ，俺具体介绍一下，开展灰盒测试之前，管理上有哪些准备工作。     回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2010/11/grey-box-testing-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=如何开展灰盒测试[1]：灰盒测试优缺点分析&url=https://program-think.blogspot.com/2010/11/grey-box-testing-1.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>如何开展灰盒测试[1]：灰盒测试优缺点分析</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2010-11-30
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2010/11/grey-box-testing-1.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="2930877115442143301">
 </a>   <h1 class="post-title entry-title" id="section"> <a href="https://program-think.blogspot.com/2010/11/grey-box-testing-1.html"> 如何开展灰盒测试[1]：灰盒测试优缺点分析 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
俺在忽悠某个技术领域的玩意儿之前，通常先要分析一下优缺点——这样才能调动大伙儿的积极性嘛。所以， <a href="https://program-think.blogspot.com/2010/11/grey-box-testing-0.html#index"> 本系列 </a> 第1帖，咱们先分析一下灰盒测试的优缺点。 <a name="more">
  </a>     <!--program-think-->
 <br /> <br /> <br />     <h2 id="section-1"> ★几个基本概念 </h2>
 <br /> 首先，把一些基本概念，简单通俗地说一下。如果觉得俺解释得不够好，不够细，可以自己去查维基百科（洋文的介绍在“ <a href="https://en.wikipedia.org/wiki/Software_testing" rel="nofollow" target="_blank"> 这里 </a> ”；看不懂洋文的，可以看“ <a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95" rel="nofollow" target="_blank"> 中文的条目 </a> ”（可惜中文的不够全，偏偏缺了“灰盒测试”这一节）。 <br /> <br />     <h3 id="section-2"> ◇黑盒测试 </h3>
 <br /> 通俗来说：黑盒测试不关注软件内部的实现细节。他仅仅把被测试的软件当成一个整体来处理，只关注软件的外在表现，不关注内部细节。典型的黑盒测试，就是光拿着鼠标操作一下用户界面，看看功能是否满足要求。 <br /> <br />     <h3 id="section-3"> ◇白盒测试 </h3>
 <br /> 白盒测试与黑盒测试相反，重点关注软件内部的实现细节（比如代码覆盖率等）。 <br /> <br />     <h3 id="section-4"> ◇灰盒测试 </h3>
 <br /> 如果你是从事开发或者测试的行当，应该已经听过黑盒测试与白盒测试这2个概念。但对灰盒测试，或许比较耳生。单纯从名称上来看，灰盒测试是介于黑盒测试与白盒测试之间的一种测试方式。 <br /> 这种测试方式，主要用于多模块构成的稍微复杂的软件系统。在灰盒测试中，重点关注软件系统内部模块的边界（接口）。这里所说的“接口”是广义的，包含有各种形式。对于进程内的模块，其接口可能是动态库的导出函数；对于进程级的模块，其接口可能是各种IPC（进程间通讯）机制；对于涉及数据库的软件系统，其接口可能是数据库的表结构...... <br /> <br />     <h3 id="section-5"> ◇“灰盒测试”与“黑盒测试”的区别 </h3>
 <br /> 两者的如下： <br /> 如果某软件包含多个模块，当你使用黑盒测试时，你只要关心整个软件系统的边界，无需关心软件系统内部各个模块之间如何协作。 <br /> 而如果使用灰盒测试，你就需要关心模块与模块之间的交互。这是灰盒测试与黑盒测试的区别。 <br /> <br />     <h3 id="section-6"> ◇“灰盒测试”与“白盒测试”的区别 </h3>
 <br /> 两者的区别如下： <br /> 但是，在灰盒测试中，你还是【无需】关心模块内部的实现细节。对于软件系统的【内部模块】，灰盒测试依然把它当成一个黑盒来看待。 <br /> 而白盒测试则不同，还需要再深入地了解【内部】模块的实现细节。所以，这是灰盒测试与黑盒测试的区别。 <br /> <br />     <h3 id="section-7"> ◇“灰盒测试”与“单元测试”的区别 </h3>
 <br /> 两者的区别如下： <br /> 刚才看到有网友在评论中问到此问题，俺补充一下。 <br /> 首先，在进行单元测试前，需要先写一些测试代码（行话叫“桩代码”，洋文叫“stub”）。一般来说，测试代码与被测试代码采用【同种语言】（比如 Java 的单元测试通常也用 Java 来写），且测试代码和被测试代码之间的耦合很紧密。因此，单元测试通常由开发人员来完成的——测试人员的能力未必能胜任。 <br /> 其次，单元测试的颗粒度会更细（会细到模块内部的类一级、函数一级），而灰盒测试仅仅到【模块一级】。 <br /> <br /> <br />     <h2 id="section-8"> ★相对于黑盒测试的优点 </h2>
 <br /> 灰盒测试相对黑盒测试的优点，其实有不少，俺挑几个重要的来说说。 <br /> <br />     <h3 id="section-9"> ◇测试可以及早介入 </h3>
 <br /> 由于黑盒测试把整个软件系统当成一个整体来测试。如果系统的某个关键模块还没有完工，那测试人员就无法对整个系统进行测试，只好闲着没事干。而灰盒测试是针对模块的边界进行，模块开发完一个就测试一个。 <br /> <br />     <h3 id="section-10"> ◇有助于测试人员理解系统结构 </h3>
 <br /> 为了进行灰盒测试，测试人员首先要熟悉内部模块之间的协作机制。在熟悉的过程中，“顺便”也就对整个系统（及其结构）有一个初步的、宏观的认识。这有助于测试人员发现一些系统结构方面的 Bug。 <br /> 而对于黑盒测试来说，由于测试人员不清楚软件系统的内部结构，难以发现一些结构性的缺陷。 <br /> <br />     <h3 id="section-11"> ◇有助于管理层了解真实的开发进度 </h3>
 <br /> 一些复杂的大系统，经常会发生开发进度失控的情况。因为很多开发人员有报喜不报忧的倾向。当某个开发人员号称自己的工作已经完成了90%，往往意味着他/她还要花同样多的时间来完成剩下的10%。这导致负责项目管理的人，无法了解开发的真实进度。 <br /> 由于灰盒测试针对对每一个模块进行，而且测试人员会从一个客观的角度来反馈模块的完成情况，这非常有利于管理层了解整个系统的真实完成情况。 <br /> <br />     <h3 id="section-12"> ◇可以构造更好的测试用例 </h3>
 <br /> 如果仅仅用黑盒的方式测试系统的外部边界（通常是用户界面），有很多软件缺陷是不容易发现的。俺分别拿“B/S系统”和“C/S系统”来举例。 <br /> 假设开发一个复杂的 Windows 桌面软件。那么，这个软件通常【不会】只有一个 EXE 文件。它可能会有若干个 EXE 文件以及若干个 DLL 文件。假如某个 DLL 提供的导出函数，没有按照约定对输入参数进行有效性判断（比如指针是否为空），那你用黑盒测试的方式，难以暴露出这种缺陷。而灰盒测试就容易发现此类问题（具体如何发现，请看后续的“接口测试实战——测试进程内的模块接口”）。 <br /> 假如你开发的是一个 Web 应用系统，那么，这种系统的服务端多半会提供若干个 Web 接口用于被客户端调用。假如某个 Web 接口存在"安全性问题/并发性问题/健壮性问题/XX 问题"，你单纯用黑盒测试的手段，同样难以发现；而灰盒测试就可以搞定（灰盒测试是如何搞定的，请看后续的《 <a href="https://program-think.blogspot.com/2010/12/grey-box-testing-4.html"> 接口测试实战——测试跨主机的模块接口 </a> 》）。 <br /> <br />     <h3 id="section-13"> ◇利于提升测试人员能力 </h3>
 <br /> 很多公司搞的黑盒测试，就是让测试人员用鼠标（键盘都难得用）操作用户界面。在这种的环境里，测试人员干的活，很多都是重复性的体力劳动，技术能力难以得到提高。 <br /> 而如果搞灰盒测试，测试人员就需要多懂一点技术背景知识，必要时还得写点测试脚本，对测试人员的能力提升很有好处。 <br /> <br /> <br />     <h2 id="section-14"> ★相对于白盒测试的好处 </h2>
 <br /> 灰盒测试相对白盒测试的好处，比较容易概括。简单来说，就是白盒测试较费钱（研发成本较高）。这多出来的研发成本，体现在如下几个方面。 <br /> <br />     <h3 id="section-15"> ◇首先，招聘成本较高 </h3>
 <br /> 在人才市场上，100个应聘的测试人员中，未必能够找到一个合适的白盒测试人员。至少从俺及周围同事的面试经历来看，难得碰到具备白盒测试能力的人。所以，你可能要花很长时间才能找到合适的人，时间成本浪费掉了。 <br /> <br />     <h3 id="section-16"> ◇其次，培训成本较高 </h3>
 <br /> 可能有同学会说，招不到就内部培养呗。这个说起来容易，但是培训也是有成本的。而且周期还不短，同样要耗费时间成本。 <br /> <br />     <h3 id="section-17"> ◇再其次，人力成本较高 </h3>
 <br /> 物以稀为贵是一条普遍的经济学规律。由于能搞白盒测试的家伙是稀有动物，你自然不能给他/她开太低的薪水。否则人家待不了多久就跑路了。薪水开得高了，人力成本自然也就提高了。 <br /> <br /> <br />     <h2 id="section-18"> ★其它的一些好处 </h2>
 <br /> 前面拿灰盒测试分别跟黑盒/白盒进行了对比，列举了一些优点。 <br /> 还有另外一些优点，和黑盒/白盒没啥关系，单独列在这里。 <br /> <br />     <h3 id="section-19"> ◇顺便强化开发文档 </h3>
 <br /> 对于一个复杂的软件系统，模块之间的接口是很重要的，因此捏，接口文档也是很重要滴。而开发人员不爱写文档/不爱更新文档，（在软件业内）已经是臭名昭著了。很多软件开发到后期，模块之间的接口文档要么没有，要么和代码实现严重脱节。 <br /> 但是，如果引入测试人员对模块之间的接口进行测试，就可以有效防止此种弊端。因为测试人员在测试前，首先要看模块间的接口文档，然后再根据接口文档设计测试用例，最后再执行用例。因此，一旦接口文档和代码实现不符，立马就露馅了。 <br /> <br />     <h3 id="section-20"> ◇有助于推进“自动化测试” </h3>
 <br /> 灰盒测试如果落实到位，还可以跟自动化测试相结合。一旦做到这点，可以大大提升测试的效率，进而大大提升软件的质量。（如何进行自动化的灰盒测试，后面的帖子会细谈） <br /> <br /> <br />     <h2 id="section-21"> ★灰盒测试有啥缺点？ </h2>
 <br /> 当然，凡事都有优点和缺点，灰盒测试自然也不例外。下面列举它的主要缺点。 <br /> <br />     <h3 id="section-22"> ◇不适用于简单的系统 </h3>
 <br /> 所谓的简单系统，就是简单到总共只有一个模块。由于灰盒测试关注于系统内部模块之间的交互。如果某个系统简单到只有一个模块，那就没必要进行灰盒测试了。 <br /> <br />     <h3 id="section-23"> ◇对测试人员的要求比黑盒测试高 </h3>
 <br /> 从上面的介绍来看，灰盒测试要求测试人员清楚系统内部由哪些模块构成，模块之间如何协作。因此，对测试的要求就提高了。因此，会带来一定的培训成本。不过捏，依照俺的经验，培训难度不大。稍微有点基础的测试人员，都可以在短期培训之后胜任。 <br /> <br />     <h3 id="section-24"> ◇不如白盒测试深入 </h3>
 <br /> 显然，灰盒不如白盒那么深入。不过捏，考虑到灰盒测试相比白盒测试有显著的成本优势，该缺点不是太明显。 <br /> <br /> <br />     <h2 id="section-25"> ★总结 </h2>
 <br /> 总而言之，言而总之，灰盒测试是一个很不错的东东，其优点明显而缺点容易克服。另外，俺前后在两家公司的研发部门推行过，效果不错的说。大伙儿值得去尝试一下。今天光说了优缺点对比，在 <a href="https://program-think.blogspot.com/2010/12/grey-box-testing-2.html"> 下一个帖子 </a> ，俺具体介绍一下，开展灰盒测试之前，管理上有哪些准备工作。 <br /> <br /> <br /> <a href="https://program-think.blogspot.com/2010/11/grey-box-testing-0.html#index"> 回到本系列的目录 </a>     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2010/11/grey-box-testing-1.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2010/11/grey-box-testing-1.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2010-12-15</time>
        <a href="https://nodebe4.github.io/opinion/2010-12-15/%E9%82%A3%E4%BA%9B%E5%AF%B9%E6%8A%97%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96%E7%9A%84%E6%94%BF%E6%9D%83-%E5%92%8C%E5%B9%B3%E5%A5%96%E9%A2%81%E5%A5%96%E8%87%B4%E8%BE%9E%E6%9C%89%E6%84%9F/">
          那些对抗诺贝尔奖的政权——和平奖颁奖致辞有感
        </a>
      </li>
    
    
      <li>
        <time>2010-12-08</time>
        <a href="https://nodebe4.github.io/opinion/2010-12-08/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-2-%E7%AE%A1%E7%90%86%E6%96%B9%E9%9D%A2%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">
          如何开展灰盒测试[2]：管理方面的准备工作
        </a>
      </li>
    
    
      <li>
        <time>2010-11-30</time>
        <a href="https://nodebe4.github.io/opinion/2010-11-30/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-0-%E6%A6%82%E8%BF%B0/">
          如何开展灰盒测试[0]：概述
        </a>
      </li>
    
    
      <li>
        <time>2010-11-24</time>
        <a href="https://nodebe4.github.io/opinion/2010-11-24/%E5%85%9A%E5%9B%BD%E5%BA%94%E5%AF%B9%E7%81%BE%E9%9A%BE%E7%9A%84%E6%A0%87%E5%87%86%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B-%E4%BB%A5%E4%B8%8A%E6%B5%B7%E5%A4%A7%E7%81%AB%E4%B8%BA%E4%BE%8B/">
          党国应对灾难的标准操作流程——以上海大火为例
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2010-11-30/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-0-%E6%A6%82%E8%BF%B0/">
            前一篇：如何开展灰盒测试[0]：概述
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2010-12-03/%E7%9C%8B%E5%9B%BE%E4%B8%8D%E8%AF%B4%E8%AF%9D-%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%89%BE%E5%B7%A5%E4%BD%9C/">
            後一篇：看图不说话：大学生找工作
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2010-11-30/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-0-%E6%A6%82%E8%BF%B0/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2010-12-03/%E7%9C%8B%E5%9B%BE%E4%B8%8D%E8%AF%B4%E8%AF%9D-%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%89%BE%E5%B7%A5%E4%BD%9C/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2010-12-08/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-2-%E7%AE%A1%E7%90%86%E6%96%B9%E9%9D%A2%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2010-11-30/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-0-%E6%A6%82%E8%BF%B0/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2010-11-30/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-0-%E6%A6%82%E8%BF%B0/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2010-12-03/%E7%9C%8B%E5%9B%BE%E4%B8%8D%E8%AF%B4%E8%AF%9D-%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%89%BE%E5%B7%A5%E4%BD%9C/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2010-12-08/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-2-%E7%AE%A1%E7%90%86%E6%96%B9%E9%9D%A2%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2010-11-30/%E5%A6%82%E4%BD%95%E5%BC%80%E5%B1%95%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95-0-%E6%A6%82%E8%BF%B0/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
