<!DOCTYPE html>
<html>
  <head>
  <title>扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      扫盲 HTTPS 和 SSL/TLS 协议[1]：背景知识、协议的需求、设计的难点  
  
    
      
    
  
  
     ★相关背景知识 
  要说清楚 HTTPS 协议的实现原理，至少需要如下几个背景知识。  1. 大致了解几个基本术语（HTTPS、SSL、TLS）的含义  2. 大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”）  3. 大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别）  4. 大致了解 CA 证书的用途  
       
  考虑到很多技术菜鸟可能不了解上述背景，俺先用最简短的文字描述一下。如果你自认为不是菜鸟，请略过本章节，直接去看“HTTPS 协议的需求”。        ◇先澄清几个术语——HTTPS、SSL、TLS 
  
   1. “HTTP”是干嘛用滴？
    首先，HTTP 是一个网络协议，是专门用来帮你传输 Web 内容滴。关于这个协议，就算你不了解，至少也听说过吧？比如你访问俺的博客的主页，浏览器地址栏会出现如下的网址：      

    http
    ://program-think.blogspot.com/    
 俺加了粗体的部分就是指 HTTP 协议。大部分网站都是通过 HTTP 协议来传输 Web 页面、以及 Web 页面上包含的各种东东（图片、CSS 样式、JS 脚本）。  （注：写这篇的时候，Google 的 blogspot 博客平台【尚未】支持全站 HTTPS，所以在上述举例中，主页的网址以 
   http://
   开头）   
   2. “SSL/TLS”是干嘛用滴？
    SSL 是洋文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由  网景公司  设计的。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）  为啥要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。  到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。  很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。   
   3. “HTTPS”是啥意思？
    解释完 HTTP 和 SSL/TLS，现在就可以来解释 HTTPS 啦。咱们通常所说的 HTTPS 协议，说白了就是“HTTP 协议”和“SSL/TLS 协议”的组合。你可以把 HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。        ◇再来说说 HTTP 协议的特点 
  作为背景知识介绍，还需要再稍微谈一下 HTTP 协议本身的特点。HTTP 本身有很多特点，考虑到篇幅有限，俺只谈那些和 HTTPS 相关的特点。   
   1. HTTP 的版本和历史
    如今咱们用的 HTTP 协议，版本号是 1.1（也就是 HTTP 1.1）。这个 1.1 版本是1995年底开始起草的（技术文档是  RFC2068  ），并在1999年正式发布（技术文档是  RFC2616  ）。  在 1.1 之前，还有曾经出现过两个版本“0.9 和 1.0”，其中的 HTTP 0.9 【没有】被广泛使用，而 HTTP 1.0 被广泛使用过。  另外，据说明年（2015）  IETF  就要发布 HTTP 2.0 的标准了。俺拭目以待。   
   2. HTTP 和 TCP 之间的关系
    简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。  
   在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。
   有很多常见的应用层协议是以 TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等。  TCP 被称为“面向连接”的传输层协议。关于它的具体细节，俺就不展开了（否则篇幅又失控了）。你只需知道：传输层主要有两个协议，分别是 TCP 和 UDP。TCP 比 UDP 更可靠。你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达（与之相反，UDP 不保证这点）。   
   3. HTTP 协议如何使用 TCP 连接？
    HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”）  假设有一个网页，里面包含好多图片，还包含好多【外部的】CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）  相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。   在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）；  到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，【默认】采用的是【Keep-Alive】的方式。  【HTTP Keep-Alive】有时候也叫做“HTTP persistent connection”或“HTTP connection reuse”。关于它的更多介绍，可以参见维基百科词条（在“  这里  ”）        ◇谈谈“对称加密”和“非对称加密”的概念 
  
   1. 啥是“加密”和“解密”？
    通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。  “加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东东——叫做“密钥”——来参与数学运算。   
   2. 啥是“对称加密”？
    所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。   
   3. 啥是“非对称加密”？
    所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。  由于篇幅有限，对“非对称加密”这个话题，俺就不展开了。有空的话，再单独写一篇扫盲。   
   4. 各自有啥优缺点？
    看完刚才的定义，很显然：（从功能角度而言）“非对称加密”能干的事情比“对称加密”要多。这是“非对称加密”的优点。但是“非对称加密”的实现，通常需要涉及到“复杂数学问题”。所以，“非对称加密”的性能通常要差很多（相对于“对称加密”而言）。  这两者的优缺点，也影响到了 SSL 协议的设计。        ◇CA 证书的原理及用途 
  关于这方面，请看俺4年前写的《  数字证书及 CA 的扫盲介绍  》。这里就不再重复唠叨了，免得篇幅太长。         ★HTTPS 协议的【需求】是啥？ 
  花了好多口水，终于把背景知识说完了。下面正式进入正题。先来说说当初设计 HTTPS 是为了满足哪些需求？  很多介绍 HTTPS 的文章一上来就给你讲实现细节。个人觉得：这是【不好】的做法。早在2009年开博的时候，发过一篇《  学习技术的三部曲：WHAT、HOW、WHY  》，其中谈到“WHY 型问题”的重要性。如果一上来就丢给你一大堆协议细节，你充其量只能知道 WHAT 和 HOW，无法理解 WHY。俺在前一个章节讲了“背景知识”，在这个章节讲了“需求”，这就有助于你理解：当初【 
   为什么
   】要设计成这样？——这就是 WHY 型的问题。        ◇兼容性 
  因为是先有 HTTP 再有 HTTPS。所以，HTTPS 的设计者肯定要考虑到对原有 HTTP 的兼容性。  这里所说的兼容性包括很多方面。比如已有的 Web 应用要尽可能无缝地迁移到 HTTPS；比如对浏览器厂商而言，改动要尽可能小；......  基于“兼容性”方面的考虑，很容易得出如下几个结论：  1. HTTPS 还是要基于 TCP 来传输  （如果改为 UDP 作传输层，无论是 Web 服务端还是浏览器客户端，都要大改——动静太大，伤筋动骨）  2. 单独使用一个新的协议，把 HTTP 协议包裹起来  （所谓的“HTTP over SSL”，实际上是在原有的 HTTP 数据外面加了一层 SSL 的封装。HTTP 协议原有的 GET、POST 之类的机制，基本上原封不动）   打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。        ◇可扩展性 
  前面说了，HTTPS 相当于是“HTTP over SSL”。  如果 SSL 这个协议在“可扩展性”方面的设计足够牛逼，那么它除了能跟 HTTP 搭配，还能够跟其它的应用层协议搭配。岂不美哉？  现在看来，当初设计 SSL 的人确实比较牛。如今的 SSL/TLS 可以跟很多常用的应用层协议（比如：FTP、SMTP、POP、Telnet）搭配，来强化这些应用层协议的安全性。   接着刚才打的比方：如果把 SSL/TLS 视作一根用来加固的金属管，它不仅可以用来加固输水的管道，还可以用来加固输煤气的管道。        ◇保密性（防泄密） 
  HTTPS 需要做到足够好的保密性。  说到保密性，首先要能够对抗“嗅探”（圈内行话叫 Sniffer）。所谓的“嗅探”，通俗而言就是监视你的网络传输流量。如果你使用【明文】的 HTTP 上网，那么监视者通过嗅探，就知道你在访问哪些网站的哪些页面。  嗅探是最低级的攻击手法。除了嗅探，HTTPS 还需要能对抗其它一些稍微高级的攻击手法——比如“重放攻击”（后面讲协议原理的时候，会再聊）。        ◇完整性（防篡改） 
  除了“保密性”，还有一个同样重要的目标是“确保完整性”。关于“完整性”这个概念，在之前的博文《  扫盲文件完整性校验——关于散列值和数字签名  》中大致提过。健忘的同学再去温习一下。  在发明 HTTPS 之前，由于 HTTP 是明文的，不但容易被嗅探，还容易被篡改。  举个例子：  比如咱们天朝的网络运营商（ISP）都比较流氓，经常有网友抱怨说访问某网站（本来是没有广告的），竟然会跳出很多中国电信的广告。为啥会这样捏？因为你的网络流量需要经过 ISP 的线路才能到达公网。如果你使用的是明文的 HTTP，ISP 很容易就可以在你访问的页面中植入广告。  所以，当初设计 HTTPS 的时候，还有一个需求是“确保 HTTP 协议的内容【不】被篡改”。        ◇真实性（防假冒） 
  在谈到 HTTPS 的需求时，“真实性”经常被忽略。其实“真实性”的重要程度【不亚于】前面的“保密性”和“完整性”。  举个例子：  你因为使用网银，需要访问该网银的 Web 站点。那么，你如何确保你访问的网站确实是你想访问的网站？（这话有点绕口令）  有些天真的同学会说：通过看网址里面的域名，来确保。为啥说这样的同学是“天真的”？因为 DNS 系统本身是不可靠的（尤其是在设计 SSL 的那个年代，连 DNSSEC 都还没发明）。由于 DNS 的不可靠（存在“域名欺骗”和“域名劫持”），你看到的网址里面的域名【未必】是真实滴！  （不了解“域名欺骗”和“域名劫持”的同学，可以参见俺之前写的《  扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染”  》）  所以，HTTPS 协议必须有某种机制来确保“真实性”的需求（至于如何确保，后面会细聊）。        ◇性能 
  再来说最后一个需求——性能。  引入 HTTPS 之后，【不能】导致性能变得太差。否则的话，谁还愿意用？  为了确保性能，SSL 的设计者至少要考虑如下几点：  1. 如何选择加密算法（“对称”or“非对称”）？  2. 如何兼顾 HTTP 采用的【短连接】TCP 方式？  （再次提醒：SSL 是在1995年之前开始设计滴。那是 Web 的远古时代——HTTP 协议版本还只是 1.0；默认使用【短连接】的 TCP 方式；默认【不】启用 Keep-Alive）        ◇小结 
  以上就是设计 SSL 协议时，必须兼顾的各种需求。后面聊协议的实现时，俺会拿 SSL 协议的特点跟前面的需求作对照。看看这些需求是如何被逐一满足滴。         ★设计 HTTPS 协议的主要【难点】是啥？ 
  设计 HTTPS 这个协议，有好几个难点。俺个人认为：“密钥交换”是最大的难点（没有之一）。  在传统的密码学场景中，假如张三要跟李四建立一个加密通讯的渠道，双方事先要约定好使用哪种加密算法？同时也要约定好使用的密钥是啥？在这个场景中，加密算法的【类型】让旁人知道，没太大关系。但是密钥【千万不能】让旁人知道。一旦旁人知道了密钥，自然就可以破解通讯的密文，得到明文。  好，现在回到 HTTPS 的场景。  当你访问某个公网的网站，你的浏览器和网站的服务器之间，如果要建立加密通讯，必然要商量好双方使用啥算法，啥密钥。——在网络通讯术语中，这个过程称之为“握手”（洋文叫“handshake”）。在握手阶段，因为加密方式还没有协商好，所以握手阶段的通讯必定是【明文】滴！既然是明文，自然有可能被第三方偷窥到。然后，还要考虑到双方之间隔着一个【互联网】，啥样的事情都可能发生（不光会有“数据偷窥”，还会有【数据篡改】）。  因此，在握手的过程中，如何做到安全地交换密钥信息，而不让周围的第三方看到。这就是设计 HTTPS 最大的难点。         ★结尾 
  本文费这么多口水，来介绍 HTTPS 的“需求”和“难点”，为啥捏？因为只有当你了解这些，后面介绍 SSL/TLS 的实现原理时，你才能理解——当初为啥要把协议设计成这个样子。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      扫盲 HTTPS 和 SSL/TLS 协议[1]：背景知识、协议的需求、设计的难点  
  
    
      
    
  
  
     ★相关背景知识 
  要说清楚 HTTPS 协议的实现原理，至少需要如下几个背景知识。  1. 大致了解几个基本术语（HTTPS、SSL、TLS）的含义  2. 大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”）  3. 大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别）  4. 大致了解 CA 证书的用途  
       
  考虑到很多技术菜鸟可能不了解上述背景，俺先用最简短的文字描述一下。如果你自认为不是菜鸟，请略过本章节，直接去看“HTTPS 协议的需求”。        ◇先澄清几个术语——HTTPS、SSL、TLS 
  
   1. “HTTP”是干嘛用滴？
    首先，HTTP 是一个网络协议，是专门用来帮你传输 Web 内容滴。关于这个协议，就算你不了解，至少也听说过吧？比如你访问俺的博客的主页，浏览器地址栏会出现如下的网址：      

    http
    ://program-think.blogspot.com/    
 俺加了粗体的部分就是指 HTTP 协议。大部分网站都是通过 HTTP 协议来传输 Web 页面、以及 Web 页面上包含的各种东东（图片、CSS 样式、JS 脚本）。  （注：写这篇的时候，Google 的 blogspot 博客平台【尚未】支持全站 HTTPS，所以在上述举例中，主页的网址以 
   http://
   开头）   
   2. “SSL/TLS”是干嘛用滴？
    SSL 是洋文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由  网景公司  设计的。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）  为啥要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。  到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。  很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。   
   3. “HTTPS”是啥意思？
    解释完 HTTP 和 SSL/TLS，现在就可以来解释 HTTPS 啦。咱们通常所说的 HTTPS 协议，说白了就是“HTTP 协议”和“SSL/TLS 协议”的组合。你可以把 HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。        ◇再来说说 HTTP 协议的特点 
  作为背景知识介绍，还需要再稍微谈一下 HTTP 协议本身的特点。HTTP 本身有很多特点，考虑到篇幅有限，俺只谈那些和 HTTPS 相关的特点。   
   1. HTTP 的版本和历史
    如今咱们用的 HTTP 协议，版本号是 1.1（也就是 HTTP 1.1）。这个 1.1 版本是1995年底开始起草的（技术文档是  RFC2068  ），并在1999年正式发布（技术文档是  RFC2616  ）。  在 1.1 之前，还有曾经出现过两个版本“0.9 和 1.0”，其中的 HTTP 0.9 【没有】被广泛使用，而 HTTP 1.0 被广泛使用过。  另外，据说明年（2015）  IETF  就要发布 HTTP 2.0 的标准了。俺拭目以待。   
   2. HTTP 和 TCP 之间的关系
    简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。  
   在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。
   有很多常见的应用层协议是以 TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等。  TCP 被称为“面向连接”的传输层协议。关于它的具体细节，俺就不展开了（否则篇幅又失控了）。你只需知道：传输层主要有两个协议，分别是 TCP 和 UDP。TCP 比 UDP 更可靠。你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达（与之相反，UDP 不保证这点）。   
   3. HTTP 协议如何使用 TCP 连接？
    HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”）  假设有一个网页，里面包含好多图片，还包含好多【外部的】CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）  相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。   在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）；  到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，【默认】采用的是【Keep-Alive】的方式。  【HTTP Keep-Alive】有时候也叫做“HTTP persistent connection”或“HTTP connection reuse”。关于它的更多介绍，可以参见维基百科词条（在“  这里  ”）        ◇谈谈“对称加密”和“非对称加密”的概念 
  
   1. 啥是“加密”和“解密”？
    通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。  “加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东东——叫做“密钥”——来参与数学运算。   
   2. 啥是“对称加密”？
    所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。   
   3. 啥是“非对称加密”？
    所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。  由于篇幅有限，对“非对称加密”这个话题，俺就不展开了。有空的话，再单独写一篇扫盲。   
   4. 各自有啥优缺点？
    看完刚才的定义，很显然：（从功能角度而言）“非对称加密”能干的事情比“对称加密”要多。这是“非对称加密”的优点。但是“非对称加密”的实现，通常需要涉及到“复杂数学问题”。所以，“非对称加密”的性能通常要差很多（相对于“对称加密”而言）。  这两者的优缺点，也影响到了 SSL 协议的设计。        ◇CA 证书的原理及用途 
  关于这方面，请看俺4年前写的《  数字证书及 CA 的扫盲介绍  》。这里就不再重复唠叨了，免得篇幅太长。         ★HTTPS 协议的【需求】是啥？ 
  花了好多口水，终于把背景知识说完了。下面正式进入正题。先来说说当初设计 HTTPS 是为了满足哪些需求？  很多介绍 HTTPS 的文章一上来就给你讲实现细节。个人觉得：这是【不好】的做法。早在2009年开博的时候，发过一篇《  学习技术的三部曲：WHAT、HOW、WHY  》，其中谈到“WHY 型问题”的重要性。如果一上来就丢给你一大堆协议细节，你充其量只能知道 WHAT 和 HOW，无法理解 WHY。俺在前一个章节讲了“背景知识”，在这个章节讲了“需求”，这就有助于你理解：当初【 
   为什么
   】要设计成这样？——这就是 WHY 型的问题。        ◇兼容性 
  因为是先有 HTTP 再有 HTTPS。所以，HTTPS 的设计者肯定要考虑到对原有 HTTP 的兼容性。  这里所说的兼容性包括很多方面。比如已有的 Web 应用要尽可能无缝地迁移到 HTTPS；比如对浏览器厂商而言，改动要尽可能小；......  基于“兼容性”方面的考虑，很容易得出如下几个结论：  1. HTTPS 还是要基于 TCP 来传输  （如果改为 UDP 作传输层，无论是 Web 服务端还是浏览器客户端，都要大改——动静太大，伤筋动骨）  2. 单独使用一个新的协议，把 HTTP 协议包裹起来  （所谓的“HTTP over SSL”，实际上是在原有的 HTTP 数据外面加了一层 SSL 的封装。HTTP 协议原有的 GET、POST 之类的机制，基本上原封不动）   打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。        ◇可扩展性 
  前面说了，HTTPS 相当于是“HTTP over SSL”。  如果 SSL 这个协议在“可扩展性”方面的设计足够牛逼，那么它除了能跟 HTTP 搭配，还能够跟其它的应用层协议搭配。岂不美哉？  现在看来，当初设计 SSL 的人确实比较牛。如今的 SSL/TLS 可以跟很多常用的应用层协议（比如：FTP、SMTP、POP、Telnet）搭配，来强化这些应用层协议的安全性。   接着刚才打的比方：如果把 SSL/TLS 视作一根用来加固的金属管，它不仅可以用来加固输水的管道，还可以用来加固输煤气的管道。        ◇保密性（防泄密） 
  HTTPS 需要做到足够好的保密性。  说到保密性，首先要能够对抗“嗅探”（圈内行话叫 Sniffer）。所谓的“嗅探”，通俗而言就是监视你的网络传输流量。如果你使用【明文】的 HTTP 上网，那么监视者通过嗅探，就知道你在访问哪些网站的哪些页面。  嗅探是最低级的攻击手法。除了嗅探，HTTPS 还需要能对抗其它一些稍微高级的攻击手法——比如“重放攻击”（后面讲协议原理的时候，会再聊）。        ◇完整性（防篡改） 
  除了“保密性”，还有一个同样重要的目标是“确保完整性”。关于“完整性”这个概念，在之前的博文《  扫盲文件完整性校验——关于散列值和数字签名  》中大致提过。健忘的同学再去温习一下。  在发明 HTTPS 之前，由于 HTTP 是明文的，不但容易被嗅探，还容易被篡改。  举个例子：  比如咱们天朝的网络运营商（ISP）都比较流氓，经常有网友抱怨说访问某网站（本来是没有广告的），竟然会跳出很多中国电信的广告。为啥会这样捏？因为你的网络流量需要经过 ISP 的线路才能到达公网。如果你使用的是明文的 HTTP，ISP 很容易就可以在你访问的页面中植入广告。  所以，当初设计 HTTPS 的时候，还有一个需求是“确保 HTTP 协议的内容【不】被篡改”。        ◇真实性（防假冒） 
  在谈到 HTTPS 的需求时，“真实性”经常被忽略。其实“真实性”的重要程度【不亚于】前面的“保密性”和“完整性”。  举个例子：  你因为使用网银，需要访问该网银的 Web 站点。那么，你如何确保你访问的网站确实是你想访问的网站？（这话有点绕口令）  有些天真的同学会说：通过看网址里面的域名，来确保。为啥说这样的同学是“天真的”？因为 DNS 系统本身是不可靠的（尤其是在设计 SSL 的那个年代，连 DNSSEC 都还没发明）。由于 DNS 的不可靠（存在“域名欺骗”和“域名劫持”），你看到的网址里面的域名【未必】是真实滴！  （不了解“域名欺骗”和“域名劫持”的同学，可以参见俺之前写的《  扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染”  》）  所以，HTTPS 协议必须有某种机制来确保“真实性”的需求（至于如何确保，后面会细聊）。        ◇性能 
  再来说最后一个需求——性能。  引入 HTTPS 之后，【不能】导致性能变得太差。否则的话，谁还愿意用？  为了确保性能，SSL 的设计者至少要考虑如下几点：  1. 如何选择加密算法（“对称”or“非对称”）？  2. 如何兼顾 HTTP 采用的【短连接】TCP 方式？  （再次提醒：SSL 是在1995年之前开始设计滴。那是 Web 的远古时代——HTTP 协议版本还只是 1.0；默认使用【短连接】的 TCP 方式；默认【不】启用 Keep-Alive）        ◇小结 
  以上就是设计 SSL 协议时，必须兼顾的各种需求。后面聊协议的实现时，俺会拿 SSL 协议的特点跟前面的需求作对照。看看这些需求是如何被逐一满足滴。         ★设计 HTTPS 协议的主要【难点】是啥？ 
  设计 HTTPS 这个协议，有好几个难点。俺个人认为：“密钥交换”是最大的难点（没有之一）。  在传统的密码学场景中，假如张三要跟李四建立一个加密通讯的渠道，双方事先要约定好使用哪种加密算法？同时也要约定好使用的密钥是啥？在这个场景中，加密算法的【类型】让旁人知道，没太大关系。但是密钥【千万不能】让旁人知道。一旦旁人知道了密钥，自然就可以破解通讯的密文，得到明文。  好，现在回到 HTTPS 的场景。  当你访问某个公网的网站，你的浏览器和网站的服务器之间，如果要建立加密通讯，必然要商量好双方使用啥算法，啥密钥。——在网络通讯术语中，这个过程称之为“握手”（洋文叫“handshake”）。在握手阶段，因为加密方式还没有协商好，所以握手阶段的通讯必定是【明文】滴！既然是明文，自然有可能被第三方偷窥到。然后，还要考虑到双方之间隔着一个【互联网】，啥样的事情都可能发生（不光会有“数据偷窥”，还会有【数据篡改】）。  因此，在握手的过程中，如何做到安全地交换密钥信息，而不让周围的第三方看到。这就是设计 HTTPS 最大的难点。         ★结尾 
  本文费这么多口水，来介绍 HTTPS 的“需求”和“难点”，为啥捏？因为只有当你了解这些，后面介绍 SSL/TLS 的实现原理时，你才能理解——当初为啥要把协议设计成这个样子。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点" />
    <meta property="twitter:title" content="扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17489)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2014%2F11%2Fhttps-ssl-tls-1.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html&text=扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html&title=扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html&title=扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点&body=

      扫盲 HTTPS 和 SSL/TLS 协议[1]：背景知识、协议的需求、设计的难点  
  
    
      
    
  
  
     ★相关背景知识 
  要说清楚 HTTPS 协议的实现原理，至少需要如下几个背景知识。  1. 大致了解几个基本术语（HTTPS、SSL、TLS）的含义  2. 大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”）  3. 大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别）  4. 大致了解 CA 证书的用途  
       
  考虑到很多技术菜鸟可能不了解上述背景，俺先用最简短的文字描述一下。如果你自认为不是菜鸟，请略过本章节，直接去看“HTTPS 协议的需求”。        ◇先澄清几个术语——HTTPS、SSL、TLS 
  
   1. “HTTP”是干嘛用滴？
    首先，HTTP 是一个网络协议，是专门用来帮你传输 Web 内容滴。关于这个协议，就算你不了解，至少也听说过吧？比如你访问俺的博客的主页，浏览器地址栏会出现如下的网址：      

    http
    ://program-think.blogspot.com/    
 俺加了粗体的部分就是指 HTTP 协议。大部分网站都是通过 HTTP 协议来传输 Web 页面、以及 Web 页面上包含的各种东东（图片、CSS 样式、JS 脚本）。  （注：写这篇的时候，Google 的 blogspot 博客平台【尚未】支持全站 HTTPS，所以在上述举例中，主页的网址以 
   http://
   开头）   
   2. “SSL/TLS”是干嘛用滴？
    SSL 是洋文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由  网景公司  设计的。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）  为啥要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。  到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。  很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。   
   3. “HTTPS”是啥意思？
    解释完 HTTP 和 SSL/TLS，现在就可以来解释 HTTPS 啦。咱们通常所说的 HTTPS 协议，说白了就是“HTTP 协议”和“SSL/TLS 协议”的组合。你可以把 HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。        ◇再来说说 HTTP 协议的特点 
  作为背景知识介绍，还需要再稍微谈一下 HTTP 协议本身的特点。HTTP 本身有很多特点，考虑到篇幅有限，俺只谈那些和 HTTPS 相关的特点。   
   1. HTTP 的版本和历史
    如今咱们用的 HTTP 协议，版本号是 1.1（也就是 HTTP 1.1）。这个 1.1 版本是1995年底开始起草的（技术文档是  RFC2068  ），并在1999年正式发布（技术文档是  RFC2616  ）。  在 1.1 之前，还有曾经出现过两个版本“0.9 和 1.0”，其中的 HTTP 0.9 【没有】被广泛使用，而 HTTP 1.0 被广泛使用过。  另外，据说明年（2015）  IETF  就要发布 HTTP 2.0 的标准了。俺拭目以待。   
   2. HTTP 和 TCP 之间的关系
    简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。  
   在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。
   有很多常见的应用层协议是以 TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等。  TCP 被称为“面向连接”的传输层协议。关于它的具体细节，俺就不展开了（否则篇幅又失控了）。你只需知道：传输层主要有两个协议，分别是 TCP 和 UDP。TCP 比 UDP 更可靠。你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达（与之相反，UDP 不保证这点）。   
   3. HTTP 协议如何使用 TCP 连接？
    HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”）  假设有一个网页，里面包含好多图片，还包含好多【外部的】CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）  相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。   在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）；  到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，【默认】采用的是【Keep-Alive】的方式。  【HTTP Keep-Alive】有时候也叫做“HTTP persistent connection”或“HTTP connection reuse”。关于它的更多介绍，可以参见维基百科词条（在“  这里  ”）        ◇谈谈“对称加密”和“非对称加密”的概念 
  
   1. 啥是“加密”和“解密”？
    通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。  “加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东东——叫做“密钥”——来参与数学运算。   
   2. 啥是“对称加密”？
    所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。   
   3. 啥是“非对称加密”？
    所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。  由于篇幅有限，对“非对称加密”这个话题，俺就不展开了。有空的话，再单独写一篇扫盲。   
   4. 各自有啥优缺点？
    看完刚才的定义，很显然：（从功能角度而言）“非对称加密”能干的事情比“对称加密”要多。这是“非对称加密”的优点。但是“非对称加密”的实现，通常需要涉及到“复杂数学问题”。所以，“非对称加密”的性能通常要差很多（相对于“对称加密”而言）。  这两者的优缺点，也影响到了 SSL 协议的设计。        ◇CA 证书的原理及用途 
  关于这方面，请看俺4年前写的《  数字证书及 CA 的扫盲介绍  》。这里就不再重复唠叨了，免得篇幅太长。         ★HTTPS 协议的【需求】是啥？ 
  花了好多口水，终于把背景知识说完了。下面正式进入正题。先来说说当初设计 HTTPS 是为了满足哪些需求？  很多介绍 HTTPS 的文章一上来就给你讲实现细节。个人觉得：这是【不好】的做法。早在2009年开博的时候，发过一篇《  学习技术的三部曲：WHAT、HOW、WHY  》，其中谈到“WHY 型问题”的重要性。如果一上来就丢给你一大堆协议细节，你充其量只能知道 WHAT 和 HOW，无法理解 WHY。俺在前一个章节讲了“背景知识”，在这个章节讲了“需求”，这就有助于你理解：当初【 
   为什么
   】要设计成这样？——这就是 WHY 型的问题。        ◇兼容性 
  因为是先有 HTTP 再有 HTTPS。所以，HTTPS 的设计者肯定要考虑到对原有 HTTP 的兼容性。  这里所说的兼容性包括很多方面。比如已有的 Web 应用要尽可能无缝地迁移到 HTTPS；比如对浏览器厂商而言，改动要尽可能小；......  基于“兼容性”方面的考虑，很容易得出如下几个结论：  1. HTTPS 还是要基于 TCP 来传输  （如果改为 UDP 作传输层，无论是 Web 服务端还是浏览器客户端，都要大改——动静太大，伤筋动骨）  2. 单独使用一个新的协议，把 HTTP 协议包裹起来  （所谓的“HTTP over SSL”，实际上是在原有的 HTTP 数据外面加了一层 SSL 的封装。HTTP 协议原有的 GET、POST 之类的机制，基本上原封不动）   打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。        ◇可扩展性 
  前面说了，HTTPS 相当于是“HTTP over SSL”。  如果 SSL 这个协议在“可扩展性”方面的设计足够牛逼，那么它除了能跟 HTTP 搭配，还能够跟其它的应用层协议搭配。岂不美哉？  现在看来，当初设计 SSL 的人确实比较牛。如今的 SSL/TLS 可以跟很多常用的应用层协议（比如：FTP、SMTP、POP、Telnet）搭配，来强化这些应用层协议的安全性。   接着刚才打的比方：如果把 SSL/TLS 视作一根用来加固的金属管，它不仅可以用来加固输水的管道，还可以用来加固输煤气的管道。        ◇保密性（防泄密） 
  HTTPS 需要做到足够好的保密性。  说到保密性，首先要能够对抗“嗅探”（圈内行话叫 Sniffer）。所谓的“嗅探”，通俗而言就是监视你的网络传输流量。如果你使用【明文】的 HTTP 上网，那么监视者通过嗅探，就知道你在访问哪些网站的哪些页面。  嗅探是最低级的攻击手法。除了嗅探，HTTPS 还需要能对抗其它一些稍微高级的攻击手法——比如“重放攻击”（后面讲协议原理的时候，会再聊）。        ◇完整性（防篡改） 
  除了“保密性”，还有一个同样重要的目标是“确保完整性”。关于“完整性”这个概念，在之前的博文《  扫盲文件完整性校验——关于散列值和数字签名  》中大致提过。健忘的同学再去温习一下。  在发明 HTTPS 之前，由于 HTTP 是明文的，不但容易被嗅探，还容易被篡改。  举个例子：  比如咱们天朝的网络运营商（ISP）都比较流氓，经常有网友抱怨说访问某网站（本来是没有广告的），竟然会跳出很多中国电信的广告。为啥会这样捏？因为你的网络流量需要经过 ISP 的线路才能到达公网。如果你使用的是明文的 HTTP，ISP 很容易就可以在你访问的页面中植入广告。  所以，当初设计 HTTPS 的时候，还有一个需求是“确保 HTTP 协议的内容【不】被篡改”。        ◇真实性（防假冒） 
  在谈到 HTTPS 的需求时，“真实性”经常被忽略。其实“真实性”的重要程度【不亚于】前面的“保密性”和“完整性”。  举个例子：  你因为使用网银，需要访问该网银的 Web 站点。那么，你如何确保你访问的网站确实是你想访问的网站？（这话有点绕口令）  有些天真的同学会说：通过看网址里面的域名，来确保。为啥说这样的同学是“天真的”？因为 DNS 系统本身是不可靠的（尤其是在设计 SSL 的那个年代，连 DNSSEC 都还没发明）。由于 DNS 的不可靠（存在“域名欺骗”和“域名劫持”），你看到的网址里面的域名【未必】是真实滴！  （不了解“域名欺骗”和“域名劫持”的同学，可以参见俺之前写的《  扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染”  》）  所以，HTTPS 协议必须有某种机制来确保“真实性”的需求（至于如何确保，后面会细聊）。        ◇性能 
  再来说最后一个需求——性能。  引入 HTTPS 之后，【不能】导致性能变得太差。否则的话，谁还愿意用？  为了确保性能，SSL 的设计者至少要考虑如下几点：  1. 如何选择加密算法（“对称”or“非对称”）？  2. 如何兼顾 HTTP 采用的【短连接】TCP 方式？  （再次提醒：SSL 是在1995年之前开始设计滴。那是 Web 的远古时代——HTTP 协议版本还只是 1.0；默认使用【短连接】的 TCP 方式；默认【不】启用 Keep-Alive）        ◇小结 
  以上就是设计 SSL 协议时，必须兼顾的各种需求。后面聊协议的实现时，俺会拿 SSL 协议的特点跟前面的需求作对照。看看这些需求是如何被逐一满足滴。         ★设计 HTTPS 协议的主要【难点】是啥？ 
  设计 HTTPS 这个协议，有好几个难点。俺个人认为：“密钥交换”是最大的难点（没有之一）。  在传统的密码学场景中，假如张三要跟李四建立一个加密通讯的渠道，双方事先要约定好使用哪种加密算法？同时也要约定好使用的密钥是啥？在这个场景中，加密算法的【类型】让旁人知道，没太大关系。但是密钥【千万不能】让旁人知道。一旦旁人知道了密钥，自然就可以破解通讯的密文，得到明文。  好，现在回到 HTTPS 的场景。  当你访问某个公网的网站，你的浏览器和网站的服务器之间，如果要建立加密通讯，必然要商量好双方使用啥算法，啥密钥。——在网络通讯术语中，这个过程称之为“握手”（洋文叫“handshake”）。在握手阶段，因为加密方式还没有协商好，所以握手阶段的通讯必定是【明文】滴！既然是明文，自然有可能被第三方偷窥到。然后，还要考虑到双方之间隔着一个【互联网】，啥样的事情都可能发生（不光会有“数据偷窥”，还会有【数据篡改】）。  因此，在握手的过程中，如何做到安全地交换密钥信息，而不让周围的第三方看到。这就是设计 HTTPS 最大的难点。         ★结尾 
  本文费这么多口水，来介绍 HTTPS 的“需求”和“难点”，为啥捏？因为只有当你了解这些，后面介绍 SSL/TLS 的实现原理时，你才能理解——当初为啥要把协议设计成这个样子。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html&title=扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点&caption=

      扫盲 HTTPS 和 SSL/TLS 协议[1]：背景知识、协议的需求、设计的难点  
  
    
      
    
  
  
     ★相关背景知识 
  要说清楚 HTTPS 协议的实现原理，至少需要如下几个背景知识。  1. 大致了解几个基本术语（HTTPS、SSL、TLS）的含义  2. 大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”）  3. 大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别）  4. 大致了解 CA 证书的用途  
       
  考虑到很多技术菜鸟可能不了解上述背景，俺先用最简短的文字描述一下。如果你自认为不是菜鸟，请略过本章节，直接去看“HTTPS 协议的需求”。        ◇先澄清几个术语——HTTPS、SSL、TLS 
  
   1. “HTTP”是干嘛用滴？
    首先，HTTP 是一个网络协议，是专门用来帮你传输 Web 内容滴。关于这个协议，就算你不了解，至少也听说过吧？比如你访问俺的博客的主页，浏览器地址栏会出现如下的网址：      

    http
    ://program-think.blogspot.com/    
 俺加了粗体的部分就是指 HTTP 协议。大部分网站都是通过 HTTP 协议来传输 Web 页面、以及 Web 页面上包含的各种东东（图片、CSS 样式、JS 脚本）。  （注：写这篇的时候，Google 的 blogspot 博客平台【尚未】支持全站 HTTPS，所以在上述举例中，主页的网址以 
   http://
   开头）   
   2. “SSL/TLS”是干嘛用滴？
    SSL 是洋文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由  网景公司  设计的。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”）  为啥要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。  到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。  很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。   
   3. “HTTPS”是啥意思？
    解释完 HTTP 和 SSL/TLS，现在就可以来解释 HTTPS 啦。咱们通常所说的 HTTPS 协议，说白了就是“HTTP 协议”和“SSL/TLS 协议”的组合。你可以把 HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。        ◇再来说说 HTTP 协议的特点 
  作为背景知识介绍，还需要再稍微谈一下 HTTP 协议本身的特点。HTTP 本身有很多特点，考虑到篇幅有限，俺只谈那些和 HTTPS 相关的特点。   
   1. HTTP 的版本和历史
    如今咱们用的 HTTP 协议，版本号是 1.1（也就是 HTTP 1.1）。这个 1.1 版本是1995年底开始起草的（技术文档是  RFC2068  ），并在1999年正式发布（技术文档是  RFC2616  ）。  在 1.1 之前，还有曾经出现过两个版本“0.9 和 1.0”，其中的 HTTP 0.9 【没有】被广泛使用，而 HTTP 1.0 被广泛使用过。  另外，据说明年（2015）  IETF  就要发布 HTTP 2.0 的标准了。俺拭目以待。   
   2. HTTP 和 TCP 之间的关系
    简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。  
   在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。
   有很多常见的应用层协议是以 TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等。  TCP 被称为“面向连接”的传输层协议。关于它的具体细节，俺就不展开了（否则篇幅又失控了）。你只需知道：传输层主要有两个协议，分别是 TCP 和 UDP。TCP 比 UDP 更可靠。你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达（与之相反，UDP 不保证这点）。   
   3. HTTP 协议如何使用 TCP 连接？
    HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”）  假设有一个网页，里面包含好多图片，还包含好多【外部的】CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）  相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。   在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）；  到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，【默认】采用的是【Keep-Alive】的方式。  【HTTP Keep-Alive】有时候也叫做“HTTP persistent connection”或“HTTP connection reuse”。关于它的更多介绍，可以参见维基百科词条（在“  这里  ”）        ◇谈谈“对称加密”和“非对称加密”的概念 
  
   1. 啥是“加密”和“解密”？
    通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。  “加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东东——叫做“密钥”——来参与数学运算。   
   2. 啥是“对称加密”？
    所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。   
   3. 啥是“非对称加密”？
    所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。  由于篇幅有限，对“非对称加密”这个话题，俺就不展开了。有空的话，再单独写一篇扫盲。   
   4. 各自有啥优缺点？
    看完刚才的定义，很显然：（从功能角度而言）“非对称加密”能干的事情比“对称加密”要多。这是“非对称加密”的优点。但是“非对称加密”的实现，通常需要涉及到“复杂数学问题”。所以，“非对称加密”的性能通常要差很多（相对于“对称加密”而言）。  这两者的优缺点，也影响到了 SSL 协议的设计。        ◇CA 证书的原理及用途 
  关于这方面，请看俺4年前写的《  数字证书及 CA 的扫盲介绍  》。这里就不再重复唠叨了，免得篇幅太长。         ★HTTPS 协议的【需求】是啥？ 
  花了好多口水，终于把背景知识说完了。下面正式进入正题。先来说说当初设计 HTTPS 是为了满足哪些需求？  很多介绍 HTTPS 的文章一上来就给你讲实现细节。个人觉得：这是【不好】的做法。早在2009年开博的时候，发过一篇《  学习技术的三部曲：WHAT、HOW、WHY  》，其中谈到“WHY 型问题”的重要性。如果一上来就丢给你一大堆协议细节，你充其量只能知道 WHAT 和 HOW，无法理解 WHY。俺在前一个章节讲了“背景知识”，在这个章节讲了“需求”，这就有助于你理解：当初【 
   为什么
   】要设计成这样？——这就是 WHY 型的问题。        ◇兼容性 
  因为是先有 HTTP 再有 HTTPS。所以，HTTPS 的设计者肯定要考虑到对原有 HTTP 的兼容性。  这里所说的兼容性包括很多方面。比如已有的 Web 应用要尽可能无缝地迁移到 HTTPS；比如对浏览器厂商而言，改动要尽可能小；......  基于“兼容性”方面的考虑，很容易得出如下几个结论：  1. HTTPS 还是要基于 TCP 来传输  （如果改为 UDP 作传输层，无论是 Web 服务端还是浏览器客户端，都要大改——动静太大，伤筋动骨）  2. 单独使用一个新的协议，把 HTTP 协议包裹起来  （所谓的“HTTP over SSL”，实际上是在原有的 HTTP 数据外面加了一层 SSL 的封装。HTTP 协议原有的 GET、POST 之类的机制，基本上原封不动）   打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。        ◇可扩展性 
  前面说了，HTTPS 相当于是“HTTP over SSL”。  如果 SSL 这个协议在“可扩展性”方面的设计足够牛逼，那么它除了能跟 HTTP 搭配，还能够跟其它的应用层协议搭配。岂不美哉？  现在看来，当初设计 SSL 的人确实比较牛。如今的 SSL/TLS 可以跟很多常用的应用层协议（比如：FTP、SMTP、POP、Telnet）搭配，来强化这些应用层协议的安全性。   接着刚才打的比方：如果把 SSL/TLS 视作一根用来加固的金属管，它不仅可以用来加固输水的管道，还可以用来加固输煤气的管道。        ◇保密性（防泄密） 
  HTTPS 需要做到足够好的保密性。  说到保密性，首先要能够对抗“嗅探”（圈内行话叫 Sniffer）。所谓的“嗅探”，通俗而言就是监视你的网络传输流量。如果你使用【明文】的 HTTP 上网，那么监视者通过嗅探，就知道你在访问哪些网站的哪些页面。  嗅探是最低级的攻击手法。除了嗅探，HTTPS 还需要能对抗其它一些稍微高级的攻击手法——比如“重放攻击”（后面讲协议原理的时候，会再聊）。        ◇完整性（防篡改） 
  除了“保密性”，还有一个同样重要的目标是“确保完整性”。关于“完整性”这个概念，在之前的博文《  扫盲文件完整性校验——关于散列值和数字签名  》中大致提过。健忘的同学再去温习一下。  在发明 HTTPS 之前，由于 HTTP 是明文的，不但容易被嗅探，还容易被篡改。  举个例子：  比如咱们天朝的网络运营商（ISP）都比较流氓，经常有网友抱怨说访问某网站（本来是没有广告的），竟然会跳出很多中国电信的广告。为啥会这样捏？因为你的网络流量需要经过 ISP 的线路才能到达公网。如果你使用的是明文的 HTTP，ISP 很容易就可以在你访问的页面中植入广告。  所以，当初设计 HTTPS 的时候，还有一个需求是“确保 HTTP 协议的内容【不】被篡改”。        ◇真实性（防假冒） 
  在谈到 HTTPS 的需求时，“真实性”经常被忽略。其实“真实性”的重要程度【不亚于】前面的“保密性”和“完整性”。  举个例子：  你因为使用网银，需要访问该网银的 Web 站点。那么，你如何确保你访问的网站确实是你想访问的网站？（这话有点绕口令）  有些天真的同学会说：通过看网址里面的域名，来确保。为啥说这样的同学是“天真的”？因为 DNS 系统本身是不可靠的（尤其是在设计 SSL 的那个年代，连 DNSSEC 都还没发明）。由于 DNS 的不可靠（存在“域名欺骗”和“域名劫持”），你看到的网址里面的域名【未必】是真实滴！  （不了解“域名欺骗”和“域名劫持”的同学，可以参见俺之前写的《  扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染”  》）  所以，HTTPS 协议必须有某种机制来确保“真实性”的需求（至于如何确保，后面会细聊）。        ◇性能 
  再来说最后一个需求——性能。  引入 HTTPS 之后，【不能】导致性能变得太差。否则的话，谁还愿意用？  为了确保性能，SSL 的设计者至少要考虑如下几点：  1. 如何选择加密算法（“对称”or“非对称”）？  2. 如何兼顾 HTTP 采用的【短连接】TCP 方式？  （再次提醒：SSL 是在1995年之前开始设计滴。那是 Web 的远古时代——HTTP 协议版本还只是 1.0；默认使用【短连接】的 TCP 方式；默认【不】启用 Keep-Alive）        ◇小结 
  以上就是设计 SSL 协议时，必须兼顾的各种需求。后面聊协议的实现时，俺会拿 SSL 协议的特点跟前面的需求作对照。看看这些需求是如何被逐一满足滴。         ★设计 HTTPS 协议的主要【难点】是啥？ 
  设计 HTTPS 这个协议，有好几个难点。俺个人认为：“密钥交换”是最大的难点（没有之一）。  在传统的密码学场景中，假如张三要跟李四建立一个加密通讯的渠道，双方事先要约定好使用哪种加密算法？同时也要约定好使用的密钥是啥？在这个场景中，加密算法的【类型】让旁人知道，没太大关系。但是密钥【千万不能】让旁人知道。一旦旁人知道了密钥，自然就可以破解通讯的密文，得到明文。  好，现在回到 HTTPS 的场景。  当你访问某个公网的网站，你的浏览器和网站的服务器之间，如果要建立加密通讯，必然要商量好双方使用啥算法，啥密钥。——在网络通讯术语中，这个过程称之为“握手”（洋文叫“handshake”）。在握手阶段，因为加密方式还没有协商好，所以握手阶段的通讯必定是【明文】滴！既然是明文，自然有可能被第三方偷窥到。然后，还要考虑到双方之间隔着一个【互联网】，啥样的事情都可能发生（不光会有“数据偷窥”，还会有【数据篡改】）。  因此，在握手的过程中，如何做到安全地交换密钥信息，而不让周围的第三方看到。这就是设计 HTTPS 最大的难点。         ★结尾 
  本文费这么多口水，来介绍 HTTPS 的“需求”和“难点”，为啥捏？因为只有当你了解这些，后面介绍 SSL/TLS 的实现原理时，你才能理解——当初为啥要把协议设计成这个样子。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点&url=https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2014-11-08
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="8380087561999960001">
 </a>   <h1 class="post-title entry-title" id="https--ssltls-1--"> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html"> 扫盲 HTTPS 和 SSL/TLS 协议[1]：背景知识、协议的需求、设计的难点 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
    <h2 id="section"> ★相关背景知识 </h2>
 <br /> 要说清楚 HTTPS 协议的实现原理，至少需要如下几个背景知识。 <br /> 1. 大致了解几个基本术语（HTTPS、SSL、TLS）的含义 <br /> 2. 大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”） <br /> 3. 大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别） <br /> 4. 大致了解 CA 证书的用途 <br /> <a name="more">
  </a>     <!--program-think-->
 <br /> 考虑到很多技术菜鸟可能不了解上述背景，俺先用最简短的文字描述一下。如果你自认为不是菜鸟，请略过本章节，直接去看“HTTPS 协议的需求”。 <br /> <br />     <h3 id="httpsssltls-"> ◇先澄清几个术语——HTTPS、SSL、TLS </h3>
 <br /> <b>
   1. “HTTP”是干嘛用滴？
  </b> <br /> 首先，HTTP 是一个网络协议，是专门用来帮你传输 Web 内容滴。关于这个协议，就算你不了解，至少也听说过吧？比如你访问俺的博客的主页，浏览器地址栏会出现如下的网址： <br />     <blockquote>
<b>
    http
   </b> ://program-think.blogspot.com/    </blockquote>
 俺加了粗体的部分就是指 HTTP 协议。大部分网站都是通过 HTTP 协议来传输 Web 页面、以及 Web 页面上包含的各种东东（图片、CSS 样式、JS 脚本）。 <br /> （注：写这篇的时候，Google 的 blogspot 博客平台【尚未】支持全站 HTTPS，所以在上述举例中，主页的网址以 <code class="language-plaintext highlighter-rouge">
   http://
  </code> 开头） <br /> <br /> <b>
   2. “SSL/TLS”是干嘛用滴？
  </b> <br /> SSL 是洋文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由 <a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF" rel="nofollow" target="_blank"> 网景公司 </a> 设计的。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如“CSS 样式表”和“JS 脚本”） <br /> 为啥要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。 <br /> 到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。 <br /> 很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。 <br /> <br /> <b>
   3. “HTTPS”是啥意思？
  </b> <br /> 解释完 HTTP 和 SSL/TLS，现在就可以来解释 HTTPS 啦。咱们通常所说的 HTTPS 协议，说白了就是“HTTP 协议”和“SSL/TLS 协议”的组合。你可以把 HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。 <br /> <br />     <h3 id="http--"> ◇再来说说 HTTP 协议的特点 </h3>
 <br /> 作为背景知识介绍，还需要再稍微谈一下 HTTP 协议本身的特点。HTTP 本身有很多特点，考虑到篇幅有限，俺只谈那些和 HTTPS 相关的特点。 <br /> <br /> <b>
   1. HTTP 的版本和历史
  </b> <br /> 如今咱们用的 HTTP 协议，版本号是 1.1（也就是 HTTP 1.1）。这个 1.1 版本是1995年底开始起草的（技术文档是 <a href="https://tools.ietf.org/html/rfc2068" rel="nofollow" target="_blank"> RFC2068 </a> ），并在1999年正式发布（技术文档是 <a href="https://tools.ietf.org/html/rfc2616" rel="nofollow" target="_blank"> RFC2616 </a> ）。 <br /> 在 1.1 之前，还有曾经出现过两个版本“0.9 和 1.0”，其中的 HTTP 0.9 【没有】被广泛使用，而 HTTP 1.0 被广泛使用过。 <br /> 另外，据说明年（2015） <a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84" rel="nofollow" target="_blank"> IETF </a> 就要发布 HTTP 2.0 的标准了。俺拭目以待。 <br /> <br /> <b>
   2. HTTP 和 TCP 之间的关系
  </b> <br /> 简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。 <br /> <b>
   在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。
  </b> 有很多常见的应用层协议是以 TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等。 <br /> TCP 被称为“面向连接”的传输层协议。关于它的具体细节，俺就不展开了（否则篇幅又失控了）。你只需知道：传输层主要有两个协议，分别是 TCP 和 UDP。TCP 比 UDP 更可靠。你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达（与之相反，UDP 不保证这点）。 <br /> <br /> <b>
   3. HTTP 协议如何使用 TCP 连接？
  </b> <br /> HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”） <br /> 假设有一个网页，里面包含好多图片，还包含好多【外部的】CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开） <br /> 相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。 <br /> <br /> 在 HTTP 1.0 版本，【默认】使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）； <br /> 到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，【默认】采用的是【Keep-Alive】的方式。 <br /> 【HTTP Keep-Alive】有时候也叫做“HTTP persistent connection”或“HTTP connection reuse”。关于它的更多介绍，可以参见维基百科词条（在“ <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" rel="nofollow" target="_blank"> 这里 </a> ”） <br /> <br />     <h3 id="section-1"> ◇谈谈“对称加密”和“非对称加密”的概念 </h3>
 <br /> <b>
   1. 啥是“加密”和“解密”？
  </b> <br /> 通俗而言，你可以把“加密”和“解密”理解为某种【互逆的】数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。 <br /> “加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东东——叫做“密钥”——来参与数学运算。 <br /> <br /> <b>
   2. 啥是“对称加密”？
  </b> <br /> 所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。 <br /> <br /> <b>
   3. 啥是“非对称加密”？
  </b> <br /> 所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用【不同的】密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。 <br /> 由于篇幅有限，对“非对称加密”这个话题，俺就不展开了。有空的话，再单独写一篇扫盲。 <br /> <br /> <b>
   4. 各自有啥优缺点？
  </b> <br /> 看完刚才的定义，很显然：（从功能角度而言）“非对称加密”能干的事情比“对称加密”要多。这是“非对称加密”的优点。但是“非对称加密”的实现，通常需要涉及到“复杂数学问题”。所以，“非对称加密”的性能通常要差很多（相对于“对称加密”而言）。 <br /> 这两者的优缺点，也影响到了 SSL 协议的设计。 <br /> <br />     <h3 id="ca--"> ◇CA 证书的原理及用途 </h3>
 <br /> 关于这方面，请看俺4年前写的《 <a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html"> 数字证书及 CA 的扫盲介绍 </a> 》。这里就不再重复唠叨了，免得篇幅太长。 <br /> <br /> <br />     <h2 id="https--"> ★HTTPS 协议的【需求】是啥？ </h2>
 <br /> 花了好多口水，终于把背景知识说完了。下面正式进入正题。先来说说当初设计 HTTPS 是为了满足哪些需求？ <br /> 很多介绍 HTTPS 的文章一上来就给你讲实现细节。个人觉得：这是【不好】的做法。早在2009年开博的时候，发过一篇《 <a href="https://program-think.blogspot.com/2009/02/study-technology-in-three-steps.html"> 学习技术的三部曲：WHAT、HOW、WHY </a> 》，其中谈到“WHY 型问题”的重要性。如果一上来就丢给你一大堆协议细节，你充其量只能知道 WHAT 和 HOW，无法理解 WHY。俺在前一个章节讲了“背景知识”，在这个章节讲了“需求”，这就有助于你理解：当初【 <b>
   为什么
  </b> 】要设计成这样？——这就是 WHY 型的问题。 <br /> <br />     <h3 id="section-2"> ◇兼容性 </h3>
 <br /> 因为是先有 HTTP 再有 HTTPS。所以，HTTPS 的设计者肯定要考虑到对原有 HTTP 的兼容性。 <br /> 这里所说的兼容性包括很多方面。比如已有的 Web 应用要尽可能无缝地迁移到 HTTPS；比如对浏览器厂商而言，改动要尽可能小；...... <br /> 基于“兼容性”方面的考虑，很容易得出如下几个结论： <br /> 1. HTTPS 还是要基于 TCP 来传输 <br /> （如果改为 UDP 作传输层，无论是 Web 服务端还是浏览器客户端，都要大改——动静太大，伤筋动骨） <br /> 2. 单独使用一个新的协议，把 HTTP 协议包裹起来 <br /> （所谓的“HTTP over SSL”，实际上是在原有的 HTTP 数据外面加了一层 SSL 的封装。HTTP 协议原有的 GET、POST 之类的机制，基本上原封不动） <br /> <br /> 打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。 <br /> <br />     <h3 id="section-3"> ◇可扩展性 </h3>
 <br /> 前面说了，HTTPS 相当于是“HTTP over SSL”。 <br /> 如果 SSL 这个协议在“可扩展性”方面的设计足够牛逼，那么它除了能跟 HTTP 搭配，还能够跟其它的应用层协议搭配。岂不美哉？ <br /> 现在看来，当初设计 SSL 的人确实比较牛。如今的 SSL/TLS 可以跟很多常用的应用层协议（比如：FTP、SMTP、POP、Telnet）搭配，来强化这些应用层协议的安全性。 <br /> <br /> 接着刚才打的比方：如果把 SSL/TLS 视作一根用来加固的金属管，它不仅可以用来加固输水的管道，还可以用来加固输煤气的管道。 <br /> <br />     <h3 id="section-4"> ◇保密性（防泄密） </h3>
 <br /> HTTPS 需要做到足够好的保密性。 <br /> 说到保密性，首先要能够对抗“嗅探”（圈内行话叫 Sniffer）。所谓的“嗅探”，通俗而言就是监视你的网络传输流量。如果你使用【明文】的 HTTP 上网，那么监视者通过嗅探，就知道你在访问哪些网站的哪些页面。 <br /> 嗅探是最低级的攻击手法。除了嗅探，HTTPS 还需要能对抗其它一些稍微高级的攻击手法——比如“重放攻击”（后面讲协议原理的时候，会再聊）。 <br /> <br />     <h3 id="section-5"> ◇完整性（防篡改） </h3>
 <br /> 除了“保密性”，还有一个同样重要的目标是“确保完整性”。关于“完整性”这个概念，在之前的博文《 <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html"> 扫盲文件完整性校验——关于散列值和数字签名 </a> 》中大致提过。健忘的同学再去温习一下。 <br /> 在发明 HTTPS 之前，由于 HTTP 是明文的，不但容易被嗅探，还容易被篡改。 <br /> 举个例子： <br /> 比如咱们天朝的网络运营商（ISP）都比较流氓，经常有网友抱怨说访问某网站（本来是没有广告的），竟然会跳出很多中国电信的广告。为啥会这样捏？因为你的网络流量需要经过 ISP 的线路才能到达公网。如果你使用的是明文的 HTTP，ISP 很容易就可以在你访问的页面中植入广告。 <br /> 所以，当初设计 HTTPS 的时候，还有一个需求是“确保 HTTP 协议的内容【不】被篡改”。 <br /> <br />     <h3 id="section-6"> ◇真实性（防假冒） </h3>
 <br /> 在谈到 HTTPS 的需求时，“真实性”经常被忽略。其实“真实性”的重要程度【不亚于】前面的“保密性”和“完整性”。 <br /> 举个例子： <br /> 你因为使用网银，需要访问该网银的 Web 站点。那么，你如何确保你访问的网站确实是你想访问的网站？（这话有点绕口令） <br /> 有些天真的同学会说：通过看网址里面的域名，来确保。为啥说这样的同学是“天真的”？因为 DNS 系统本身是不可靠的（尤其是在设计 SSL 的那个年代，连 DNSSEC 都还没发明）。由于 DNS 的不可靠（存在“域名欺骗”和“域名劫持”），你看到的网址里面的域名【未必】是真实滴！ <br /> （不了解“域名欺骗”和“域名劫持”的同学，可以参见俺之前写的《 <a href="https://program-think.blogspot.com/2014/01/dns.html"> 扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染” </a> 》） <br /> 所以，HTTPS 协议必须有某种机制来确保“真实性”的需求（至于如何确保，后面会细聊）。 <br /> <br />     <h3 id="section-7"> ◇性能 </h3>
 <br /> 再来说最后一个需求——性能。 <br /> 引入 HTTPS 之后，【不能】导致性能变得太差。否则的话，谁还愿意用？ <br /> 为了确保性能，SSL 的设计者至少要考虑如下几点： <br /> 1. 如何选择加密算法（“对称”or“非对称”）？ <br /> 2. 如何兼顾 HTTP 采用的【短连接】TCP 方式？ <br /> （再次提醒：SSL 是在1995年之前开始设计滴。那是 Web 的远古时代——HTTP 协议版本还只是 1.0；默认使用【短连接】的 TCP 方式；默认【不】启用 Keep-Alive） <br /> <br />     <h3 id="section-8"> ◇小结 </h3>
 <br /> 以上就是设计 SSL 协议时，必须兼顾的各种需求。后面聊协议的实现时，俺会拿 SSL 协议的特点跟前面的需求作对照。看看这些需求是如何被逐一满足滴。 <br /> <br /> <br />     <h2 id="https---1"> ★设计 HTTPS 协议的主要【难点】是啥？ </h2>
 <br /> 设计 HTTPS 这个协议，有好几个难点。俺个人认为：“密钥交换”是最大的难点（没有之一）。 <br /> 在传统的密码学场景中，假如张三要跟李四建立一个加密通讯的渠道，双方事先要约定好使用哪种加密算法？同时也要约定好使用的密钥是啥？在这个场景中，加密算法的【类型】让旁人知道，没太大关系。但是密钥【千万不能】让旁人知道。一旦旁人知道了密钥，自然就可以破解通讯的密文，得到明文。 <br /> 好，现在回到 HTTPS 的场景。 <br /> 当你访问某个公网的网站，你的浏览器和网站的服务器之间，如果要建立加密通讯，必然要商量好双方使用啥算法，啥密钥。——在网络通讯术语中，这个过程称之为“握手”（洋文叫“handshake”）。在握手阶段，因为加密方式还没有协商好，所以握手阶段的通讯必定是【明文】滴！既然是明文，自然有可能被第三方偷窥到。然后，还要考虑到双方之间隔着一个【互联网】，啥样的事情都可能发生（不光会有“数据偷窥”，还会有【数据篡改】）。 <br /> 因此，在握手的过程中，如何做到安全地交换密钥信息，而不让周围的第三方看到。这就是设计 HTTPS 最大的难点。 <br /> <br /> <br />     <h2 id="section-9"> ★结尾 </h2>
 <br /> 本文费这么多口水，来介绍 HTTPS 的“需求”和“难点”，为啥捏？因为只有当你了解这些，后面介绍 SSL/TLS 的实现原理时，你才能理解——当初为啥要把协议设计成这个样子。 <br /> <br /> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html#index"> 回到本系列的目录 </a>     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2014-11-19</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-19/%E5%90%84%E7%A7%8D%E8%BF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA-%E5%85%9A%E5%9B%BD%E5%96%89%E8%88%8C%E6%AD%A3%E9%80%90%E6%B8%90%E5%A4%B1%E5%8E%BB%E8%88%86%E8%AE%BA%E9%98%B5%E5%9C%B0/">
          各种迹象显示——党国喉舌正逐渐失去舆论阵地
        </a>
      </li>
    
    
      <li>
        <time>2014-11-15</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-15/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-2-%E5%8F%AF%E9%9D%A0%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%9A%84%E9%9A%BE%E7%82%B9-%E4%BB%A5%E5%8F%8A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/">
          扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性
        </a>
      </li>
    
    
      <li>
        <time>2014-11-08</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/">
          扫盲 HTTPS 和 SSL-TLS 协议[0]：引子
        </a>
      </li>
    
    
      <li>
        <time>2014-11-04</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-04/%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2%E5%8D%87%E7%BA%A7-%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0-%E5%85%A8%E7%AB%99%E6%90%9C%E7%B4%A2-%E6%AF%94-Google-%E6%9B%B4%E5%87%86%E7%A1%AE%E5%9C%B0%E6%90%9C%E7%B4%A2%E8%AF%84%E8%AE%BA/">
          博客界面升级（重新实现【全站搜索】，比 Google 更准确地搜索评论）
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/">
            前一篇：扫盲 HTTPS 和 SSL-TLS 协议[0]：引子
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2014-11-09/%E9%8C%A2%E9%8B%BC%E5%B0%88%E6%AC%84-%E4%BE%9D%E6%86%B2%E6%B2%BB%E5%9C%8B-%E6%B6%88%E5%A4%B1%E8%AC%8E%E5%BA%95%E8%A2%AB%E6%8F%AD%E9%96%8B%E4%B8%80%E8%A7%92/">
            後一篇：錢鋼專欄：「依憲治國」消失謎底被揭開一角
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2014-11-09/%E9%8C%A2%E9%8B%BC%E5%B0%88%E6%AC%84-%E4%BE%9D%E6%86%B2%E6%B2%BB%E5%9C%8B-%E6%B6%88%E5%A4%B1%E8%AC%8E%E5%BA%95%E8%A2%AB%E6%8F%AD%E9%96%8B%E4%B8%80%E8%A7%92/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2014-11-15/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-2-%E5%8F%AF%E9%9D%A0%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%9A%84%E9%9A%BE%E7%82%B9-%E4%BB%A5%E5%8F%8A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2014-11-09/%E9%8C%A2%E9%8B%BC%E5%B0%88%E6%AC%84-%E4%BE%9D%E6%86%B2%E6%B2%BB%E5%9C%8B-%E6%B6%88%E5%A4%B1%E8%AC%8E%E5%BA%95%E8%A2%AB%E6%8F%AD%E9%96%8B%E4%B8%80%E8%A7%92/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2014-11-15/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-2-%E5%8F%AF%E9%9D%A0%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%9A%84%E9%9A%BE%E7%82%B9-%E4%BB%A5%E5%8F%8A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
