<!DOCTYPE html>
<html>
  <head>
  <title>扫盲文件完整性校验——关于散列值和数字签名 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      扫盲文件完整性校验——关于散列值和数字签名  
  
    
      
    
  
  
近期有网友在博客中留言，希望俺介绍散列值校验文件的知识。所以俺干脆写一篇“文件完整性校验”的扫盲教程。由于本文是扫盲性质，尽量不涉及太技术化的内容。  
       
        ★啥是“完整性校验”？ 
  所谓的“完整性校验”，顾名思义，就是检查文件是否完整。那么，什么情况下会导致文件不完整捏？大概有如下几种情况。   
   1. 感染病毒
    比方说你的系统中了病毒，病毒感染了某个软件安装包或者某个可执行程序。那么该文件的完整性就被破坏了。   
   2. 植入木马/后门
    还有一种文件不完整的情况，是被别有用心的人植入木马或后门。比方说某些国内的软件下载站点，它们提供的 Windows 安装光盘镜像已经被安置了后门。   
   3. 传输故障
    这种情况主要发生在网络下载时。因为网络传输是有可能发生误码的（传输错误），另外还有可能下载到快结束的时候断线（没下载全）。这些情况都会导致你下载的文件不完整。  如今的上网环境相比当年的 Modem 拨号，已经有明显改善。所以这种情况应该不多见了。         ★散列算法（哈希算法）扫盲 
       ◇什么是“散列算法/哈希算法”？ 
  这里所说的“散列”是一种计算机算法，洋文叫做 Hash，有时候也根据音译称为哈希。  散列算法可以把【任意尺寸】的数据（原始数据）转变为一个【固定尺寸】的“小”数据（叫“散列值”或“摘要”）。        ◇摘要长度 
  对于某个具体的散列算法，得到的散列值长度总是固定的。散列值的长度又称“摘要长度”。  以下是常见散列算法的摘要长度       
    
     
      
       散列算法
      
      
       散列值比特数
      
      
       散列值字节数
      
     
     
      
       CRC32
      
      
       32
      
      
       4
      
     
     
      
       MD5
      
      
       128
      
      
       16
      
     
     
      
       SHA1
      
      
       160
      
      
       20
      
     
     
      
       SHA256
      
      
       256
      
      
       32
      
     
     
      
       SHA512
      
      
       512
      
      
       64
      
     
    
    
       ◇散列算法的特色 
  
   1. 不可逆性
    从刚才的描述看，散列似乎有点像压缩。其实捏，散列算法跟压缩算法是完全不同滴。压缩算法是可逆的（可以把压缩后的数据再还原），而【 
   散列算法是不可逆的
   】。  还有一些人把散列算法称为“加密算法”，这也是不对的。因为加密算法是可逆的（“加密”的【逆操作】就是“解密”），而散列算法是【不可逆】的。   
   2. 确定性
    通过某种散列算法，分别对两个原始数据计算散列值。如果算出来的散列值不同，那么可以 100% 肯定这两段数据是不同的——这就是“确定性”。  但反过来，如果这两段数据的散列值相同，则只能说，这两段数据【 
   非常可能
   】相同。所谓的“非常可能”，就是说，还达不到百分百。具体原因，请看下一节“散列函数的可靠性”。         ★关于散列算法的【可靠性】 
       ◇何为“散列碰撞”？ 
  刚才说了，存在非常小的可能性，导致两段不同的原始数据，计算出相同的散列值。这种情况称之为“散列碰撞”或“散列冲突”。        ◇碰撞的类型 
  散列碰撞的类型，大体上有两种：   
   1. 随机碰撞
    随机碰撞就像买彩票中大奖，完全是出于小概率的偶然因素——你碰巧遇见两个不同的数据（文件），具有相同的散列值。  理论上讲，任何散列算法都存在随机碰撞的可能性，只是可能性有大有小。   
   2. 人为碰撞
    人为碰撞就是说，有人（通常是恶意的攻击者）故意制造散列碰撞，以此来骗过“基于散列值的完整性校验”。        ◇如何避免碰撞 
  
   1. 对于随机碰撞
    要避免随机碰撞，很简单，只需要选择摘要长度足够长的散列算法。  拿前面举的3个例子。  CRC32 的摘要长度是“32bit”，也就说，最多可以表示“2的32次方”这么多种可能性（也就是几十亿，数量级相当于地球总人口）。表面上看貌似很大，其实还不够大。比如当前互联网上的页面总数就已经大大超过“几十亿”。如果对每个页面计算 CRC32 散列，会碰到很多重复（碰撞）。  而 MD5 的摘要长度是“128bit”，也就是【2的128次方】。这个数字足够大了。通俗地说，从宇宙诞生到宇宙毁灭，你都未必有机会碰见 MD5 的【随机碰撞】。而 SHA1 的摘要长度是“160bit”，那就更不用说了。   
   2. 对于人为碰撞
    想避免人为碰撞，要同时兼顾两个因素——散列算法的摘要长度、散列算法的优秀程度。“摘要长度”刚才已经解释了。光说一下“算法的优秀程度”。  如果某个散列算法有缺陷（不够优秀），那么攻击者就可以比较容易地构造出两个【不同的】原始数据，但却拥有【相同的】散列值。如此一来，就可以骗过基于散列算法的完整性检查。  典型的例子就是 MD5——该算法在过去10多年里曾经非常流行，但是前几年被发现存在严重缺陷。所以，MD5 虽然“随机碰撞”的概率非常非常低，但“人为碰撞”的概率可【不低】。如果你比较注重安全性，【不要】再使用 MD5 进行完整性校验。   再补充一下：  随着硬件计算能力的提升，即便是 SHA1 也开始变得【不】安全了（参见如下博文中的  密码学相关  章节）。今后 SHA1 会逐步被 SHA256 或 SHA512 替代。  《  近期安全动态和点评（2019年2季度）  》         ★散列值校验的方法——使用网站提供的软件散列值 
  如今，大伙儿的安全意识越来越高了。相应的，很多知名的软件，除了在官网上提供下载，还会相应提供下载软件的散列值。当你下载好某个软件之后，先在自己电脑里计算一下散列值，然后跟官方网站提供的散列值对比一下。如果散列值一样，通常就说明没问题。   
   举例：Firefox 浏览器的散列校验
    打开如下链接，就可以看到 Firefox 某个版本的 SHA1 列表（把网址中的 
   版本号
   三个字替换为具体的【三段式】版本号，比如 
   18.0.2
   ）。这个列表很长，包括各种语言，各个平台。为了方便起见，你可以先算好 SHA1 散列值，然后到里面搜索该散列值      https://ftp.mozilla.org/pub/mozilla.org/firefox/releases/版本号/SHA1SUMS    
  某些菜鸟读者可能会问：如何在自己电脑上计算某个软件的散列值？  这就需要看下一个章节。         ★散列值校验的方法——使用客户端工具计算散列值 
  前面说完了校验的流程，最后再说一下校验的工具。  考虑到大部分读者是 Windows 用户，俺介绍一下微软官方的 FCIV（洋文全称是“File Checksum Integrity Verifier”）。这是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。  因为是命令行工具，你需要先运行 CMD，出现 Windows 的命令行界面（黑窗口）之后，在其中使用该工具。下面是 FCIV 功能简介。        ◇计算单个文件 
  比如你有一个微软的系统安装光盘镜像，位于 
   C:\download\Windows.iso
   那么，用如下命令可以计算该文件的 SHA1 散列值      fciv -sha1 C:\download\Windows.iso    
       ◇批量计算某个目录 
  FCIV 支持批量计算某个目录下的文件散列值。比方说，可以用如下命令可以计算 
   C:\download
   目录下的每一个文件的 SHA1      fciv -sha1 C:\download\    
       ◇批量计算并存储，供前后对比 
  比如 
   C:\download
   目录下有很多文件。俺想知道过一段时间之后，这些文件是否被改过。那么，可以先用如下命令，把该目录中所有文件的 SHA1 散列都存储到某个 XML 格式的文件中（本例中，俺假设保存的文件是当前目录的 
   hash.xml
   ，你也可以保存到其它文件名）      fciv -sha1 C:\download\ -xml hash.xml    
  过了一段时间后，你可以用如下命令，就可以看出哪些文件被修改过。      fciv -sha1 C:\download\ -xml hash.xml -v    
        ★啥是“数字签名”？ 
  所谓的“数字签名”，通俗来说，就是采用某种技术手段来证明某个信息确实是由某个机构（或某个人）发布的。因为其用途有点类似于传统的手写签字，所以称之为“数字签名”。  数字签名的技术实现需要依赖于“非对称加密技术”和“数字证书体系”。关于“非对称加密技术”，考虑到篇幅，今天就不展开了；关于“数字证书”，3年前写过一篇扫盲（在“  这里  ”），有兴趣的同学可以瞧一瞧，这里就不再啰嗦了。         ★Windows 平台的“数字签名” 
  数字签名有很多种，大伙儿比较常见的是 Windows 平台下的数字签名。如今大型 IT 公司（比如“微软、Google、苹果”等）或者是知名开源组织发布的 Windows 软件，安装文件通常都内置数字签名。所以俺着重介绍 Windows 平台的数字签名该如何校验。        ◇利用资源管理器验证单个文件 
  大概从 Windows 2000开始，Windows 就支持在某个文件尾部附加数字签名，并且 Windows 的资源管理器内置了对数字签名的校验功能。  下面俺通过几个截图，简单介绍一下：如何在资源管理器中验证数字签名。   比如，俺手头有一个 Firefox 的安装文件（带有数字签名）。当俺查看该文件的属性，会看到如下的界面。眼神好的同学，会注意到到上面有个“ 
   数字签名
   ”的标签页。如果没有出现这个标签页，就说明该文件没有附带数字签名。        
  选择该标签页，出现如下界面。  顺便说一下，某些数字签名中没有包含“邮件地址”，那么这一项会显示“不可用”；同样的，某些数字签名没有包含“时间戳”，也会显示“不可用”。不要紧张，这里显示的“不可用”跟数字签名的有效性 
   没关系
   。        
  一般来说，签名列表中，有且仅有一个签名。选中它，点“ 
   详细信息
   ”按钮。跳出如下界面：  通常这个界面会显示一行字： 
   该数字签名正常
   （图中红圈标出）。如果有这行字，就说明该文件从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。        
  如果该文件被篡改过了（比如，感染了病毒、被注入木马），那么对话框会出现一个警告提示： 
   该数字签名无效
   （图中红圈标出），界面如下。一旦出现数字签名无效，那这个文件就不要再使用了。        
       ◇利用命令行工具批量验证 
  用上面的图形化界面进行验证，比较傻瓜化。但有一个缺点——如果你要验证的文件比较多，一个一个去点对话框，手会抽筋滴。所以，俺再介绍一下命令行的工具，适合进行批量验证。  这个命令行工具就是微软官网提供的【SigCheck】，由大名鼎鼎的 SysInternals 出品（SysInternals 已经被微软收购）。跟前面提到的 FCIV 类似，它也是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。   使用如下命令，可以批量检查某个目录下（包括多层嵌套子目录）的所有可执行程序，并且把“无签名”或者“签名无效”的文件列出来。      sigcheck -u -e -s 某个目录的路径名    
 先提醒一下：  检查数字签名的有效性本身就比较慢，如果目录下的文件很多，你要有足够的耐心等它运行完毕。   稍微补充一下，这个 SigCheck 命令还顺便提供了散列值（命令格式如下），该功能可替代 FCIV 的头两个功能，可惜无法替代 FCIV 的第三个功能。      sigcheck -h 某个【目录】的路径名
sigcheck -h 某个【文件】的路径名
    
        ★PGP/GPG 的数字签名 
  刚才聊了 Windows 平台滴。但是，切莫以为只有 Windows 平台才提供数字签名——其它的数字签名工具还有好几种。名气比较大的数字签名工具当属 PGP/GPG。这两个缩写就像绕口令，很容易搞混。PGP 是商业软件，而 GPG 是 GnuPG 的缩写，是 GNU 的开源项目。后者是前者的开源替代品，两者的功能基本兼容。  这俩玩意儿的功能很强悍，校验数字签名对它俩只是小菜一碟。考虑到大伙儿平时较少碰到 GPG 的签名，俺今天就偷懒一下，暂不介绍。以后如果有空，再专门写一篇帖子介绍 PGP/GPG 的各种功能和使用场景。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：  《  如何防止黑客入侵  》（系列）  《  数字证书及 CA 的扫盲介绍  》  《  文件加密的扫盲介绍  》  《  如何用“磁盘加密”对抗警方的【取证软件】和【刑讯逼供】，兼谈数据删除技巧  》  《  近期安全动态和点评（2019年2季度）  》     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2013/02/file-integrity-check.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      扫盲文件完整性校验——关于散列值和数字签名  
  
    
      
    
  
  
近期有网友在博客中留言，希望俺介绍散列值校验文件的知识。所以俺干脆写一篇“文件完整性校验”的扫盲教程。由于本文是扫盲性质，尽量不涉及太技术化的内容。  
       
        ★啥是“完整性校验”？ 
  所谓的“完整性校验”，顾名思义，就是检查文件是否完整。那么，什么情况下会导致文件不完整捏？大概有如下几种情况。   
   1. 感染病毒
    比方说你的系统中了病毒，病毒感染了某个软件安装包或者某个可执行程序。那么该文件的完整性就被破坏了。   
   2. 植入木马/后门
    还有一种文件不完整的情况，是被别有用心的人植入木马或后门。比方说某些国内的软件下载站点，它们提供的 Windows 安装光盘镜像已经被安置了后门。   
   3. 传输故障
    这种情况主要发生在网络下载时。因为网络传输是有可能发生误码的（传输错误），另外还有可能下载到快结束的时候断线（没下载全）。这些情况都会导致你下载的文件不完整。  如今的上网环境相比当年的 Modem 拨号，已经有明显改善。所以这种情况应该不多见了。         ★散列算法（哈希算法）扫盲 
       ◇什么是“散列算法/哈希算法”？ 
  这里所说的“散列”是一种计算机算法，洋文叫做 Hash，有时候也根据音译称为哈希。  散列算法可以把【任意尺寸】的数据（原始数据）转变为一个【固定尺寸】的“小”数据（叫“散列值”或“摘要”）。        ◇摘要长度 
  对于某个具体的散列算法，得到的散列值长度总是固定的。散列值的长度又称“摘要长度”。  以下是常见散列算法的摘要长度       
    
     
      
       散列算法
      
      
       散列值比特数
      
      
       散列值字节数
      
     
     
      
       CRC32
      
      
       32
      
      
       4
      
     
     
      
       MD5
      
      
       128
      
      
       16
      
     
     
      
       SHA1
      
      
       160
      
      
       20
      
     
     
      
       SHA256
      
      
       256
      
      
       32
      
     
     
      
       SHA512
      
      
       512
      
      
       64
      
     
    
    
       ◇散列算法的特色 
  
   1. 不可逆性
    从刚才的描述看，散列似乎有点像压缩。其实捏，散列算法跟压缩算法是完全不同滴。压缩算法是可逆的（可以把压缩后的数据再还原），而【 
   散列算法是不可逆的
   】。  还有一些人把散列算法称为“加密算法”，这也是不对的。因为加密算法是可逆的（“加密”的【逆操作】就是“解密”），而散列算法是【不可逆】的。   
   2. 确定性
    通过某种散列算法，分别对两个原始数据计算散列值。如果算出来的散列值不同，那么可以 100% 肯定这两段数据是不同的——这就是“确定性”。  但反过来，如果这两段数据的散列值相同，则只能说，这两段数据【 
   非常可能
   】相同。所谓的“非常可能”，就是说，还达不到百分百。具体原因，请看下一节“散列函数的可靠性”。         ★关于散列算法的【可靠性】 
       ◇何为“散列碰撞”？ 
  刚才说了，存在非常小的可能性，导致两段不同的原始数据，计算出相同的散列值。这种情况称之为“散列碰撞”或“散列冲突”。        ◇碰撞的类型 
  散列碰撞的类型，大体上有两种：   
   1. 随机碰撞
    随机碰撞就像买彩票中大奖，完全是出于小概率的偶然因素——你碰巧遇见两个不同的数据（文件），具有相同的散列值。  理论上讲，任何散列算法都存在随机碰撞的可能性，只是可能性有大有小。   
   2. 人为碰撞
    人为碰撞就是说，有人（通常是恶意的攻击者）故意制造散列碰撞，以此来骗过“基于散列值的完整性校验”。        ◇如何避免碰撞 
  
   1. 对于随机碰撞
    要避免随机碰撞，很简单，只需要选择摘要长度足够长的散列算法。  拿前面举的3个例子。  CRC32 的摘要长度是“32bit”，也就说，最多可以表示“2的32次方”这么多种可能性（也就是几十亿，数量级相当于地球总人口）。表面上看貌似很大，其实还不够大。比如当前互联网上的页面总数就已经大大超过“几十亿”。如果对每个页面计算 CRC32 散列，会碰到很多重复（碰撞）。  而 MD5 的摘要长度是“128bit”，也就是【2的128次方】。这个数字足够大了。通俗地说，从宇宙诞生到宇宙毁灭，你都未必有机会碰见 MD5 的【随机碰撞】。而 SHA1 的摘要长度是“160bit”，那就更不用说了。   
   2. 对于人为碰撞
    想避免人为碰撞，要同时兼顾两个因素——散列算法的摘要长度、散列算法的优秀程度。“摘要长度”刚才已经解释了。光说一下“算法的优秀程度”。  如果某个散列算法有缺陷（不够优秀），那么攻击者就可以比较容易地构造出两个【不同的】原始数据，但却拥有【相同的】散列值。如此一来，就可以骗过基于散列算法的完整性检查。  典型的例子就是 MD5——该算法在过去10多年里曾经非常流行，但是前几年被发现存在严重缺陷。所以，MD5 虽然“随机碰撞”的概率非常非常低，但“人为碰撞”的概率可【不低】。如果你比较注重安全性，【不要】再使用 MD5 进行完整性校验。   再补充一下：  随着硬件计算能力的提升，即便是 SHA1 也开始变得【不】安全了（参见如下博文中的  密码学相关  章节）。今后 SHA1 会逐步被 SHA256 或 SHA512 替代。  《  近期安全动态和点评（2019年2季度）  》         ★散列值校验的方法——使用网站提供的软件散列值 
  如今，大伙儿的安全意识越来越高了。相应的，很多知名的软件，除了在官网上提供下载，还会相应提供下载软件的散列值。当你下载好某个软件之后，先在自己电脑里计算一下散列值，然后跟官方网站提供的散列值对比一下。如果散列值一样，通常就说明没问题。   
   举例：Firefox 浏览器的散列校验
    打开如下链接，就可以看到 Firefox 某个版本的 SHA1 列表（把网址中的 
   版本号
   三个字替换为具体的【三段式】版本号，比如 
   18.0.2
   ）。这个列表很长，包括各种语言，各个平台。为了方便起见，你可以先算好 SHA1 散列值，然后到里面搜索该散列值      https://ftp.mozilla.org/pub/mozilla.org/firefox/releases/版本号/SHA1SUMS    
  某些菜鸟读者可能会问：如何在自己电脑上计算某个软件的散列值？  这就需要看下一个章节。         ★散列值校验的方法——使用客户端工具计算散列值 
  前面说完了校验的流程，最后再说一下校验的工具。  考虑到大部分读者是 Windows 用户，俺介绍一下微软官方的 FCIV（洋文全称是“File Checksum Integrity Verifier”）。这是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。  因为是命令行工具，你需要先运行 CMD，出现 Windows 的命令行界面（黑窗口）之后，在其中使用该工具。下面是 FCIV 功能简介。        ◇计算单个文件 
  比如你有一个微软的系统安装光盘镜像，位于 
   C:\download\Windows.iso
   那么，用如下命令可以计算该文件的 SHA1 散列值      fciv -sha1 C:\download\Windows.iso    
       ◇批量计算某个目录 
  FCIV 支持批量计算某个目录下的文件散列值。比方说，可以用如下命令可以计算 
   C:\download
   目录下的每一个文件的 SHA1      fciv -sha1 C:\download\    
       ◇批量计算并存储，供前后对比 
  比如 
   C:\download
   目录下有很多文件。俺想知道过一段时间之后，这些文件是否被改过。那么，可以先用如下命令，把该目录中所有文件的 SHA1 散列都存储到某个 XML 格式的文件中（本例中，俺假设保存的文件是当前目录的 
   hash.xml
   ，你也可以保存到其它文件名）      fciv -sha1 C:\download\ -xml hash.xml    
  过了一段时间后，你可以用如下命令，就可以看出哪些文件被修改过。      fciv -sha1 C:\download\ -xml hash.xml -v    
        ★啥是“数字签名”？ 
  所谓的“数字签名”，通俗来说，就是采用某种技术手段来证明某个信息确实是由某个机构（或某个人）发布的。因为其用途有点类似于传统的手写签字，所以称之为“数字签名”。  数字签名的技术实现需要依赖于“非对称加密技术”和“数字证书体系”。关于“非对称加密技术”，考虑到篇幅，今天就不展开了；关于“数字证书”，3年前写过一篇扫盲（在“  这里  ”），有兴趣的同学可以瞧一瞧，这里就不再啰嗦了。         ★Windows 平台的“数字签名” 
  数字签名有很多种，大伙儿比较常见的是 Windows 平台下的数字签名。如今大型 IT 公司（比如“微软、Google、苹果”等）或者是知名开源组织发布的 Windows 软件，安装文件通常都内置数字签名。所以俺着重介绍 Windows 平台的数字签名该如何校验。        ◇利用资源管理器验证单个文件 
  大概从 Windows 2000开始，Windows 就支持在某个文件尾部附加数字签名，并且 Windows 的资源管理器内置了对数字签名的校验功能。  下面俺通过几个截图，简单介绍一下：如何在资源管理器中验证数字签名。   比如，俺手头有一个 Firefox 的安装文件（带有数字签名）。当俺查看该文件的属性，会看到如下的界面。眼神好的同学，会注意到到上面有个“ 
   数字签名
   ”的标签页。如果没有出现这个标签页，就说明该文件没有附带数字签名。        
  选择该标签页，出现如下界面。  顺便说一下，某些数字签名中没有包含“邮件地址”，那么这一项会显示“不可用”；同样的，某些数字签名没有包含“时间戳”，也会显示“不可用”。不要紧张，这里显示的“不可用”跟数字签名的有效性 
   没关系
   。        
  一般来说，签名列表中，有且仅有一个签名。选中它，点“ 
   详细信息
   ”按钮。跳出如下界面：  通常这个界面会显示一行字： 
   该数字签名正常
   （图中红圈标出）。如果有这行字，就说明该文件从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。        
  如果该文件被篡改过了（比如，感染了病毒、被注入木马），那么对话框会出现一个警告提示： 
   该数字签名无效
   （图中红圈标出），界面如下。一旦出现数字签名无效，那这个文件就不要再使用了。        
       ◇利用命令行工具批量验证 
  用上面的图形化界面进行验证，比较傻瓜化。但有一个缺点——如果你要验证的文件比较多，一个一个去点对话框，手会抽筋滴。所以，俺再介绍一下命令行的工具，适合进行批量验证。  这个命令行工具就是微软官网提供的【SigCheck】，由大名鼎鼎的 SysInternals 出品（SysInternals 已经被微软收购）。跟前面提到的 FCIV 类似，它也是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。   使用如下命令，可以批量检查某个目录下（包括多层嵌套子目录）的所有可执行程序，并且把“无签名”或者“签名无效”的文件列出来。      sigcheck -u -e -s 某个目录的路径名    
 先提醒一下：  检查数字签名的有效性本身就比较慢，如果目录下的文件很多，你要有足够的耐心等它运行完毕。   稍微补充一下，这个 SigCheck 命令还顺便提供了散列值（命令格式如下），该功能可替代 FCIV 的头两个功能，可惜无法替代 FCIV 的第三个功能。      sigcheck -h 某个【目录】的路径名
sigcheck -h 某个【文件】的路径名
    
        ★PGP/GPG 的数字签名 
  刚才聊了 Windows 平台滴。但是，切莫以为只有 Windows 平台才提供数字签名——其它的数字签名工具还有好几种。名气比较大的数字签名工具当属 PGP/GPG。这两个缩写就像绕口令，很容易搞混。PGP 是商业软件，而 GPG 是 GnuPG 的缩写，是 GNU 的开源项目。后者是前者的开源替代品，两者的功能基本兼容。  这俩玩意儿的功能很强悍，校验数字签名对它俩只是小菜一碟。考虑到大伙儿平时较少碰到 GPG 的签名，俺今天就偷懒一下，暂不介绍。以后如果有空，再专门写一篇帖子介绍 PGP/GPG 的各种功能和使用场景。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：  《  如何防止黑客入侵  》（系列）  《  数字证书及 CA 的扫盲介绍  》  《  文件加密的扫盲介绍  》  《  如何用“磁盘加密”对抗警方的【取证软件】和【刑讯逼供】，兼谈数据删除技巧  》  《  近期安全动态和点评（2019年2季度）  》     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2013/02/file-integrity-check.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="扫盲文件完整性校验——关于散列值和数字签名" />
    <meta property="twitter:title" content="扫盲文件完整性校验——关于散列值和数字签名" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17489)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2013%2F02%2Ffile-integrity-check.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2013/02/file-integrity-check.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2013/02/file-integrity-check.html&text=扫盲文件完整性校验——关于散列值和数字签名&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2013/02/file-integrity-check.html&title=扫盲文件完整性校验——关于散列值和数字签名" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2013/02/file-integrity-check.html&title=扫盲文件完整性校验——关于散列值和数字签名" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=扫盲文件完整性校验——关于散列值和数字签名&body=

      扫盲文件完整性校验——关于散列值和数字签名  
  
    
      
    
  
  
近期有网友在博客中留言，希望俺介绍散列值校验文件的知识。所以俺干脆写一篇“文件完整性校验”的扫盲教程。由于本文是扫盲性质，尽量不涉及太技术化的内容。  
       
        ★啥是“完整性校验”？ 
  所谓的“完整性校验”，顾名思义，就是检查文件是否完整。那么，什么情况下会导致文件不完整捏？大概有如下几种情况。   
   1. 感染病毒
    比方说你的系统中了病毒，病毒感染了某个软件安装包或者某个可执行程序。那么该文件的完整性就被破坏了。   
   2. 植入木马/后门
    还有一种文件不完整的情况，是被别有用心的人植入木马或后门。比方说某些国内的软件下载站点，它们提供的 Windows 安装光盘镜像已经被安置了后门。   
   3. 传输故障
    这种情况主要发生在网络下载时。因为网络传输是有可能发生误码的（传输错误），另外还有可能下载到快结束的时候断线（没下载全）。这些情况都会导致你下载的文件不完整。  如今的上网环境相比当年的 Modem 拨号，已经有明显改善。所以这种情况应该不多见了。         ★散列算法（哈希算法）扫盲 
       ◇什么是“散列算法/哈希算法”？ 
  这里所说的“散列”是一种计算机算法，洋文叫做 Hash，有时候也根据音译称为哈希。  散列算法可以把【任意尺寸】的数据（原始数据）转变为一个【固定尺寸】的“小”数据（叫“散列值”或“摘要”）。        ◇摘要长度 
  对于某个具体的散列算法，得到的散列值长度总是固定的。散列值的长度又称“摘要长度”。  以下是常见散列算法的摘要长度       
    
     
      
       散列算法
      
      
       散列值比特数
      
      
       散列值字节数
      
     
     
      
       CRC32
      
      
       32
      
      
       4
      
     
     
      
       MD5
      
      
       128
      
      
       16
      
     
     
      
       SHA1
      
      
       160
      
      
       20
      
     
     
      
       SHA256
      
      
       256
      
      
       32
      
     
     
      
       SHA512
      
      
       512
      
      
       64
      
     
    
    
       ◇散列算法的特色 
  
   1. 不可逆性
    从刚才的描述看，散列似乎有点像压缩。其实捏，散列算法跟压缩算法是完全不同滴。压缩算法是可逆的（可以把压缩后的数据再还原），而【 
   散列算法是不可逆的
   】。  还有一些人把散列算法称为“加密算法”，这也是不对的。因为加密算法是可逆的（“加密”的【逆操作】就是“解密”），而散列算法是【不可逆】的。   
   2. 确定性
    通过某种散列算法，分别对两个原始数据计算散列值。如果算出来的散列值不同，那么可以 100% 肯定这两段数据是不同的——这就是“确定性”。  但反过来，如果这两段数据的散列值相同，则只能说，这两段数据【 
   非常可能
   】相同。所谓的“非常可能”，就是说，还达不到百分百。具体原因，请看下一节“散列函数的可靠性”。         ★关于散列算法的【可靠性】 
       ◇何为“散列碰撞”？ 
  刚才说了，存在非常小的可能性，导致两段不同的原始数据，计算出相同的散列值。这种情况称之为“散列碰撞”或“散列冲突”。        ◇碰撞的类型 
  散列碰撞的类型，大体上有两种：   
   1. 随机碰撞
    随机碰撞就像买彩票中大奖，完全是出于小概率的偶然因素——你碰巧遇见两个不同的数据（文件），具有相同的散列值。  理论上讲，任何散列算法都存在随机碰撞的可能性，只是可能性有大有小。   
   2. 人为碰撞
    人为碰撞就是说，有人（通常是恶意的攻击者）故意制造散列碰撞，以此来骗过“基于散列值的完整性校验”。        ◇如何避免碰撞 
  
   1. 对于随机碰撞
    要避免随机碰撞，很简单，只需要选择摘要长度足够长的散列算法。  拿前面举的3个例子。  CRC32 的摘要长度是“32bit”，也就说，最多可以表示“2的32次方”这么多种可能性（也就是几十亿，数量级相当于地球总人口）。表面上看貌似很大，其实还不够大。比如当前互联网上的页面总数就已经大大超过“几十亿”。如果对每个页面计算 CRC32 散列，会碰到很多重复（碰撞）。  而 MD5 的摘要长度是“128bit”，也就是【2的128次方】。这个数字足够大了。通俗地说，从宇宙诞生到宇宙毁灭，你都未必有机会碰见 MD5 的【随机碰撞】。而 SHA1 的摘要长度是“160bit”，那就更不用说了。   
   2. 对于人为碰撞
    想避免人为碰撞，要同时兼顾两个因素——散列算法的摘要长度、散列算法的优秀程度。“摘要长度”刚才已经解释了。光说一下“算法的优秀程度”。  如果某个散列算法有缺陷（不够优秀），那么攻击者就可以比较容易地构造出两个【不同的】原始数据，但却拥有【相同的】散列值。如此一来，就可以骗过基于散列算法的完整性检查。  典型的例子就是 MD5——该算法在过去10多年里曾经非常流行，但是前几年被发现存在严重缺陷。所以，MD5 虽然“随机碰撞”的概率非常非常低，但“人为碰撞”的概率可【不低】。如果你比较注重安全性，【不要】再使用 MD5 进行完整性校验。   再补充一下：  随着硬件计算能力的提升，即便是 SHA1 也开始变得【不】安全了（参见如下博文中的  密码学相关  章节）。今后 SHA1 会逐步被 SHA256 或 SHA512 替代。  《  近期安全动态和点评（2019年2季度）  》         ★散列值校验的方法——使用网站提供的软件散列值 
  如今，大伙儿的安全意识越来越高了。相应的，很多知名的软件，除了在官网上提供下载，还会相应提供下载软件的散列值。当你下载好某个软件之后，先在自己电脑里计算一下散列值，然后跟官方网站提供的散列值对比一下。如果散列值一样，通常就说明没问题。   
   举例：Firefox 浏览器的散列校验
    打开如下链接，就可以看到 Firefox 某个版本的 SHA1 列表（把网址中的 
   版本号
   三个字替换为具体的【三段式】版本号，比如 
   18.0.2
   ）。这个列表很长，包括各种语言，各个平台。为了方便起见，你可以先算好 SHA1 散列值，然后到里面搜索该散列值      https://ftp.mozilla.org/pub/mozilla.org/firefox/releases/版本号/SHA1SUMS    
  某些菜鸟读者可能会问：如何在自己电脑上计算某个软件的散列值？  这就需要看下一个章节。         ★散列值校验的方法——使用客户端工具计算散列值 
  前面说完了校验的流程，最后再说一下校验的工具。  考虑到大部分读者是 Windows 用户，俺介绍一下微软官方的 FCIV（洋文全称是“File Checksum Integrity Verifier”）。这是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。  因为是命令行工具，你需要先运行 CMD，出现 Windows 的命令行界面（黑窗口）之后，在其中使用该工具。下面是 FCIV 功能简介。        ◇计算单个文件 
  比如你有一个微软的系统安装光盘镜像，位于 
   C:\download\Windows.iso
   那么，用如下命令可以计算该文件的 SHA1 散列值      fciv -sha1 C:\download\Windows.iso    
       ◇批量计算某个目录 
  FCIV 支持批量计算某个目录下的文件散列值。比方说，可以用如下命令可以计算 
   C:\download
   目录下的每一个文件的 SHA1      fciv -sha1 C:\download\    
       ◇批量计算并存储，供前后对比 
  比如 
   C:\download
   目录下有很多文件。俺想知道过一段时间之后，这些文件是否被改过。那么，可以先用如下命令，把该目录中所有文件的 SHA1 散列都存储到某个 XML 格式的文件中（本例中，俺假设保存的文件是当前目录的 
   hash.xml
   ，你也可以保存到其它文件名）      fciv -sha1 C:\download\ -xml hash.xml    
  过了一段时间后，你可以用如下命令，就可以看出哪些文件被修改过。      fciv -sha1 C:\download\ -xml hash.xml -v    
        ★啥是“数字签名”？ 
  所谓的“数字签名”，通俗来说，就是采用某种技术手段来证明某个信息确实是由某个机构（或某个人）发布的。因为其用途有点类似于传统的手写签字，所以称之为“数字签名”。  数字签名的技术实现需要依赖于“非对称加密技术”和“数字证书体系”。关于“非对称加密技术”，考虑到篇幅，今天就不展开了；关于“数字证书”，3年前写过一篇扫盲（在“  这里  ”），有兴趣的同学可以瞧一瞧，这里就不再啰嗦了。         ★Windows 平台的“数字签名” 
  数字签名有很多种，大伙儿比较常见的是 Windows 平台下的数字签名。如今大型 IT 公司（比如“微软、Google、苹果”等）或者是知名开源组织发布的 Windows 软件，安装文件通常都内置数字签名。所以俺着重介绍 Windows 平台的数字签名该如何校验。        ◇利用资源管理器验证单个文件 
  大概从 Windows 2000开始，Windows 就支持在某个文件尾部附加数字签名，并且 Windows 的资源管理器内置了对数字签名的校验功能。  下面俺通过几个截图，简单介绍一下：如何在资源管理器中验证数字签名。   比如，俺手头有一个 Firefox 的安装文件（带有数字签名）。当俺查看该文件的属性，会看到如下的界面。眼神好的同学，会注意到到上面有个“ 
   数字签名
   ”的标签页。如果没有出现这个标签页，就说明该文件没有附带数字签名。        
  选择该标签页，出现如下界面。  顺便说一下，某些数字签名中没有包含“邮件地址”，那么这一项会显示“不可用”；同样的，某些数字签名没有包含“时间戳”，也会显示“不可用”。不要紧张，这里显示的“不可用”跟数字签名的有效性 
   没关系
   。        
  一般来说，签名列表中，有且仅有一个签名。选中它，点“ 
   详细信息
   ”按钮。跳出如下界面：  通常这个界面会显示一行字： 
   该数字签名正常
   （图中红圈标出）。如果有这行字，就说明该文件从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。        
  如果该文件被篡改过了（比如，感染了病毒、被注入木马），那么对话框会出现一个警告提示： 
   该数字签名无效
   （图中红圈标出），界面如下。一旦出现数字签名无效，那这个文件就不要再使用了。        
       ◇利用命令行工具批量验证 
  用上面的图形化界面进行验证，比较傻瓜化。但有一个缺点——如果你要验证的文件比较多，一个一个去点对话框，手会抽筋滴。所以，俺再介绍一下命令行的工具，适合进行批量验证。  这个命令行工具就是微软官网提供的【SigCheck】，由大名鼎鼎的 SysInternals 出品（SysInternals 已经被微软收购）。跟前面提到的 FCIV 类似，它也是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。   使用如下命令，可以批量检查某个目录下（包括多层嵌套子目录）的所有可执行程序，并且把“无签名”或者“签名无效”的文件列出来。      sigcheck -u -e -s 某个目录的路径名    
 先提醒一下：  检查数字签名的有效性本身就比较慢，如果目录下的文件很多，你要有足够的耐心等它运行完毕。   稍微补充一下，这个 SigCheck 命令还顺便提供了散列值（命令格式如下），该功能可替代 FCIV 的头两个功能，可惜无法替代 FCIV 的第三个功能。      sigcheck -h 某个【目录】的路径名
sigcheck -h 某个【文件】的路径名
    
        ★PGP/GPG 的数字签名 
  刚才聊了 Windows 平台滴。但是，切莫以为只有 Windows 平台才提供数字签名——其它的数字签名工具还有好几种。名气比较大的数字签名工具当属 PGP/GPG。这两个缩写就像绕口令，很容易搞混。PGP 是商业软件，而 GPG 是 GnuPG 的缩写，是 GNU 的开源项目。后者是前者的开源替代品，两者的功能基本兼容。  这俩玩意儿的功能很强悍，校验数字签名对它俩只是小菜一碟。考虑到大伙儿平时较少碰到 GPG 的签名，俺今天就偷懒一下，暂不介绍。以后如果有空，再专门写一篇帖子介绍 PGP/GPG 的各种功能和使用场景。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：  《  如何防止黑客入侵  》（系列）  《  数字证书及 CA 的扫盲介绍  》  《  文件加密的扫盲介绍  》  《  如何用“磁盘加密”对抗警方的【取证软件】和【刑讯逼供】，兼谈数据删除技巧  》  《  近期安全动态和点评（2019年2季度）  》     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2013/02/file-integrity-check.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2013/02/file-integrity-check.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2013/02/file-integrity-check.html&title=扫盲文件完整性校验——关于散列值和数字签名&caption=

      扫盲文件完整性校验——关于散列值和数字签名  
  
    
      
    
  
  
近期有网友在博客中留言，希望俺介绍散列值校验文件的知识。所以俺干脆写一篇“文件完整性校验”的扫盲教程。由于本文是扫盲性质，尽量不涉及太技术化的内容。  
       
        ★啥是“完整性校验”？ 
  所谓的“完整性校验”，顾名思义，就是检查文件是否完整。那么，什么情况下会导致文件不完整捏？大概有如下几种情况。   
   1. 感染病毒
    比方说你的系统中了病毒，病毒感染了某个软件安装包或者某个可执行程序。那么该文件的完整性就被破坏了。   
   2. 植入木马/后门
    还有一种文件不完整的情况，是被别有用心的人植入木马或后门。比方说某些国内的软件下载站点，它们提供的 Windows 安装光盘镜像已经被安置了后门。   
   3. 传输故障
    这种情况主要发生在网络下载时。因为网络传输是有可能发生误码的（传输错误），另外还有可能下载到快结束的时候断线（没下载全）。这些情况都会导致你下载的文件不完整。  如今的上网环境相比当年的 Modem 拨号，已经有明显改善。所以这种情况应该不多见了。         ★散列算法（哈希算法）扫盲 
       ◇什么是“散列算法/哈希算法”？ 
  这里所说的“散列”是一种计算机算法，洋文叫做 Hash，有时候也根据音译称为哈希。  散列算法可以把【任意尺寸】的数据（原始数据）转变为一个【固定尺寸】的“小”数据（叫“散列值”或“摘要”）。        ◇摘要长度 
  对于某个具体的散列算法，得到的散列值长度总是固定的。散列值的长度又称“摘要长度”。  以下是常见散列算法的摘要长度       
    
     
      
       散列算法
      
      
       散列值比特数
      
      
       散列值字节数
      
     
     
      
       CRC32
      
      
       32
      
      
       4
      
     
     
      
       MD5
      
      
       128
      
      
       16
      
     
     
      
       SHA1
      
      
       160
      
      
       20
      
     
     
      
       SHA256
      
      
       256
      
      
       32
      
     
     
      
       SHA512
      
      
       512
      
      
       64
      
     
    
    
       ◇散列算法的特色 
  
   1. 不可逆性
    从刚才的描述看，散列似乎有点像压缩。其实捏，散列算法跟压缩算法是完全不同滴。压缩算法是可逆的（可以把压缩后的数据再还原），而【 
   散列算法是不可逆的
   】。  还有一些人把散列算法称为“加密算法”，这也是不对的。因为加密算法是可逆的（“加密”的【逆操作】就是“解密”），而散列算法是【不可逆】的。   
   2. 确定性
    通过某种散列算法，分别对两个原始数据计算散列值。如果算出来的散列值不同，那么可以 100% 肯定这两段数据是不同的——这就是“确定性”。  但反过来，如果这两段数据的散列值相同，则只能说，这两段数据【 
   非常可能
   】相同。所谓的“非常可能”，就是说，还达不到百分百。具体原因，请看下一节“散列函数的可靠性”。         ★关于散列算法的【可靠性】 
       ◇何为“散列碰撞”？ 
  刚才说了，存在非常小的可能性，导致两段不同的原始数据，计算出相同的散列值。这种情况称之为“散列碰撞”或“散列冲突”。        ◇碰撞的类型 
  散列碰撞的类型，大体上有两种：   
   1. 随机碰撞
    随机碰撞就像买彩票中大奖，完全是出于小概率的偶然因素——你碰巧遇见两个不同的数据（文件），具有相同的散列值。  理论上讲，任何散列算法都存在随机碰撞的可能性，只是可能性有大有小。   
   2. 人为碰撞
    人为碰撞就是说，有人（通常是恶意的攻击者）故意制造散列碰撞，以此来骗过“基于散列值的完整性校验”。        ◇如何避免碰撞 
  
   1. 对于随机碰撞
    要避免随机碰撞，很简单，只需要选择摘要长度足够长的散列算法。  拿前面举的3个例子。  CRC32 的摘要长度是“32bit”，也就说，最多可以表示“2的32次方”这么多种可能性（也就是几十亿，数量级相当于地球总人口）。表面上看貌似很大，其实还不够大。比如当前互联网上的页面总数就已经大大超过“几十亿”。如果对每个页面计算 CRC32 散列，会碰到很多重复（碰撞）。  而 MD5 的摘要长度是“128bit”，也就是【2的128次方】。这个数字足够大了。通俗地说，从宇宙诞生到宇宙毁灭，你都未必有机会碰见 MD5 的【随机碰撞】。而 SHA1 的摘要长度是“160bit”，那就更不用说了。   
   2. 对于人为碰撞
    想避免人为碰撞，要同时兼顾两个因素——散列算法的摘要长度、散列算法的优秀程度。“摘要长度”刚才已经解释了。光说一下“算法的优秀程度”。  如果某个散列算法有缺陷（不够优秀），那么攻击者就可以比较容易地构造出两个【不同的】原始数据，但却拥有【相同的】散列值。如此一来，就可以骗过基于散列算法的完整性检查。  典型的例子就是 MD5——该算法在过去10多年里曾经非常流行，但是前几年被发现存在严重缺陷。所以，MD5 虽然“随机碰撞”的概率非常非常低，但“人为碰撞”的概率可【不低】。如果你比较注重安全性，【不要】再使用 MD5 进行完整性校验。   再补充一下：  随着硬件计算能力的提升，即便是 SHA1 也开始变得【不】安全了（参见如下博文中的  密码学相关  章节）。今后 SHA1 会逐步被 SHA256 或 SHA512 替代。  《  近期安全动态和点评（2019年2季度）  》         ★散列值校验的方法——使用网站提供的软件散列值 
  如今，大伙儿的安全意识越来越高了。相应的，很多知名的软件，除了在官网上提供下载，还会相应提供下载软件的散列值。当你下载好某个软件之后，先在自己电脑里计算一下散列值，然后跟官方网站提供的散列值对比一下。如果散列值一样，通常就说明没问题。   
   举例：Firefox 浏览器的散列校验
    打开如下链接，就可以看到 Firefox 某个版本的 SHA1 列表（把网址中的 
   版本号
   三个字替换为具体的【三段式】版本号，比如 
   18.0.2
   ）。这个列表很长，包括各种语言，各个平台。为了方便起见，你可以先算好 SHA1 散列值，然后到里面搜索该散列值      https://ftp.mozilla.org/pub/mozilla.org/firefox/releases/版本号/SHA1SUMS    
  某些菜鸟读者可能会问：如何在自己电脑上计算某个软件的散列值？  这就需要看下一个章节。         ★散列值校验的方法——使用客户端工具计算散列值 
  前面说完了校验的流程，最后再说一下校验的工具。  考虑到大部分读者是 Windows 用户，俺介绍一下微软官方的 FCIV（洋文全称是“File Checksum Integrity Verifier”）。这是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。  因为是命令行工具，你需要先运行 CMD，出现 Windows 的命令行界面（黑窗口）之后，在其中使用该工具。下面是 FCIV 功能简介。        ◇计算单个文件 
  比如你有一个微软的系统安装光盘镜像，位于 
   C:\download\Windows.iso
   那么，用如下命令可以计算该文件的 SHA1 散列值      fciv -sha1 C:\download\Windows.iso    
       ◇批量计算某个目录 
  FCIV 支持批量计算某个目录下的文件散列值。比方说，可以用如下命令可以计算 
   C:\download
   目录下的每一个文件的 SHA1      fciv -sha1 C:\download\    
       ◇批量计算并存储，供前后对比 
  比如 
   C:\download
   目录下有很多文件。俺想知道过一段时间之后，这些文件是否被改过。那么，可以先用如下命令，把该目录中所有文件的 SHA1 散列都存储到某个 XML 格式的文件中（本例中，俺假设保存的文件是当前目录的 
   hash.xml
   ，你也可以保存到其它文件名）      fciv -sha1 C:\download\ -xml hash.xml    
  过了一段时间后，你可以用如下命令，就可以看出哪些文件被修改过。      fciv -sha1 C:\download\ -xml hash.xml -v    
        ★啥是“数字签名”？ 
  所谓的“数字签名”，通俗来说，就是采用某种技术手段来证明某个信息确实是由某个机构（或某个人）发布的。因为其用途有点类似于传统的手写签字，所以称之为“数字签名”。  数字签名的技术实现需要依赖于“非对称加密技术”和“数字证书体系”。关于“非对称加密技术”，考虑到篇幅，今天就不展开了；关于“数字证书”，3年前写过一篇扫盲（在“  这里  ”），有兴趣的同学可以瞧一瞧，这里就不再啰嗦了。         ★Windows 平台的“数字签名” 
  数字签名有很多种，大伙儿比较常见的是 Windows 平台下的数字签名。如今大型 IT 公司（比如“微软、Google、苹果”等）或者是知名开源组织发布的 Windows 软件，安装文件通常都内置数字签名。所以俺着重介绍 Windows 平台的数字签名该如何校验。        ◇利用资源管理器验证单个文件 
  大概从 Windows 2000开始，Windows 就支持在某个文件尾部附加数字签名，并且 Windows 的资源管理器内置了对数字签名的校验功能。  下面俺通过几个截图，简单介绍一下：如何在资源管理器中验证数字签名。   比如，俺手头有一个 Firefox 的安装文件（带有数字签名）。当俺查看该文件的属性，会看到如下的界面。眼神好的同学，会注意到到上面有个“ 
   数字签名
   ”的标签页。如果没有出现这个标签页，就说明该文件没有附带数字签名。        
  选择该标签页，出现如下界面。  顺便说一下，某些数字签名中没有包含“邮件地址”，那么这一项会显示“不可用”；同样的，某些数字签名没有包含“时间戳”，也会显示“不可用”。不要紧张，这里显示的“不可用”跟数字签名的有效性 
   没关系
   。        
  一般来说，签名列表中，有且仅有一个签名。选中它，点“ 
   详细信息
   ”按钮。跳出如下界面：  通常这个界面会显示一行字： 
   该数字签名正常
   （图中红圈标出）。如果有这行字，就说明该文件从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。        
  如果该文件被篡改过了（比如，感染了病毒、被注入木马），那么对话框会出现一个警告提示： 
   该数字签名无效
   （图中红圈标出），界面如下。一旦出现数字签名无效，那这个文件就不要再使用了。        
       ◇利用命令行工具批量验证 
  用上面的图形化界面进行验证，比较傻瓜化。但有一个缺点——如果你要验证的文件比较多，一个一个去点对话框，手会抽筋滴。所以，俺再介绍一下命令行的工具，适合进行批量验证。  这个命令行工具就是微软官网提供的【SigCheck】，由大名鼎鼎的 SysInternals 出品（SysInternals 已经被微软收购）。跟前面提到的 FCIV 类似，它也是一个小巧、绿色、免费的命令行工具，下载页面在“  这里  ”。   使用如下命令，可以批量检查某个目录下（包括多层嵌套子目录）的所有可执行程序，并且把“无签名”或者“签名无效”的文件列出来。      sigcheck -u -e -s 某个目录的路径名    
 先提醒一下：  检查数字签名的有效性本身就比较慢，如果目录下的文件很多，你要有足够的耐心等它运行完毕。   稍微补充一下，这个 SigCheck 命令还顺便提供了散列值（命令格式如下），该功能可替代 FCIV 的头两个功能，可惜无法替代 FCIV 的第三个功能。      sigcheck -h 某个【目录】的路径名
sigcheck -h 某个【文件】的路径名
    
        ★PGP/GPG 的数字签名 
  刚才聊了 Windows 平台滴。但是，切莫以为只有 Windows 平台才提供数字签名——其它的数字签名工具还有好几种。名气比较大的数字签名工具当属 PGP/GPG。这两个缩写就像绕口令，很容易搞混。PGP 是商业软件，而 GPG 是 GnuPG 的缩写，是 GNU 的开源项目。后者是前者的开源替代品，两者的功能基本兼容。  这俩玩意儿的功能很强悍，校验数字签名对它俩只是小菜一碟。考虑到大伙儿平时较少碰到 GPG 的签名，俺今天就偷懒一下，暂不介绍。以后如果有空，再专门写一篇帖子介绍 PGP/GPG 的各种功能和使用场景。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：  《  如何防止黑客入侵  》（系列）  《  数字证书及 CA 的扫盲介绍  》  《  文件加密的扫盲介绍  》  《  如何用“磁盘加密”对抗警方的【取证软件】和【刑讯逼供】，兼谈数据删除技巧  》  《  近期安全动态和点评（2019年2季度）  》     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2013/02/file-integrity-check.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=扫盲文件完整性校验——关于散列值和数字签名&url=https://program-think.blogspot.com/2013/02/file-integrity-check.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>扫盲文件完整性校验——关于散列值和数字签名</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2013-02-12
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="864434823129709398">
 </a>   <h1 class="post-title entry-title" id="section"> <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html"> 扫盲文件完整性校验——关于散列值和数字签名 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
近期有网友在博客中留言，希望俺介绍散列值校验文件的知识。所以俺干脆写一篇“文件完整性校验”的扫盲教程。由于本文是扫盲性质，尽量不涉及太技术化的内容。 <br /> <a name="more">
  </a>     <!--program-think-->
 <br /> <br />     <h2 id="section-1"> ★啥是“完整性校验”？ </h2>
 <br /> 所谓的“完整性校验”，顾名思义，就是检查文件是否完整。那么，什么情况下会导致文件不完整捏？大概有如下几种情况。 <br /> <br /> <b>
   1. 感染病毒
  </b> <br /> 比方说你的系统中了病毒，病毒感染了某个软件安装包或者某个可执行程序。那么该文件的完整性就被破坏了。 <br /> <br /> <b>
   2. 植入木马/后门
  </b> <br /> 还有一种文件不完整的情况，是被别有用心的人植入木马或后门。比方说某些国内的软件下载站点，它们提供的 Windows 安装光盘镜像已经被安置了后门。 <br /> <br /> <b>
   3. 传输故障
  </b> <br /> 这种情况主要发生在网络下载时。因为网络传输是有可能发生误码的（传输错误），另外还有可能下载到快结束的时候断线（没下载全）。这些情况都会导致你下载的文件不完整。 <br /> 如今的上网环境相比当年的 Modem 拨号，已经有明显改善。所以这种情况应该不多见了。 <br /> <br /> <br />     <h2 id="section-2"> ★散列算法（哈希算法）扫盲 </h2>
 <br />     <h3 id="section-3"> ◇什么是“散列算法/哈希算法”？ </h3>
 <br /> 这里所说的“散列”是一种计算机算法，洋文叫做 Hash，有时候也根据音译称为哈希。 <br /> 散列算法可以把【任意尺寸】的数据（原始数据）转变为一个【固定尺寸】的“小”数据（叫“散列值”或“摘要”）。 <br /> <br />     <h3 id="section-4"> ◇摘要长度 </h3>
 <br /> 对于某个具体的散列算法，得到的散列值长度总是固定的。散列值的长度又称“摘要长度”。 <br /> 以下是常见散列算法的摘要长度 <br />     <center> <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
     <tr style="background:lightgrey;">
      <th>
       散列算法
      </th>
      <th>
       散列值比特数
      </th>
      <th>
       散列值字节数
      </th>
     </tr>
     <tr>
      <td>
       CRC32
      </td>
      <td>
       32
      </td>
      <td>
       4
      </td>
     </tr>
     <tr>
      <td>
       MD5
      </td>
      <td>
       128
      </td>
      <td>
       16
      </td>
     </tr>
     <tr>
      <td>
       SHA1
      </td>
      <td>
       160
      </td>
      <td>
       20
      </td>
     </tr>
     <tr>
      <td>
       SHA256
      </td>
      <td>
       256
      </td>
      <td>
       32
      </td>
     </tr>
     <tr>
      <td>
       SHA512
      </td>
      <td>
       512
      </td>
      <td>
       64
      </td>
     </tr>
    </tbody>
   </table> </center>
 <br />     <h3 id="section-5"> ◇散列算法的特色 </h3>
 <br /> <b>
   1. 不可逆性
  </b> <br /> 从刚才的描述看，散列似乎有点像压缩。其实捏，散列算法跟压缩算法是完全不同滴。压缩算法是可逆的（可以把压缩后的数据再还原），而【 <b>
   散列算法是不可逆的
  </b> 】。 <br /> 还有一些人把散列算法称为“加密算法”，这也是不对的。因为加密算法是可逆的（“加密”的【逆操作】就是“解密”），而散列算法是【不可逆】的。 <br /> <br /> <b>
   2. 确定性
  </b> <br /> 通过某种散列算法，分别对两个原始数据计算散列值。如果算出来的散列值不同，那么可以 100% 肯定这两段数据是不同的——这就是“确定性”。 <br /> 但反过来，如果这两段数据的散列值相同，则只能说，这两段数据【 <b>
   非常可能
  </b> 】相同。所谓的“非常可能”，就是说，还达不到百分百。具体原因，请看下一节“散列函数的可靠性”。 <br /> <br /> <br />     <h2 id="section-6"> ★关于散列算法的【可靠性】 </h2>
 <br />     <h2 id="section-7"> ◇何为“散列碰撞”？ </h2>
 <br /> 刚才说了，存在非常小的可能性，导致两段不同的原始数据，计算出相同的散列值。这种情况称之为“散列碰撞”或“散列冲突”。 <br /> <br />     <h3 id="section-8"> ◇碰撞的类型 </h3>
 <br /> 散列碰撞的类型，大体上有两种： <br /> <br /> <b>
   1. 随机碰撞
  </b> <br /> 随机碰撞就像买彩票中大奖，完全是出于小概率的偶然因素——你碰巧遇见两个不同的数据（文件），具有相同的散列值。 <br /> 理论上讲，任何散列算法都存在随机碰撞的可能性，只是可能性有大有小。 <br /> <br /> <b>
   2. 人为碰撞
  </b> <br /> 人为碰撞就是说，有人（通常是恶意的攻击者）故意制造散列碰撞，以此来骗过“基于散列值的完整性校验”。 <br /> <br />     <h3 id="section-9"> ◇如何避免碰撞 </h3>
 <br /> <b>
   1. 对于随机碰撞
  </b> <br /> 要避免随机碰撞，很简单，只需要选择摘要长度足够长的散列算法。 <br /> 拿前面举的3个例子。 <br /> CRC32 的摘要长度是“32bit”，也就说，最多可以表示“2的32次方”这么多种可能性（也就是几十亿，数量级相当于地球总人口）。表面上看貌似很大，其实还不够大。比如当前互联网上的页面总数就已经大大超过“几十亿”。如果对每个页面计算 CRC32 散列，会碰到很多重复（碰撞）。 <br /> 而 MD5 的摘要长度是“128bit”，也就是【2的128次方】。这个数字足够大了。通俗地说，从宇宙诞生到宇宙毁灭，你都未必有机会碰见 MD5 的【随机碰撞】。而 SHA1 的摘要长度是“160bit”，那就更不用说了。 <br /> <br /> <b>
   2. 对于人为碰撞
  </b> <br /> 想避免人为碰撞，要同时兼顾两个因素——散列算法的摘要长度、散列算法的优秀程度。“摘要长度”刚才已经解释了。光说一下“算法的优秀程度”。 <br /> 如果某个散列算法有缺陷（不够优秀），那么攻击者就可以比较容易地构造出两个【不同的】原始数据，但却拥有【相同的】散列值。如此一来，就可以骗过基于散列算法的完整性检查。 <br /> 典型的例子就是 MD5——该算法在过去10多年里曾经非常流行，但是前几年被发现存在严重缺陷。所以，MD5 虽然“随机碰撞”的概率非常非常低，但“人为碰撞”的概率可【不低】。如果你比较注重安全性，【不要】再使用 MD5 进行完整性校验。 <br /> <br /> 再补充一下： <br /> 随着硬件计算能力的提升，即便是 SHA1 也开始变得【不】安全了（参见如下博文中的 <q> 密码学相关 </q> 章节）。今后 SHA1 会逐步被 SHA256 或 SHA512 替代。 <br /> 《 <a href="https://program-think.blogspot.com/2019/07/Security-News.html"> 近期安全动态和点评（2019年2季度） </a> 》 <br /> <br /> <br />     <h2 id="section-10"> ★散列值校验的方法——使用网站提供的软件散列值 </h2>
 <br /> 如今，大伙儿的安全意识越来越高了。相应的，很多知名的软件，除了在官网上提供下载，还会相应提供下载软件的散列值。当你下载好某个软件之后，先在自己电脑里计算一下散列值，然后跟官方网站提供的散列值对比一下。如果散列值一样，通常就说明没问题。 <br /> <br /> <b>
   举例：Firefox 浏览器的散列校验
  </b> <br /> 打开如下链接，就可以看到 Firefox 某个版本的 SHA1 列表（把网址中的 <code class="language-plaintext highlighter-rouge">
   版本号
  </code> 三个字替换为具体的【三段式】版本号，比如 <code class="language-plaintext highlighter-rouge">
   18.0.2
  </code> ）。这个列表很长，包括各种语言，各个平台。为了方便起见，你可以先算好 SHA1 散列值，然后到里面搜索该散列值 <br />     <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://ftp.mozilla.org/pub/mozilla.org/firefox/releases/版本号/SHA1SUMS</code></pre></div>    </div>
 <br /> 某些菜鸟读者可能会问：如何在自己电脑上计算某个软件的散列值？ <br /> 这就需要看下一个章节。 <br /> <br /> <br />     <h2 id="section-11"> ★散列值校验的方法——使用客户端工具计算散列值 </h2>
 <br /> 前面说完了校验的流程，最后再说一下校验的工具。 <br /> 考虑到大部分读者是 Windows 用户，俺介绍一下微软官方的 FCIV（洋文全称是“File Checksum Integrity Verifier”）。这是一个小巧、绿色、免费的命令行工具，下载页面在“ <a href="https://support.microsoft.com/kb/841290/" rel="nofollow" target="_blank"> 这里 </a> ”。 <br /> 因为是命令行工具，你需要先运行 CMD，出现 Windows 的命令行界面（黑窗口）之后，在其中使用该工具。下面是 FCIV 功能简介。 <br /> <br />     <h3 id="section-12"> ◇计算单个文件 </h3>
 <br /> 比如你有一个微软的系统安装光盘镜像，位于 <code class="language-plaintext highlighter-rouge">
   C:\download\Windows.iso
  </code> 那么，用如下命令可以计算该文件的 SHA1 散列值 <br />     <div class="language-plaintext shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fciv -sha1 C:\download\Windows.iso</code></pre></div>    </div>
 <br />     <h3 id="section-13"> ◇批量计算某个目录 </h3>
 <br /> FCIV 支持批量计算某个目录下的文件散列值。比方说，可以用如下命令可以计算 <code class="language-plaintext highlighter-rouge">
   C:\download
  </code> 目录下的每一个文件的 SHA1 <br />     <div class="language-plaintext shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fciv -sha1 C:\download\</code></pre></div>    </div>
 <br />     <h3 id="section-14"> ◇批量计算并存储，供前后对比 </h3>
 <br /> 比如 <code class="language-plaintext highlighter-rouge">
   C:\download
  </code> 目录下有很多文件。俺想知道过一段时间之后，这些文件是否被改过。那么，可以先用如下命令，把该目录中所有文件的 SHA1 散列都存储到某个 XML 格式的文件中（本例中，俺假设保存的文件是当前目录的 <code class="language-plaintext highlighter-rouge">
   hash.xml
  </code> ，你也可以保存到其它文件名） <br />     <div class="language-plaintext shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fciv -sha1 C:\download\ -xml hash.xml</code></pre></div>    </div>
 <br /> 过了一段时间后，你可以用如下命令，就可以看出哪些文件被修改过。 <br />     <div class="language-plaintext shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fciv -sha1 C:\download\ -xml hash.xml -v</code></pre></div>    </div>
 <br /> <br />     <h2 id="section-15"> ★啥是“数字签名”？ </h2>
 <br /> 所谓的“数字签名”，通俗来说，就是采用某种技术手段来证明某个信息确实是由某个机构（或某个人）发布的。因为其用途有点类似于传统的手写签字，所以称之为“数字签名”。 <br /> 数字签名的技术实现需要依赖于“非对称加密技术”和“数字证书体系”。关于“非对称加密技术”，考虑到篇幅，今天就不展开了；关于“数字证书”，3年前写过一篇扫盲（在“ <a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html"> 这里 </a> ”），有兴趣的同学可以瞧一瞧，这里就不再啰嗦了。 <br /> <br /> <br />     <h2 id="windows--"> ★Windows 平台的“数字签名” </h2>
 <br /> 数字签名有很多种，大伙儿比较常见的是 Windows 平台下的数字签名。如今大型 IT 公司（比如“微软、Google、苹果”等）或者是知名开源组织发布的 Windows 软件，安装文件通常都内置数字签名。所以俺着重介绍 Windows 平台的数字签名该如何校验。 <br /> <br />     <h3 id="section-16"> ◇利用资源管理器验证单个文件 </h3>
 <br /> 大概从 Windows 2000开始，Windows 就支持在某个文件尾部附加数字签名，并且 Windows 的资源管理器内置了对数字签名的校验功能。 <br /> 下面俺通过几个截图，简单介绍一下：如何在资源管理器中验证数字签名。 <br /> <br /> 比如，俺手头有一个 Firefox 的安装文件（带有数字签名）。当俺查看该文件的属性，会看到如下的界面。眼神好的同学，会注意到到上面有个“ <b>
   数字签名
  </b> ”的标签页。如果没有出现这个标签页，就说明该文件没有附带数字签名。 <br />     <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/7yTWIB51d7IDQdJbkci9h7WasV2KtT3wv1GQHp7jpwDgqgoWuCrR0AN-RBKPpPIKhRJ3X-BW3NgpkSNDk_Pktcc2AKEAj37K6Ykddgrklvseb9D8yxRFX0psAtvXlqpK_4ByoSxd" /> </center>
 <br /> 选择该标签页，出现如下界面。 <br /> 顺便说一下，某些数字签名中没有包含“邮件地址”，那么这一项会显示“不可用”；同样的，某些数字签名没有包含“时间戳”，也会显示“不可用”。不要紧张，这里显示的“不可用”跟数字签名的有效性 <b>
   没关系
  </b> 。 <br />     <center> <img alt="不见图 请翻墙" src="https://lh5.googleusercontent.com/RnomEwHFwXYoQL2Ydk9N5WSlVG70Ie09qf2NvCCLcEKItHd-XDMwuB4_tYUFrabuTJxD5AXImyFX6zN_37KJgconsKwcWjgB1s7yS1QuIexm65HMempZvf5WQIXyYookguyc7Rvr" /> </center>
 <br /> 一般来说，签名列表中，有且仅有一个签名。选中它，点“ <b>
   详细信息
  </b> ”按钮。跳出如下界面： <br /> 通常这个界面会显示一行字： <b>
   该数字签名正常
  </b> （图中红圈标出）。如果有这行字，就说明该文件从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。 <br />     <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/wkK-RA1vVQf7t_T2KtsyknIF_3yvjTwWaQwAYoI2A1DUtf8bfcOoGLcusTueaZJ1g4L6kN3Ng-4vMdC2Ra9P_hmyhqEoY_7Fziu8O2Z6TFXBwtaPLkkAzfWrv4snlFgDiIjauTv0" /> </center>
 <br /> 如果该文件被篡改过了（比如，感染了病毒、被注入木马），那么对话框会出现一个警告提示： <b>
   该数字签名无效
  </b> （图中红圈标出），界面如下。一旦出现数字签名无效，那这个文件就不要再使用了。 <br />     <center> <img alt="不见图 请翻墙" src="https://lh3.googleusercontent.com/CB8Nl5udCNWWFTdgk3ZMkNEhmsZjvs9DngaNt0GEgzfpuPu9tCufvlLPJ13jpEyDSZtlTnPZ1DvmzxirIA4-TWIQUEG-KNOWJ5os6HriDq7kjjng85qBnbdz4VQmgZ4T-jloNFON" /> </center>
 <br />     <h3 id="section-17"> ◇利用命令行工具批量验证 </h3>
 <br /> 用上面的图形化界面进行验证，比较傻瓜化。但有一个缺点——如果你要验证的文件比较多，一个一个去点对话框，手会抽筋滴。所以，俺再介绍一下命令行的工具，适合进行批量验证。 <br /> 这个命令行工具就是微软官网提供的【SigCheck】，由大名鼎鼎的 SysInternals 出品（SysInternals 已经被微软收购）。跟前面提到的 FCIV 类似，它也是一个小巧、绿色、免费的命令行工具，下载页面在“ <a href="https://docs.microsoft.com/sysinternals/downloads/sigcheck" rel="nofollow" target="_blank"> 这里 </a> ”。 <br /> <br /> 使用如下命令，可以批量检查某个目录下（包括多层嵌套子目录）的所有可执行程序，并且把“无签名”或者“签名无效”的文件列出来。 <br />     <div class="language-plaintext shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck -u -e -s 某个目录的路径名</code></pre></div>    </div>
 先提醒一下： <br /> 检查数字签名的有效性本身就比较慢，如果目录下的文件很多，你要有足够的耐心等它运行完毕。 <br /> <br /> 稍微补充一下，这个 SigCheck 命令还顺便提供了散列值（命令格式如下），该功能可替代 FCIV 的头两个功能，可惜无法替代 FCIV 的第三个功能。 <br />     <div class="language-plaintext shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck -h 某个【目录】的路径名
sigcheck -h 某个【文件】的路径名
</code></pre></div>    </div>
 <br /> <br />     <h2 id="pgpgpg--"> ★PGP/GPG 的数字签名 </h2>
 <br /> 刚才聊了 Windows 平台滴。但是，切莫以为只有 Windows 平台才提供数字签名——其它的数字签名工具还有好几种。名气比较大的数字签名工具当属 PGP/GPG。这两个缩写就像绕口令，很容易搞混。PGP 是商业软件，而 GPG 是 GnuPG 的缩写，是 GNU 的开源项目。后者是前者的开源替代品，两者的功能基本兼容。 <br /> 这俩玩意儿的功能很强悍，校验数字签名对它俩只是小菜一碟。考虑到大伙儿平时较少碰到 GPG 的签名，俺今天就偷懒一下，暂不介绍。以后如果有空，再专门写一篇帖子介绍 PGP/GPG 的各种功能和使用场景。 <br /> <br /> <br /> <b>
   俺博客上，和本文相关的帖子（需翻墙）
  </b> ： <br /> 《 <a href="https://program-think.blogspot.com/2010/06/howto-prevent-hacker-attack-0.html"> 如何防止黑客入侵 </a> 》（系列） <br /> 《 <a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html"> 数字证书及 CA 的扫盲介绍 </a> 》 <br /> 《 <a href="https://program-think.blogspot.com/2011/05/file-encryption-overview.html"> 文件加密的扫盲介绍 </a> 》 <br /> 《 <a href="https://program-think.blogspot.com/2019/02/Use-Disk-Encryption-Anti-Computer-Forensics.html"> 如何用“磁盘加密”对抗警方的【取证软件】和【刑讯逼供】，兼谈数据删除技巧 </a> 》 <br /> 《 <a href="https://program-think.blogspot.com/2019/07/Security-News.html"> 近期安全动态和点评（2019年2季度） </a> 》     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2013/02/file-integrity-check.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2013-02-18</time>
        <a href="https://nodebe4.github.io/opinion/2013-02-18/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E5%85%B3%E4%BA%8E%E6%9C%9D%E9%B2%9C%E6%A0%B8%E8%AF%95%E9%AA%8C-%E7%BD%91%E6%96%877%E7%AF%87-%E8%AF%84%E8%AE%BA%E8%8B%A5%E5%B9%B2/">
          每周转载：关于朝鲜核试验（网文7篇，评论若干）
        </a>
      </li>
    
    
      <li>
        <time>2013-02-16</time>
        <a href="https://nodebe4.github.io/opinion/2013-02-16/%E4%B8%BA%E5%95%A5%E4%BF%BA%E6%8E%A8%E8%8D%90-Python-5-%E4%BD%9C%E4%B8%BA%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E7%9A%84-Python-%E9%A1%BA%E4%BE%BF%E5%88%86%E4%BA%AB%E4%BF%BA%E6%95%B4%E7%90%86%E7%9A%84-Python-%E5%BC%80%E6%BA%90%E5%BA%93/">
          为啥俺推荐 Python[5]：作为瑞士军刀的 Python——顺便分享俺整理的 Python 开源库
        </a>
      </li>
    
    
      <li>
        <time>2013-02-07</time>
        <a href="https://nodebe4.github.io/opinion/2013-02-07/%E5%88%86%E4%BA%AB%E5%8E%86%E5%8F%B2%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-9%E6%9C%AC-%E5%A2%9E%E5%8A%A0-%E5%8E%86%E5%8F%B2-%E5%A4%A7%E7%B1%BB/">
          分享历史类电子书（9本）——增加“历史”大类
        </a>
      </li>
    
    
      <li>
        <time>2013-02-04</time>
        <a href="https://nodebe4.github.io/opinion/2013-02-04/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E5%85%B3%E4%BA%8E-GitHub-%E5%92%8C-GFW-%E7%9A%84-PK-%E7%AC%AC1%E5%AD%A3/">
          每周转载：关于 GitHub 和 GFW 的 PK（第1季）
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2013-02-07/%E5%88%86%E4%BA%AB%E5%8E%86%E5%8F%B2%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-9%E6%9C%AC-%E5%A2%9E%E5%8A%A0-%E5%8E%86%E5%8F%B2-%E5%A4%A7%E7%B1%BB/">
            前一篇：分享历史类电子书（9本）——增加“历史”大类
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2013-02-16/%E4%B8%BA%E5%95%A5%E4%BF%BA%E6%8E%A8%E8%8D%90-Python-5-%E4%BD%9C%E4%B8%BA%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E7%9A%84-Python-%E9%A1%BA%E4%BE%BF%E5%88%86%E4%BA%AB%E4%BF%BA%E6%95%B4%E7%90%86%E7%9A%84-Python-%E5%BC%80%E6%BA%90%E5%BA%93/">
            後一篇：为啥俺推荐 Python[5]：作为瑞士军刀的 Python——顺便分享俺整理的 Python 开源库
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2013-02-07/%E5%88%86%E4%BA%AB%E5%8E%86%E5%8F%B2%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-9%E6%9C%AC-%E5%A2%9E%E5%8A%A0-%E5%8E%86%E5%8F%B2-%E5%A4%A7%E7%B1%BB/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2013-02-16/%E4%B8%BA%E5%95%A5%E4%BF%BA%E6%8E%A8%E8%8D%90-Python-5-%E4%BD%9C%E4%B8%BA%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E7%9A%84-Python-%E9%A1%BA%E4%BE%BF%E5%88%86%E4%BA%AB%E4%BF%BA%E6%95%B4%E7%90%86%E7%9A%84-Python-%E5%BC%80%E6%BA%90%E5%BA%93/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2013-02-16/%E4%B8%BA%E5%95%A5%E4%BF%BA%E6%8E%A8%E8%8D%90-Python-5-%E4%BD%9C%E4%B8%BA%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E7%9A%84-Python-%E9%A1%BA%E4%BE%BF%E5%88%86%E4%BA%AB%E4%BF%BA%E6%95%B4%E7%90%86%E7%9A%84-Python-%E5%BC%80%E6%BA%90%E5%BA%93/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2013-02-07/%E5%88%86%E4%BA%AB%E5%8E%86%E5%8F%B2%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-9%E6%9C%AC-%E5%A2%9E%E5%8A%A0-%E5%8E%86%E5%8F%B2-%E5%A4%A7%E7%B1%BB/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2013-02-07/%E5%88%86%E4%BA%AB%E5%8E%86%E5%8F%B2%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-9%E6%9C%AC-%E5%A2%9E%E5%8A%A0-%E5%8E%86%E5%8F%B2-%E5%A4%A7%E7%B1%BB/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2013-02-16/%E4%B8%BA%E5%95%A5%E4%BF%BA%E6%8E%A8%E8%8D%90-Python-5-%E4%BD%9C%E4%B8%BA%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E7%9A%84-Python-%E9%A1%BA%E4%BE%BF%E5%88%86%E4%BA%AB%E4%BF%BA%E6%95%B4%E7%90%86%E7%9A%84-Python-%E5%BC%80%E6%BA%90%E5%BA%93/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2013-02-16/%E4%B8%BA%E5%95%A5%E4%BF%BA%E6%8E%A8%E8%8D%90-Python-5-%E4%BD%9C%E4%B8%BA%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%E7%9A%84-Python-%E9%A1%BA%E4%BE%BF%E5%88%86%E4%BA%AB%E4%BF%BA%E6%95%B4%E7%90%86%E7%9A%84-Python-%E5%BC%80%E6%BA%90%E5%BA%93/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2013-02-07/%E5%88%86%E4%BA%AB%E5%8E%86%E5%8F%B2%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-9%E6%9C%AC-%E5%A2%9E%E5%8A%A0-%E5%8E%86%E5%8F%B2-%E5%A4%A7%E7%B1%BB/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
