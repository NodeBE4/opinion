<!DOCTYPE html>
<html>
  <head>
  <title>架构设计：生产者-消费者模式[2]：队列缓冲区 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      架构设计：生产者/消费者模式[2]：队列缓冲区  
  
    
      
    
  
  
经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。 
       
  关于并发的场景，在之前的帖子“  进程还线程？是一个问题！  ”中，已经专门论述了进程和线程各自的优缺点，两者皆不可偏废。所以，后面对各种缓冲区类型的介绍都会同时提及进程方式和线程方式。        ★线程方式 
  先来说一下并发线程中使用队列的例子，以及相关的优缺点。        ◇内存分配的性能 
  在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。  那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“  Java 性能优化[1]  ”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和  用户态/核心态切换  的开销。  那该怎么办捏？请听下文分解，关于“  生产者/消费者模式[3]：环形缓冲区  ”。        ◇同步和互斥的性能 
  另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在"操作系统"这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“  这里  ”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。  这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。  这又该咋办捏？请听下文的下文分解，关于“  生产者/消费者模式[4]：双缓冲区  ”。        ◇适用于队列的场合 
  刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“  这里  ”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的  ArrayBlockingQueue  ）。因此，开发人员可以捡现成，避免了重新发明轮子。  所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合  KISS 原则  。        ★进程方式 
  说完了线程的方式，再来介绍基于进程的并发。  跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。        ◇匿名管道 
  感觉管道是最像队列的IPC类型。生产者进程在管道的 
   写端
   放入数据；消费者进程在管道的 
   读端
   取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。  管道又分“  命名管道  ”和“  匿名管道  ”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。  其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“  这里  ”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。  这么干有如下几个好处：  1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。  2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。  3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。   当然，这种方式也有自身的缺点：  1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。  2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。  3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。  4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。   顺便补充几个注意事项，大伙儿留意一下：  1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。  2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有 
   立即
   读到）。具体的细节，大伙儿可以看"  这篇文章  "。        ◇SOCKET（TCP 方式） 
  基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。  SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：  1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。  2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。  3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。  4. SOCKET 支持双向通讯，有利于消费者反馈信息。   当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的  ACE  库、Python 的  Twisted  ）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。  虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者 
   进程
   和消费者 
   进程
   内部各自再引入基于 
   线程
   的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。        
  这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。  这样的好处是很明显的，具体如下：  1. 能够应对 
   暂时性
   的网络故障。并且在网络故障解除后，能够继续工作。  2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。  3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。  4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）  5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。  针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。   下一个帖子  ，咱们来介绍一下环形缓冲区的话题。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      架构设计：生产者/消费者模式[2]：队列缓冲区  
  
    
      
    
  
  
经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。 
       
  关于并发的场景，在之前的帖子“  进程还线程？是一个问题！  ”中，已经专门论述了进程和线程各自的优缺点，两者皆不可偏废。所以，后面对各种缓冲区类型的介绍都会同时提及进程方式和线程方式。        ★线程方式 
  先来说一下并发线程中使用队列的例子，以及相关的优缺点。        ◇内存分配的性能 
  在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。  那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“  Java 性能优化[1]  ”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和  用户态/核心态切换  的开销。  那该怎么办捏？请听下文分解，关于“  生产者/消费者模式[3]：环形缓冲区  ”。        ◇同步和互斥的性能 
  另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在"操作系统"这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“  这里  ”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。  这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。  这又该咋办捏？请听下文的下文分解，关于“  生产者/消费者模式[4]：双缓冲区  ”。        ◇适用于队列的场合 
  刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“  这里  ”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的  ArrayBlockingQueue  ）。因此，开发人员可以捡现成，避免了重新发明轮子。  所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合  KISS 原则  。        ★进程方式 
  说完了线程的方式，再来介绍基于进程的并发。  跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。        ◇匿名管道 
  感觉管道是最像队列的IPC类型。生产者进程在管道的 
   写端
   放入数据；消费者进程在管道的 
   读端
   取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。  管道又分“  命名管道  ”和“  匿名管道  ”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。  其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“  这里  ”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。  这么干有如下几个好处：  1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。  2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。  3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。   当然，这种方式也有自身的缺点：  1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。  2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。  3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。  4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。   顺便补充几个注意事项，大伙儿留意一下：  1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。  2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有 
   立即
   读到）。具体的细节，大伙儿可以看"  这篇文章  "。        ◇SOCKET（TCP 方式） 
  基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。  SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：  1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。  2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。  3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。  4. SOCKET 支持双向通讯，有利于消费者反馈信息。   当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的  ACE  库、Python 的  Twisted  ）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。  虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者 
   进程
   和消费者 
   进程
   内部各自再引入基于 
   线程
   的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。        
  这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。  这样的好处是很明显的，具体如下：  1. 能够应对 
   暂时性
   的网络故障。并且在网络故障解除后，能够继续工作。  2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。  3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。  4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）  5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。  针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。   下一个帖子  ，咱们来介绍一下环形缓冲区的话题。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="架构设计：生产者-消费者模式[2]：队列缓冲区" />
    <meta property="twitter:title" content="架构设计：生产者-消费者模式[2]：队列缓冲区" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17489)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2009%2F03%2Fproducer-consumer-pattern-2-queue.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html&text=架构设计：生产者-消费者模式[2]：队列缓冲区&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html&title=架构设计：生产者-消费者模式[2]：队列缓冲区" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html&title=架构设计：生产者-消费者模式[2]：队列缓冲区" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=架构设计：生产者-消费者模式[2]：队列缓冲区&body=

      架构设计：生产者/消费者模式[2]：队列缓冲区  
  
    
      
    
  
  
经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。 
       
  关于并发的场景，在之前的帖子“  进程还线程？是一个问题！  ”中，已经专门论述了进程和线程各自的优缺点，两者皆不可偏废。所以，后面对各种缓冲区类型的介绍都会同时提及进程方式和线程方式。        ★线程方式 
  先来说一下并发线程中使用队列的例子，以及相关的优缺点。        ◇内存分配的性能 
  在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。  那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“  Java 性能优化[1]  ”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和  用户态/核心态切换  的开销。  那该怎么办捏？请听下文分解，关于“  生产者/消费者模式[3]：环形缓冲区  ”。        ◇同步和互斥的性能 
  另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在"操作系统"这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“  这里  ”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。  这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。  这又该咋办捏？请听下文的下文分解，关于“  生产者/消费者模式[4]：双缓冲区  ”。        ◇适用于队列的场合 
  刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“  这里  ”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的  ArrayBlockingQueue  ）。因此，开发人员可以捡现成，避免了重新发明轮子。  所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合  KISS 原则  。        ★进程方式 
  说完了线程的方式，再来介绍基于进程的并发。  跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。        ◇匿名管道 
  感觉管道是最像队列的IPC类型。生产者进程在管道的 
   写端
   放入数据；消费者进程在管道的 
   读端
   取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。  管道又分“  命名管道  ”和“  匿名管道  ”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。  其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“  这里  ”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。  这么干有如下几个好处：  1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。  2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。  3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。   当然，这种方式也有自身的缺点：  1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。  2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。  3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。  4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。   顺便补充几个注意事项，大伙儿留意一下：  1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。  2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有 
   立即
   读到）。具体的细节，大伙儿可以看"  这篇文章  "。        ◇SOCKET（TCP 方式） 
  基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。  SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：  1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。  2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。  3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。  4. SOCKET 支持双向通讯，有利于消费者反馈信息。   当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的  ACE  库、Python 的  Twisted  ）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。  虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者 
   进程
   和消费者 
   进程
   内部各自再引入基于 
   线程
   的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。        
  这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。  这样的好处是很明显的，具体如下：  1. 能够应对 
   暂时性
   的网络故障。并且在网络故障解除后，能够继续工作。  2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。  3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。  4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）  5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。  针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。   下一个帖子  ，咱们来介绍一下环形缓冲区的话题。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html&title=架构设计：生产者-消费者模式[2]：队列缓冲区&caption=

      架构设计：生产者/消费者模式[2]：队列缓冲区  
  
    
      
    
  
  
经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。 
       
  关于并发的场景，在之前的帖子“  进程还线程？是一个问题！  ”中，已经专门论述了进程和线程各自的优缺点，两者皆不可偏废。所以，后面对各种缓冲区类型的介绍都会同时提及进程方式和线程方式。        ★线程方式 
  先来说一下并发线程中使用队列的例子，以及相关的优缺点。        ◇内存分配的性能 
  在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。  那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“  Java 性能优化[1]  ”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和  用户态/核心态切换  的开销。  那该怎么办捏？请听下文分解，关于“  生产者/消费者模式[3]：环形缓冲区  ”。        ◇同步和互斥的性能 
  另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在"操作系统"这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“  这里  ”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。  这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。  这又该咋办捏？请听下文的下文分解，关于“  生产者/消费者模式[4]：双缓冲区  ”。        ◇适用于队列的场合 
  刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“  这里  ”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的  ArrayBlockingQueue  ）。因此，开发人员可以捡现成，避免了重新发明轮子。  所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合  KISS 原则  。        ★进程方式 
  说完了线程的方式，再来介绍基于进程的并发。  跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。        ◇匿名管道 
  感觉管道是最像队列的IPC类型。生产者进程在管道的 
   写端
   放入数据；消费者进程在管道的 
   读端
   取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。  管道又分“  命名管道  ”和“  匿名管道  ”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。  其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“  这里  ”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。  这么干有如下几个好处：  1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。  2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。  3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。   当然，这种方式也有自身的缺点：  1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。  2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。  3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。  4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。   顺便补充几个注意事项，大伙儿留意一下：  1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。  2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有 
   立即
   读到）。具体的细节，大伙儿可以看"  这篇文章  "。        ◇SOCKET（TCP 方式） 
  基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。  SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：  1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。  2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。  3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。  4. SOCKET 支持双向通讯，有利于消费者反馈信息。   当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的  ACE  库、Python 的  Twisted  ）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。  虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者 
   进程
   和消费者 
   进程
   内部各自再引入基于 
   线程
   的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。        
  这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。  这样的好处是很明显的，具体如下：  1. 能够应对 
   暂时性
   的网络故障。并且在网络故障解除后，能够继续工作。  2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。  3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。  4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）  5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。  针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。   下一个帖子  ，咱们来介绍一下环形缓冲区的话题。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=架构设计：生产者-消费者模式[2]：队列缓冲区&url=https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>架构设计：生产者-消费者模式[2]：队列缓冲区</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2009-03-29
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="2977893841103338691">
 </a>   <h1 class="post-title entry-title" id="section"> <a href="https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html"> 架构设计：生产者/消费者模式[2]：队列缓冲区 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。 <a name="more">
  </a>     <!--program-think-->
 <br /> 关于并发的场景，在之前的帖子“ <a href="https://program-think.blogspot.com/2009/02/multi-process-vs-multi-thread.html"> 进程还线程？是一个问题！ </a> ”中，已经专门论述了进程和线程各自的优缺点，两者皆不可偏废。所以，后面对各种缓冲区类型的介绍都会同时提及进程方式和线程方式。 <br /> <br />     <h2 id="section-1"> ★线程方式 </h2>
 <br /> 先来说一下并发线程中使用队列的例子，以及相关的优缺点。 <br /> <br />     <h3 id="section-2"> ◇内存分配的性能 </h3>
 <br /> 在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。 <br /> 那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“ <a href="https://program-think.blogspot.com/2009/03/java-performance-tuning-1-two-types.html"> Java 性能优化[1] </a> ”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和 <a href="https://en.wikipedia.org/wiki/Context_switch#User_and_kernel_mode_switching" rel="nofollow" target="_blank"> 用户态/核心态切换 </a> 的开销。 <br /> 那该怎么办捏？请听下文分解，关于“ <a href="https://program-think.blogspot.com/2009/04/producer-consumer-pattern-3-circle.html"> 生产者/消费者模式[3]：环形缓冲区 </a> ”。 <br /> <br />     <h3 id="section-3"> ◇同步和互斥的性能 </h3>
 <br /> 另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在"操作系统"这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“ <a href="https://en.wikipedia.org/wiki/Producer-consumer_problem" rel="nofollow" target="_blank"> 这里 </a> ”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。 <br /> 这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。 <br /> 这又该咋办捏？请听下文的下文分解，关于“ <a href="https://program-think.blogspot.com/2009/04/producer-consumer-pattern-4-double.html"> 生产者/消费者模式[4]：双缓冲区 </a> ”。 <br /> <br />     <h3 id="section-4"> ◇适用于队列的场合 </h3>
 <br /> 刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“ <a href="https://en.wikipedia.org/wiki/Deque" rel="nofollow" target="_blank"> 这里 </a> ”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ArrayBlockingQueue.html" rel="nofollow" target="_blank"> ArrayBlockingQueue </a> ）。因此，开发人员可以捡现成，避免了重新发明轮子。 <br /> 所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合 <a href="https://en.wikipedia.org/wiki/KISS_principle" rel="nofollow" target="_blank"> KISS 原则 </a> 。 <br /> <br />     <h2 id="section-5"> ★进程方式 </h2>
 <br /> 说完了线程的方式，再来介绍基于进程的并发。 <br /> 跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。 <br /> <br />     <h3 id="section-6"> ◇匿名管道 </h3>
 <br /> 感觉管道是最像队列的IPC类型。生产者进程在管道的 <b>
   写端
  </b> 放入数据；消费者进程在管道的 <b>
   读端
  </b> 取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。 <br /> 管道又分“ <a href="https://en.wikipedia.org/wiki/Named_pipe" rel="nofollow" target="_blank"> 命名管道 </a> ”和“ <a href="https://en.wikipedia.org/wiki/Anonymous_pipe" rel="nofollow" target="_blank"> 匿名管道 </a> ”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。 <br /> 其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“ <a href="https://en.wikipedia.org/wiki/Pipeline_%28Unix%29" rel="nofollow" target="_blank"> 这里 </a> ”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。 <br /> 这么干有如下几个好处： <br /> 1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。 <br /> 2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。 <br /> 3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。 <br /> <br /> 当然，这种方式也有自身的缺点： <br /> 1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。 <br /> 2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。 <br /> 3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。 <br /> 4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。 <br /> <br /> 顺便补充几个注意事项，大伙儿留意一下： <br /> 1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。 <br /> 2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有 <b>
   立即
  </b> 读到）。具体的细节，大伙儿可以看" <a href="http://www.pixelbeat.org/programming/stdio_buffering/" rel="nofollow" target="_blank"> 这篇文章 </a> "。 <br /> <br />     <h3 id="sockettcp--"> ◇SOCKET（TCP 方式） </h3>
 <br /> 基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。 <br /> SOCKET 相比 shell 管道符的方式，有啥优点捏？请看： <br /> 1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。 <br /> 2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。 <br /> 3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。 <br /> 4. SOCKET 支持双向通讯，有利于消费者反馈信息。 <br /> <br /> 当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的 <a href="http://www.cs.wustl.edu/%7Eschmidt/ACE.html" rel="nofollow" target="_blank"> ACE </a> 库、Python 的 <a href="http://twistedmatrix.com/" rel="nofollow" target="_blank"> Twisted </a> ）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。 <br /> 虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者 <b>
   进程
  </b> 和消费者 <b>
   进程
  </b> 内部各自再引入基于 <b>
   线程
  </b> 的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。 <br />     <center> <img alt="不见图 请翻墙" src="https://lh6.googleusercontent.com/Q6n7axlrP3zHVoLedfVtnr8Bg-v6ySkIFFkgd5nzBJOqBISM9KKMV1koWsH9VoZYDT_WHLlSuhoHf3QP0aYR3HSLzU-wug-gKx1r5Zoe_aybHY33C1P8-NCMtrbL4QcUw_1PXawQ" /> </center>
 <br /> 这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。 <br /> 这样的好处是很明显的，具体如下： <br /> 1. 能够应对 <b>
   暂时性
  </b> 的网络故障。并且在网络故障解除后，能够继续工作。 <br /> 2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。 <br /> 3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。 <br /> 4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求） <br /> 5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。 <br /> 针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。 <br /> <a href="https://program-think.blogspot.com/2009/04/producer-consumer-pattern-3-circle.html"> 下一个帖子 </a> ，咱们来介绍一下环形缓冲区的话题。 <br /> <br /> <a href="https://program-think.blogspot.com/2009/03/producer-consumer-pattern-0-overview.html#index"> 回到本系列的目录 </a>     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2009/03/producer-consumer-pattern-2-queue.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2009-04-03</time>
        <a href="https://nodebe4.github.io/opinion/2009-04-03/C++-%E7%9A%84%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E5%92%8C%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91-6-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
          C++ 的可移植性和跨平台开发[6]：多线程
        </a>
      </li>
    
    
      <li>
        <time>2009-03-31</time>
        <a href="https://nodebe4.github.io/opinion/2009-03-31/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-3-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">
          架构设计：生产者-消费者模式[3]：环形缓冲区
        </a>
      </li>
    
    
      <li>
        <time>2009-03-26</time>
        <a href="https://nodebe4.github.io/opinion/2009-03-26/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-1-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/">
          架构设计：生产者-消费者模式[1]：如何确定数据单元？
        </a>
      </li>
    
    
      <li>
        <time>2009-03-24</time>
        <a href="https://nodebe4.github.io/opinion/2009-03-24/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-0-%E6%A6%82%E8%BF%B0/">
          架构设计：生产者-消费者模式[0]：概述
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2009-03-29/%E8%8B%8F%E5%8A%9B%E4%B8%BB%E7%BC%96-%E6%B3%95%E5%BE%8B%E5%92%8C%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6-%E7%AC%AC%E5%9B%9B%E5%8D%B7/">
            前一篇：苏力主编：《法律和社会科学》第四卷
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2009-03-31/%E4%BA%BA%E6%B0%91%E5%85%AC%E7%A4%BE-%E4%B8%AD%E5%9B%BD%E5%86%9C%E6%9D%91%E7%9A%84%E5%9C%B0%E7%8B%B1%E4%B9%8B%E6%97%85/">
            後一篇：“人民公社”：中国农村的地狱之旅
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2009-03-29/%E8%8B%8F%E5%8A%9B%E4%B8%BB%E7%BC%96-%E6%B3%95%E5%BE%8B%E5%92%8C%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6-%E7%AC%AC%E5%9B%9B%E5%8D%B7/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2009-03-31/%E4%BA%BA%E6%B0%91%E5%85%AC%E7%A4%BE-%E4%B8%AD%E5%9B%BD%E5%86%9C%E6%9D%91%E7%9A%84%E5%9C%B0%E7%8B%B1%E4%B9%8B%E6%97%85/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2009-03-31/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-3-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2009-03-26/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-1-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2009-03-29/%E8%8B%8F%E5%8A%9B%E4%B8%BB%E7%BC%96-%E6%B3%95%E5%BE%8B%E5%92%8C%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6-%E7%AC%AC%E5%9B%9B%E5%8D%B7/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2009-03-31/%E4%BA%BA%E6%B0%91%E5%85%AC%E7%A4%BE-%E4%B8%AD%E5%9B%BD%E5%86%9C%E6%9D%91%E7%9A%84%E5%9C%B0%E7%8B%B1%E4%B9%8B%E6%97%85/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2009-03-31/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-3-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2009-03-26/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-1-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
