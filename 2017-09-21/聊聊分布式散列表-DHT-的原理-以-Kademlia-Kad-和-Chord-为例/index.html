<!DOCTYPE html>
<html>
  <head>
  <title>聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例  
  
    
      
    
  
  
     ★引子——为啥要聊这个话题？ 
  这是一篇比较深入地谈技术的博文（而且还牵涉到一点算法）。俺很久没有写这种类型的博文了。  今天发这篇，主要是因为如下几点：  1  在“对抗 GFW、对抗政府审查”的过程中，【彻底无中心】的分布式系统是非常有用滴！  （关于这点，请参见前几年的博文：《  “对抗专制、捍卫自由”的 N 种技术力量  》）  2  DHT 是这类分布式系统的【关键基础设施】，俺希望追求自由的网民能多了解这方面的知识  3  俺也希望有更多程序员能参与这方面的【开源社区】。  在对抗政府审查的时候，商业公司是靠不住滴；只能指望开源社区。  4  虽然 GFW 已经在封杀 BT sync／Resilio Sync；但是，启用了 DHT 功能的 BTsync（必须是老版本），在墙内依然是【免翻墙】可用，让俺很受鼓舞 :)  （感兴趣的同学可以参见上个月的博文：《  聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？  》）  
       
        ★预备知识 
  （如果你自认为是一个熟练的程序员，请直接略过“预备知识”这个章节，看下一章节）        ◇什么是“散列/哈希（hash）”？ 
  （注：在本文中，凡是提及“散列”或“哈希”或“hash”，均表示相同含义）  关于 hash 的概念，俺曾经写过一篇相关的扫盲教程《  扫盲文件完整性校验——关于散列值和数字签名  》，不了解此概念的同学，可以先看看。  老实说，如果你还没有搞明白 hash 的概念，就不要浪费时间看本文的后续部分了。        ◇什么是“散列表/哈希表（hash table）”？ 
  “散列表/哈希表”是用来存储“键值对”的一种容器。“键值对”洋文称之为“key/value pairs”，简称“K/V”。有了“散列表”，你可以很方便快速地通过 key 来获得 value。  举个例子：  手机通讯簿可以通俗理解成一个“散列表”。里面的每一条记录都包含“姓名”和“电话号码”。“姓名”相当于“键值对”中的 key，电话号码相当于 value。你可以通过姓名方便地查找出电话号码。        ◇如何实现散列表？ 
  （考虑到本文的完整性，【简单介绍】一下散列表的实现）  在散列表这种数据结构中，会包含 N 个 bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是【固定不变】的。于是可以对每个桶进行编号，从 0 到 N-1。  “桶”是用来存储“键值对”的，你可以把它通俗理解成一个动态数组，里面可以存放【多个】“键值对”。  下面这张图是从维基百科上剽窃来的。它展示了散列表的【查找】原理。当使用某个 key 进行查找，会先用某个散列函数计算这个 key 的散列值。得到散列值通常是一个整数，然后用散列值对 N（桶数）进行“取模”运算（除法求余数），就可以算出对应的桶编号。  （注：取模运算是最常用的做法，但不是唯一的做法）          （使用散列表存储电话簿的示意图，剽窃自维基百科） 
       ◇什么是“散列表”的【碰撞/冲突】（Collision）？ 
  在俺那篇  扫盲教程  中，已经介绍了“散列碰撞”（也称为“散列冲突”）的概念。  当两个不同的 key 进行哈希计算却得到【相同的散列值】，就是所谓的【散列函数碰撞】。一旦出现这种情况，这两个 key 对应的两个键值对就会被存储在【同一个】桶（bucket）里面。  另一种情况是：虽然计算出来的散列值【不同】，但经过“取模运算”之后却得到【相同】的桶编号。这时候也会出现：两个键值对存储在一个桶里面。          （出现“散列碰撞”的示意图，剽窃自维基百科） 
  如果某个哈希表在存储数据时【完全没有碰撞】，那么每个桶里面都只有 0个 或 1个 键值对。查找起来就非常快。  反之，如果某个哈希表在存储数据时出现【严重碰撞】，就会导致某些桶里面存储了一大坨的键值对。将来查找 key 的时候，如果定位到的是这种“大桶”，就需要在这个桶里面逐一比对 key 是否相同——查找效率就会变得很差。        ◇“散列表”有哪些优点？ 
  主要优点是：（当数据量很大时）散列表可以提供快速且稳定的查找速度。  当然，这里有个前提就是：散列函数要【足够好】——  1、计算出的散列值要足够离散（从而使得不同的键值对可以比较【均匀】地分配到各个桶里面）  2、要尽可能降低碰撞（碰撞会降低性能）  另一个前提是：桶的数量也有一定的讲究——  1、桶数要足够大。否则的话，【必定会】导致某些桶里面的键值对太多（这点很明显，没想明白的同学，可参见“抽屉原理”）  2、（如果用常见的“取模”映射到桶）桶的总数最好是【质数/素数】（这个不解释，爱思考的同学自己想一下）         ★分布式散列表（DHT）概述 
       ◇什么是 DHT？ 
  “分布式散列表”也称为“分布式哈希表”，洋文是“distributed hash table”，简称 DHT。  “分布式散列表”在概念上类似与传统的“散列表”，差异在于——  “传统的散列表”主要是用于单机上的某个软件中；  “分布式散列表”主要是用于分布式系统（此时，分布式系统的节点可以通俗理解为散列表中的 bucket）   “分布式散列表”主要是用来存储大量的（甚至是海量的）数据。在实际使用场景中，直接对所存储的“每一个业务数据”计算散列值，然后用散列值作为 key，业务数据本身是 value。          （分布式散列表的示意图，此图剽窃自维基百科） 
  （为了偷懒，本文以下部分均使用 DHT 来表示“分布式散列表”）        ◇为啥会出现 DHT？ 
  在 P2P 文件共享的发展史上，出现过3种不同的技术路线（三代）。   
   第1代
    采用【中央服务器】的模式——每个节点都需要先连接到中央服务器，然后才能查找到自己想要的文件在哪里。  这种技术的最大缺点是——中央服务器成为整个 P2P 网络的【单点故障】。  （关于“单点故障”这个概念，可以看另一篇介绍：《  聊聊“单点故障”——关于“德国空难”和“李光耀”的随想  》）  这类 p2p 的典型代表是  Napster  。   
   第2代
    采用【广播】的模式——要找文件的时候，每个节点都向自己相连的【所有节点】进行询问；被询问的节点如果不知道这个文件在哪里，就再次进行“广播”......如此往复，直至找到所需文件。  这种技术的最大缺点是——会引发“广播风暴”并严重占用网络带宽，也会严重消耗节点的系统资源。即使在协议层面通过设置 TTL（time to live），限制查询过程只递归 N 轮，依然【无法】彻底解决此弊端。  因为这种手法太吓人，获得“Query Flooding”的绰号。下面放一张示意图。          （示意图：第2代 P2P 的 Query Flooding） 
  这类 p2p 的典型代表是  Gnutella  的早期版本。   
   第3代
    这一代采用的技术就是今天要聊的 DHT。  通过 DHT 这个玩意儿，不但避免了第一代技术的【单点故障】，也避免了第二代技术的【广播风暴】。        ◇DHT 有哪些应用场景？ 
  DHT 最早用于 P2P 文件共享和文件下载（比如：BT、电驴、电骡），之后也被广泛用于某些分布式系统中，比如：      
分布式文件系统  分布式缓存  暗网（比如：  I2P  、  Freenet  ）  无中心的聊天工具/IM（比如：  TOX  ）  无中心的微博客/microblogging（比如：  Twister  ）  无中心的社交网络/SNS    
 正是因为【无中心】的分布式系统普遍使用 DHT，所以本文开头称之为：分布式系统的【基础设施】。         ★分布式散列表（DHT）的难点 
       ◇“无中心”导致的难点 
  前面提到了 DHT 的诞生，是为了解决前面两代 P2P 技术的缺陷。其中一个缺陷是“中央服务器”导致的【单点故障】。  因此 DHT 就【不能】再依靠中央服务器。而没有了中央服务器，就需要提供一系列机制来实现节点之间的通讯。        ◇“海量数据”导致的难点 
  DHT 的很多使用场景是为了承载海量数据（PB 或更高级别）。  由于数据是海量的，每个节点只能存储（整个系统的）一小部分数据。需要把数据【均匀分摊】到每个节点。        ◇“节点动态变化”导致的难点 
  很多 DHT 的使用场景是在公网（互联网）上，参与 DHT 的节点（主机）会出现【频繁变化】——每时每刻都有新的节点上线，也会有旧的节点下线。在这种情况下，需要确保数据依然是【均匀分摊】到所有节点。   （俺特别强调一下：传统的散列表在这种情况下的困难）  前面提到：传统散列表所含的【桶数】是固定不变滴。为啥捏？  因为传统散列表在针对 key 计算出散列值之后，需要用“散列值”和“桶数”进行某种运算（比如：取模运算），从而得到桶的编号。  如果桶的数量出现变化，就会影响到上述“取模运算”的结果，然后导致数据错乱。        ◇“高效查询”导致的难点 
  对于节点数很多的分布式系统，如何快速定位节点，同时又不消耗太多网络资源，这也是一个挑战。  比如前面提到第二代 P2P 技术，在查找所需文件时会导致【广播风暴】。这就成为其致命弱点。  DHT 必须有更高效的查找机制。而且这种查找机制要能适应“节点动态变化”这个特点。         ★分布式散列表（DHT）如何解决上述难点？ 
  DHT 采用如下一些机制来解决上述问题，并满足分布式系统比较苛刻的需求。        ◇“散列算法”的选择 
  前面提到：DHT 通常是直接拿业务数据的散列值作为 key，业务数据本身作为 value。  考虑到 DHT 需要承载的数据量通常比较大，散列函数产生的“散列值范围”（keyspace）要足够大，以防止太多的碰撞。更进一步，如果 keyspace【大到一定程度】，使得“随机碰撞”的概率小到忽略不计，就有助于简化 DHT 的系统设计。  通常的 DHT 都会采用大于等于 128 比特的散列值（2  128  比 “地球上所有电子文档总数” 还要大【很多数量级】）。        ◇同构的“node ID”与“data key” 
  DHT 属于分布式系统的一种。既然是分布式系统，意味着存在【多个】节点（电脑主机）。在设计分布式系统的时候，一种常见的做法是：给每一个节点（node）分配【唯一的】ID。有了这个节点 ID（node ID），在系统设计上的好处是——对分布式系统所依赖的物理网络的【解耦】。  很多 DHT 的设计会让“node ID”采用跟“data key”【同构】的散列值。这么搞的好处是：  1、当散列值空间足够大的时候，随机碰撞忽略不计，因此也就确保了 node ID 的唯一性  2、可以简化系统设计——比如简化路由算法（下面会提及）        ◇“拓扑结构”的设计 
  作为分布式系统，DHT 必然要定义某种拓扑结构；有了拓扑结构，自然就要设计某种“路由算法”。  如果某个 DHT 采用前面所说的——“node ID”与“data key”【同构】——那么很自然的就会引入“  Key-based routing  ”。  请注意，这【不是】某个具体的路由算法，而只是某种【风格】。采用这种风格来设计路由机制，好处是： 
   key 本身已经提供了足够多的路由信息
   。   当某个分布式系统具有自己的拓扑结构，它本身成为一个“覆盖网络”（洋文叫“Overlay Network”）。所谓的“覆盖网络”，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的“覆盖网络”，它们的数据通讯是依赖下层的互联网来实现的。  前面提到的“node ID”，其【解耦】的作用就体现在——分布式系统在设计拓扑结构和路由算法时，只需要考虑 node ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。        ◇“路由算法”的权衡 
  由于 DHT 中的节点数可能非常多（比如：几十万、几百万），而且这些节点是动态变化的。因此就【不可能】让每一个节点都记录所有其它节点的信息。实际情况是：每个节点通常只知道少数一些节点的信息。  这时候就需要设计某种路由算法，尽可能利用已知的节点来转发数据。“路由算法”这玩意儿很重要，直接决定了 DHT 的速度和资源消耗。  在确定了路由算法之后，还需要做一个两难的权衡——“路由表的大小”。  路由表越大，可以实现越短（跳数越少）的路由；缺点是：（由于节点动态变化）路由表的维护成本也就越高。  路由表数越小，其维护成本越小；缺点是：路由就会变长（跳数变多）。        ◇距离算法 
  某些 DHT 系统还会定义一种“距离算法”，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。  请注意：此处所说的“距离”属于【逻辑层面】，对应的是 DHT 自己的拓扑结构；它与地理位置【无关】，也与互联网的拓扑结构【无关】。  写到这里，某些聪明的读者就会明白：为啥前面要强调——“node ID”与“data key”【同构】。当这两者【同构】，就可以使用【同一种“距离算法”】；反之，如果这两者不同构，多半要引入几种不同的“距离算法”。        ◇数据定位 
  有了前面这一大砣东西作为铺垫，现在就可以来谈谈“数据定位”啦。对 DHT 而言，这是最关键的东东。  DHT 与传统的散列表在【功能】上是类似的。说白了，他们最关键的功能只有两个——“保存数据”和“获取数据”。如果用 C 语言来表示的话，函数原型大致如下：      void put(KEY k, VALUE v);  // 保存“键值对”
VALUE get(KEY k);  // 根据“键”获取“值”    
  
   保存数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点得到了新加入的数据（K/V），它会先计算自己与新数据的 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么这个数据就保持在自己这里。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。   
   获取数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点接收到查询数据的请求（key），它会先计算自己与 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么就在自己这里找有没有 key 对应的 value。有的话就返回 value，没有的话就报错。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。         ★  Chord 协议  简介 
       ◇概述 
  Chord 诞生于2001年。第一批 DHT 协议都是在那年涌现的，另外几个是：  CAN  、  Tapestry  、  Pastry  。  俺之所以选取 Chord 来介绍，主要是因为 Chord 的原理比较简单（概念好理解），而且相关的资料也很多。   （请允许俺稍微跑题，聊一下 IT 八卦）  Chord 是 MIT 的几个技术牛人一起搞出来的，这几个牛人中包括世界级的黑客：罗伯特·莫里斯（  Robert Morris  ）。  此人以“  莫里斯蠕虫  ”而享誉信息安全界。这是 IT 史上【第一个】蠕虫（注：蠕虫可以利用网络【实时】传播），这个蠕虫对当时（1988年）的互联网造成毁灭性打击（一天之内，约十分之一的互联网主机中招并下线）。  他不仅是编程高手兼顶级黑客，而且是创业者兼投资人。他与同样大名鼎鼎的保罗·格雷汉姆（  Paul Graham  ）以及  Trevor Blackwell  ，3人在1995年共同创立了  Viaweb  ，并在1998年把公司以5千万美元卖给 Yahoo。然后他们拿这笔钱创办了  Y Combinator  （如今世界闻名的风投机构）。        ◇拓扑结构——环形 
  要聊 Chord 的拓扑，必然要提到“  Consistent Hashing  ”（译作：“一致散列”或“稳定散列”）。搞明白“一致散列”也就知道 Chord 的拓扑设计了。  提出“一致散列”这个概念主要是为了解决“节点动态变化”的难点（前面有提及）。为了解决这个难点，“一致散列”把散列值空间（keyspace）构成一个【环】。对于 
   m
   比特的散列值，其范围是 
   [0, 2
   
    m
   
   -1]
   。你把这个区间头尾相接就变成一个环，其周长是 
   2
   
    m
   
   。然后对这个环规定了一个移动方向（比如顺时针）。  如果 node ID 和 data key 是同构的，那么这两者都可以映射到这个环上（对应于环上的某点）。          （示意图：环形的 keyspace） 
  假设有某个“节点A”，距离它最近的是“节点B”（以顺时针方向衡量距离）。那么称 B 是 A 的【继任】（successor），A 是 B 的【前任】（predecessor）。   数据隶属于【距离最小】的节点。以 
   m = 6
   的环形空间为例：  数据区间 
   [5,8]
   隶属于“节点8”  数据区间 
   [9,15]
   隶属于“节点15”  ......  数据区间 
   [59,4]
   隶属于“节点4”（注：“6比特”的环形空间， 
   63
   之后是 
   0
   ）          （示意图：“数据”与“节点”对应关系） 
  以上就是“一致性散列”的拓扑结构，同时也是 Chord 的拓扑结构。        ◇路由机制 
  接下来简单说一下路由的玩法。   
   基本路由（简单遍历）
    当收到请求（key），先看 key 是否在自己这里。如果在自己这里，就直接返回信息；否则就把 key 转发给自己的继任者。以此类推。  这种玩法的时间复杂度是： 
   O(N)
   。对于一个节点数很多的 DHT 网络，这种做法显然【非常低效】。   
   高级路由（Finger Table）
    由于“基本路由”非常低效，自然就引入更高级的玩法——基于“Finger Table”的路由。  “Finger Table”是一个列表，最多包含 
   m
   项（ 
   m
   就是散列值的比特数），每一项都是节点 ID。  假设当前节点的 ID 是 
   n
   ，那么表中第 
   i
   项的值是： 
   successor( (n + 2
   
    i
   
   ) mod 2
   
    m
   
   )
    当收到请求（key），就到“Finger Table”中找到【最大的且不超过 key】的那一项，然后把 key 转发给这一项对应的节点。  有了“Finger Table”之后，时间复杂度可以优化为： 
   O(log N)
   。          （示意图：Finger Table） 
       ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 通过跟 B 进行查询，找到自己这个 ID 在环上的接头人。也就是——找到自己这个 ID 对应的“继任”（假设叫 C）与“前任”（假设叫 D）  4  接下来，A 需要跟 C 和 D 进行一系列互动，使得自己成为 C 的前任，以及 D 的继任。  这个互动过程，大致类似于在双向链表当中插入元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【正常】退出 
  如果某个节点想要主动离开这个 DHT 网络，按照约定需要作一些善后的处理工作。比如说，通知自己的前任去更新其继任者......  这些善后处理，大致类似于：在双向链表中删除元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【异常】退出 
  作为一个分布式系统，任何节点都有可能意外下线（也就是说，来不及进行善后就挂掉了）  假设 节点A 的继任者【异常】下线了，那么 节点A 就抓瞎了。咋办捏？  为了保险起见，Chord 引入了一个“继任者候选列表”的概念。每个节点都用这个列表来包含：距离自己最近的 N 个节点的信息，顺序是【由近到远】。一旦自己的继任者下线了，就在列表中找到一个【距离最近且在线】的节点，作为新的继任者。然后 节点A 更新该列表，确保依然有 N 个候选。更新完“继任者候选列表”后，节点A 也会通知自己的前任，那么 A 的前任也就能更新自己的“继任者候选列表”。        ◇引申阅读 
  Chord 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Chord——A Scalable Peer-to-peer Lookup Service for Internet Applications  》         ★  Kademlia（Kad）协议  简介 
  （注：由于“Kademlia”这个词太长，为了打字省力，以下都采用“Kad”这个简写）        ◇概述 
  Kad 诞生于2002年，由纽约大学的两个牛人（Petar Maymounkov &amp; David Mazières）共同设计（他俩的论文，在本章节末尾附有链接）。  Kad 的原理比 Chord 稍微晦涩一些（涉及一点点数据结构的知识，如果你是程序猿，不用怕）。俺之所以选 Kad 来介绍，是因为——实际应用的 DHT 大部分都采用 Kad 及其变种。比如几种知名的 P2P 下载（BT、eDonkey/电驴、eMule/电骡）的 DHT 都是基于 Kad；知名的 I2P 暗网也依赖 Kad（说到 I2P，俺博客写过一篇扫盲教程，在“  这里  ”）。        ◇拓扑结构——二叉树 
  
   散列值的预处理
    Kad 也采用了“node ID 与 data key 同构”的设计思路。然后 Kad 采用某种算法把 key 映射到一个二叉树，每一个 key 都是这个二叉树的【叶子】。  在映射之前，先做一下预处理。  1. 先把 key 以二进制形式表示。  2. 把每一个 key 缩短为它的【最短唯一前缀】。   
   为啥要搞“最短唯一前缀”？
    Kad 使用 
   160比特
   的散列算法（比如 SHA1），完整的 key 用二进制表示有 
   160
   个数位（bit）。  首先，实际运行的 Kad 网络，即使有几百万个节点，相比 keyspace（2  160  ）也只是很小很小很小的一个子集。  其次，由于散列函数的特点，key 的分布是【高度随机】的。因此也是【高度离散】的——任何两个 key 都【不会】非常临近。  所以，使用“最短唯一前缀”来处理 key 的二进制形式，得到的结果就会很短（比特数远远小于 160）。   
   散列值的映射
    完成上述的预处理后，接下来的映射规则是：  1. 先把 key 以二进制形式表示，然后从高位到低位依次处理。  2. 二进制的第 
   n
   个 bit 就对应了二叉树的第 
   n
   层  3. 如果该位是 
   1
   ，进入左子树，是 
   0
   则进入右子树（这只是人为约定，反过来处理也可以）  4. 全部数位都处理完后，这个 key 就对应了二叉树上的某个【叶子】          （示意图：“最短唯一前缀”映射到二叉树的叶子） 
       ◇距离算法——异或（XOR） 
  接下来要聊的是 Kad【最精妙之处】——采用 XOR（按位异或操作）算法计算 key 之间的“距离”。  这种搞法使得它具备了类似于“几何距离”的某些特性（下面用 ⊕ 表示 XOR）      
      
        
          
      (A ⊕ B) == (B ⊕ A)
     
          XOR 符合“交换律”，具备对称性。相比之下，Chord 的距离算法不对称
        
        
          
      (A ⊕ A) == 0
     
          反身性，自身距离为零
        
        
          
      (A ⊕ B) &gt; 0
     
          【不同】的两个 key 之间的距离必大于零
        
        
          
      (A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)
     
          三角不等式
        
      
    
       ◇路由机制 
  
   二叉树的拆分
    对每一个节点，都可以【按照自己的视角】对整个二叉树进行拆分。  拆分的规则是：先从根节点开始，把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推，直到最后只剩下自己。  Kad 默认的散列值空间是 
   m = 160
   （散列值有 
   160 bits
   ），因此拆分出来的子树【最多】有 
   160
   个（考虑到实际的节点数【远远小于】 
   2
   
    160
   
   ，子树的个数会明显小于 
   160
   ）。  对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的【任何一个】节点（考虑到篇幅，具体的数学证明就不贴出来了）          （示意图：二叉树的拆分。 
    注：图中的“第三”与“第四”应对调。非常感谢热心读者在评论区指正！
    ） 
  
   K-桶（K-bucket）
    前面说了，每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（请始终牢记：分布式系统的节点是动态变化滴），光知道【一个】显然是不够滴，需要知道【多个】才比较保险。  所以 Kad 论文中给出了一个“K-桶（K-bucket）”的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 
   K
   个节点。这里所说的 
   K
   值是一个【系统级】的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 
   8
   ）。  这个“K-桶”其实就是【路由表】。对于某个节点而言，如果【以它自己为视角】拆分了 
   n
   个子树，那么它就需要维护 
   n
   个路由表，并且每个路由表的【上限】是 
   K
   。  说 K 只是一个【上限】，是因为有两种情况使得 K 桶的尺寸会小于 K。  1. 距离越近的子树就越小。如果整个子树【可能存在的】节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。  2. 有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。          （示意图：K = 2 的路由表） 
         （示意图：路由过程） 
  
   K-桶（K-bucket）的刷新机制
    刷新机制大致有如下几种：  1. 主动收集节点  任何节点都可以主动发起“查询节点”的请求（对应于协议类型 FIND_NODE），从而刷新 K 桶中的节点信息（下面聊“节点的加入”时，会提及这种）  2. 被动收集节点  如果收到其它节点发来的请求（协议类型 FIND_NODE 或 FIND_VALUE），会把对方的 ID 加入自己的某个 K 桶中。  3. 探测失效节点  Kad 还是支持一种探测机制（协议类型 PING），可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点，然后把下线的节点从路由表中干掉。   
   “并发请求”与“α 参数”
    “K桶”的这个设计思路【天生支持并发】。因为【同一个】“K桶”中的每个节点都是平等的，没有哪个更特殊；而且对【同一个】“K桶”中的节点发起请求，互相之间没有影响（无耦合）。  所以 Kad 协议还引入了一个“α参数/α因子”，默认设置为 
   3
   ，使用 Kad 的软件可以在具体使用场景中调整这个“α因子”。  当需要路由到某个“子树”，会从该子树对应的“K桶”中挑选【α个节点】，然后对这几个节点【同时】发出请求。  这么做有啥好处捏？俺在本文末尾聊“性能”和“安全性”时会具体介绍。        ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 向 B 发起一个查询请求（协议类型 FIND_NODE），请求的 ID 是自己（通俗地说，就是查询自己）  4  B 收到该请求之后，（如前面所说）会先把 A 的 ID 加入自己的某个 K 桶中。  然后，根据 FIND_NODE 协议的约定，B 会找到【K个】最接近 A 的节点，并返回给 A。  （B 怎么知道哪些节点接近 A 捏？这时候，【用 XOR 表示距离】的算法就发挥作用啦）  5  A 收到这 K 个节点的 ID 之后，（仅仅根据这批 ID 的值）就可以开始初始化自己的 K 桶。  6  然后 A 会继续向刚刚拿到的这批节点发送查询请求（协议类型 FIND_NODE），如此往复（递归），直至 A 建立了足够详细的路由表。        ◇节点的退出 
  与 Chord 不同，Kad 对于节点退出没有额外的要求（没有“主动退出”的说法）。  所以，Kad 的节点想离开 DHT 网络【不】需要任何操作（套用徐志摩的名言：  悄悄的我走了，正如我悄悄的来  ）        ◇引申阅读 
  Kad 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Kademlia——A Peer-to-peer Information System Based on the XOR Metric  》         ★为啥 Kad 成为 DHT 的主流？ 
  Kad 成为 DHT 的主流实现方式，这已经是很明显的事实。问题在于：为啥会是它？  这是一个比较发散的问题，以下是俺个人观点，供参考。        ◇简单性 
  在“简单性”方面，Kad 和 Chord 都属于很简单的。所以俺要拿一个【反面教程】作为对比。  下面俺来说说 CAN（Content Addressable Network）——它是最早出现的四个 DHT 协议之一（2001年），在学术界也算很有名气。  介绍 CAN 的资料，通常会在开篇提到：CAN 的拓扑结构是基于【多维笛卡尔环面】。俺相信很多程序员看到这个词汇，心里会咯噔一下，脑袋会大一圈。  和 CAN 的【多维环面】比起来，Kad 基于【二叉树】的拓扑结构，就显得异常简单、非常亲切。假如要让程序员在 “二叉树” 和 “多维笛卡尔环面” 二选一，都不用调查问卷，俺就敢打保票——超过 99% 的程序员会选择“二叉树”。  Kad 除了拓扑结构很简单，它的距离算法也很简单——只不过是节点 ID 的异或运算（XOR）。   （稍微跑题一下）  有很多充满学院派气息的系统设计，最终成为空中楼阁，就是因为：这些系统的【设计太复杂】了。当程序员对设计望而生畏，更有可能的情况是：要么没人愿意动手写，要么是有人动手写了，但是迟迟做不出来。        ◇灵活性 
  以 Kad 和 Chord 的路由表来作对比。  Kad 的“K-bucket”是可以根据使用场景来调整 K 值，而且对 K 值的调整完全不影响代码实现。这就是所谓的“适应需求的灵活性”（有时也称之为“设计的弹性”）。  相比之下，Chord 的“Finger Table”就没有这种灵活性。        ◇性能 
  Kad 的路由算法天生就支持【并发】（参见前面介绍的“α 参数”）。  而很多 DHT 协议（包括 Chord）没有这种优势。  由于公网上的线路具有很大的不确定性（极不稳定），哪怕是同样两个节点，之间的传输速率也可能时快时慢。由于 Kad 路由请求支持并发，发出请求的节点总是可以获得最快的那个 peer 的响应。        ◇安全性 
  考虑到本文只介绍了 Chord 和 Kad，还是拿它俩做对比。  假设某个攻击者想要搞 Chord 网络的某个节点（假设叫 A），他/她可以先获得此 节点A 的 ID（这并不难）。知道 节点A 的 ID 后，攻击者就可以运行若干个受控的 Chord 节点（恶意节点），并且精心设置这批恶意节点的 ID；当这批恶意节点加入 Chord 网络后，就可以顺利被添加到 节点A 的路由表中（具体的原理，参见前面对“Finger Table”的介绍）。一旦 节点A 的路由表加入【足够多】的恶意节点，那么 节点A 的路由就有【足够大】的概率会经过这批恶意节点。攻击者作为这批恶意节点的控制人，就可以对 节点A 做很多手脚。   从理论上讲，类似的手法也可以用来针对 Kad。但是攻击难度会显著变大。原因如下：  1  Kad 协议缺省约定——在线时间越长的节点越可能被加入“K桶”。所以攻击者哪怕构造了一批恶意节点，这些恶意节点要想被正常节点加入自己的“K桶”，难度也很大。  2  就算某个恶意节点（比如叫 X）被正常节点（比如叫 A）加入“K-桶”。由于一个“K-桶”只对应【一个子树】。所以，只有当 节点A 在针对某个【特定子树】进行路由的时候，才【有可能】会碰上这个恶意节点。  （唠叨一下：Kad 的路由算法中，对每个子树都维护一个“K-桶”作为路由表）  3  即便正好对这个子树路由，也【不一定】会碰上恶意节点——碰上的【概率】取决于：“K 的大小” 以及 “从桶中选取节点的策略”。  4  前面提到：Kad 协议支持【并发查询】——每次都会从同一个“K-桶”中取出【α个】节点，发出查询请求（参数 α 默认设为 3,可以调大）  所以，这【α 个节点】中，如果只有一个是恶意的，这个恶意节点也很难捣乱；除非这【α 个节点】全部都是恶意的，而这个概率又很小。   （注：俺并【没有】说 Kad 是最安全的。这段介绍只能让你体会一下“K-桶”的设计思路——除了增加性能，还顺便增加了攻击者的难度）        ◇小结 
  刚才聊的这几个方面，对每一个方面，Kad 未必能排第一，但至少它都能排进前几名。  几个方面综合起来，它就成为最有竞争力和活力的 DHT 技术方案。         ★结尾 
  刚才聊到了“安全性”，本来还想再写一个章节，谈谈“针对 DHT 网络的攻击手法”。不过捏，本文已经写了很长，为了照顾某些患有“阅读障碍症”的读者，就先到此为止吧。今后另外找时间谈“攻击 DHT”这个话题。  由于本文的某些内容，俺也是现学现卖。如有错漏之处，还望懂行的同学不吝赐教 :)    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲文件完整性校验——关于散列值和数字签名    聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？    “如何翻墙”系列：简单扫盲 I2P 的使用    “对抗专制、捍卫自由”的 N 种技术力量    聊聊“单点故障”——关于“德国空难”和“李光耀”的随想      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例  
  
    
      
    
  
  
     ★引子——为啥要聊这个话题？ 
  这是一篇比较深入地谈技术的博文（而且还牵涉到一点算法）。俺很久没有写这种类型的博文了。  今天发这篇，主要是因为如下几点：  1  在“对抗 GFW、对抗政府审查”的过程中，【彻底无中心】的分布式系统是非常有用滴！  （关于这点，请参见前几年的博文：《  “对抗专制、捍卫自由”的 N 种技术力量  》）  2  DHT 是这类分布式系统的【关键基础设施】，俺希望追求自由的网民能多了解这方面的知识  3  俺也希望有更多程序员能参与这方面的【开源社区】。  在对抗政府审查的时候，商业公司是靠不住滴；只能指望开源社区。  4  虽然 GFW 已经在封杀 BT sync／Resilio Sync；但是，启用了 DHT 功能的 BTsync（必须是老版本），在墙内依然是【免翻墙】可用，让俺很受鼓舞 :)  （感兴趣的同学可以参见上个月的博文：《  聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？  》）  
       
        ★预备知识 
  （如果你自认为是一个熟练的程序员，请直接略过“预备知识”这个章节，看下一章节）        ◇什么是“散列/哈希（hash）”？ 
  （注：在本文中，凡是提及“散列”或“哈希”或“hash”，均表示相同含义）  关于 hash 的概念，俺曾经写过一篇相关的扫盲教程《  扫盲文件完整性校验——关于散列值和数字签名  》，不了解此概念的同学，可以先看看。  老实说，如果你还没有搞明白 hash 的概念，就不要浪费时间看本文的后续部分了。        ◇什么是“散列表/哈希表（hash table）”？ 
  “散列表/哈希表”是用来存储“键值对”的一种容器。“键值对”洋文称之为“key/value pairs”，简称“K/V”。有了“散列表”，你可以很方便快速地通过 key 来获得 value。  举个例子：  手机通讯簿可以通俗理解成一个“散列表”。里面的每一条记录都包含“姓名”和“电话号码”。“姓名”相当于“键值对”中的 key，电话号码相当于 value。你可以通过姓名方便地查找出电话号码。        ◇如何实现散列表？ 
  （考虑到本文的完整性，【简单介绍】一下散列表的实现）  在散列表这种数据结构中，会包含 N 个 bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是【固定不变】的。于是可以对每个桶进行编号，从 0 到 N-1。  “桶”是用来存储“键值对”的，你可以把它通俗理解成一个动态数组，里面可以存放【多个】“键值对”。  下面这张图是从维基百科上剽窃来的。它展示了散列表的【查找】原理。当使用某个 key 进行查找，会先用某个散列函数计算这个 key 的散列值。得到散列值通常是一个整数，然后用散列值对 N（桶数）进行“取模”运算（除法求余数），就可以算出对应的桶编号。  （注：取模运算是最常用的做法，但不是唯一的做法）          （使用散列表存储电话簿的示意图，剽窃自维基百科） 
       ◇什么是“散列表”的【碰撞/冲突】（Collision）？ 
  在俺那篇  扫盲教程  中，已经介绍了“散列碰撞”（也称为“散列冲突”）的概念。  当两个不同的 key 进行哈希计算却得到【相同的散列值】，就是所谓的【散列函数碰撞】。一旦出现这种情况，这两个 key 对应的两个键值对就会被存储在【同一个】桶（bucket）里面。  另一种情况是：虽然计算出来的散列值【不同】，但经过“取模运算”之后却得到【相同】的桶编号。这时候也会出现：两个键值对存储在一个桶里面。          （出现“散列碰撞”的示意图，剽窃自维基百科） 
  如果某个哈希表在存储数据时【完全没有碰撞】，那么每个桶里面都只有 0个 或 1个 键值对。查找起来就非常快。  反之，如果某个哈希表在存储数据时出现【严重碰撞】，就会导致某些桶里面存储了一大坨的键值对。将来查找 key 的时候，如果定位到的是这种“大桶”，就需要在这个桶里面逐一比对 key 是否相同——查找效率就会变得很差。        ◇“散列表”有哪些优点？ 
  主要优点是：（当数据量很大时）散列表可以提供快速且稳定的查找速度。  当然，这里有个前提就是：散列函数要【足够好】——  1、计算出的散列值要足够离散（从而使得不同的键值对可以比较【均匀】地分配到各个桶里面）  2、要尽可能降低碰撞（碰撞会降低性能）  另一个前提是：桶的数量也有一定的讲究——  1、桶数要足够大。否则的话，【必定会】导致某些桶里面的键值对太多（这点很明显，没想明白的同学，可参见“抽屉原理”）  2、（如果用常见的“取模”映射到桶）桶的总数最好是【质数/素数】（这个不解释，爱思考的同学自己想一下）         ★分布式散列表（DHT）概述 
       ◇什么是 DHT？ 
  “分布式散列表”也称为“分布式哈希表”，洋文是“distributed hash table”，简称 DHT。  “分布式散列表”在概念上类似与传统的“散列表”，差异在于——  “传统的散列表”主要是用于单机上的某个软件中；  “分布式散列表”主要是用于分布式系统（此时，分布式系统的节点可以通俗理解为散列表中的 bucket）   “分布式散列表”主要是用来存储大量的（甚至是海量的）数据。在实际使用场景中，直接对所存储的“每一个业务数据”计算散列值，然后用散列值作为 key，业务数据本身是 value。          （分布式散列表的示意图，此图剽窃自维基百科） 
  （为了偷懒，本文以下部分均使用 DHT 来表示“分布式散列表”）        ◇为啥会出现 DHT？ 
  在 P2P 文件共享的发展史上，出现过3种不同的技术路线（三代）。   
   第1代
    采用【中央服务器】的模式——每个节点都需要先连接到中央服务器，然后才能查找到自己想要的文件在哪里。  这种技术的最大缺点是——中央服务器成为整个 P2P 网络的【单点故障】。  （关于“单点故障”这个概念，可以看另一篇介绍：《  聊聊“单点故障”——关于“德国空难”和“李光耀”的随想  》）  这类 p2p 的典型代表是  Napster  。   
   第2代
    采用【广播】的模式——要找文件的时候，每个节点都向自己相连的【所有节点】进行询问；被询问的节点如果不知道这个文件在哪里，就再次进行“广播”......如此往复，直至找到所需文件。  这种技术的最大缺点是——会引发“广播风暴”并严重占用网络带宽，也会严重消耗节点的系统资源。即使在协议层面通过设置 TTL（time to live），限制查询过程只递归 N 轮，依然【无法】彻底解决此弊端。  因为这种手法太吓人，获得“Query Flooding”的绰号。下面放一张示意图。          （示意图：第2代 P2P 的 Query Flooding） 
  这类 p2p 的典型代表是  Gnutella  的早期版本。   
   第3代
    这一代采用的技术就是今天要聊的 DHT。  通过 DHT 这个玩意儿，不但避免了第一代技术的【单点故障】，也避免了第二代技术的【广播风暴】。        ◇DHT 有哪些应用场景？ 
  DHT 最早用于 P2P 文件共享和文件下载（比如：BT、电驴、电骡），之后也被广泛用于某些分布式系统中，比如：      
分布式文件系统  分布式缓存  暗网（比如：  I2P  、  Freenet  ）  无中心的聊天工具/IM（比如：  TOX  ）  无中心的微博客/microblogging（比如：  Twister  ）  无中心的社交网络/SNS    
 正是因为【无中心】的分布式系统普遍使用 DHT，所以本文开头称之为：分布式系统的【基础设施】。         ★分布式散列表（DHT）的难点 
       ◇“无中心”导致的难点 
  前面提到了 DHT 的诞生，是为了解决前面两代 P2P 技术的缺陷。其中一个缺陷是“中央服务器”导致的【单点故障】。  因此 DHT 就【不能】再依靠中央服务器。而没有了中央服务器，就需要提供一系列机制来实现节点之间的通讯。        ◇“海量数据”导致的难点 
  DHT 的很多使用场景是为了承载海量数据（PB 或更高级别）。  由于数据是海量的，每个节点只能存储（整个系统的）一小部分数据。需要把数据【均匀分摊】到每个节点。        ◇“节点动态变化”导致的难点 
  很多 DHT 的使用场景是在公网（互联网）上，参与 DHT 的节点（主机）会出现【频繁变化】——每时每刻都有新的节点上线，也会有旧的节点下线。在这种情况下，需要确保数据依然是【均匀分摊】到所有节点。   （俺特别强调一下：传统的散列表在这种情况下的困难）  前面提到：传统散列表所含的【桶数】是固定不变滴。为啥捏？  因为传统散列表在针对 key 计算出散列值之后，需要用“散列值”和“桶数”进行某种运算（比如：取模运算），从而得到桶的编号。  如果桶的数量出现变化，就会影响到上述“取模运算”的结果，然后导致数据错乱。        ◇“高效查询”导致的难点 
  对于节点数很多的分布式系统，如何快速定位节点，同时又不消耗太多网络资源，这也是一个挑战。  比如前面提到第二代 P2P 技术，在查找所需文件时会导致【广播风暴】。这就成为其致命弱点。  DHT 必须有更高效的查找机制。而且这种查找机制要能适应“节点动态变化”这个特点。         ★分布式散列表（DHT）如何解决上述难点？ 
  DHT 采用如下一些机制来解决上述问题，并满足分布式系统比较苛刻的需求。        ◇“散列算法”的选择 
  前面提到：DHT 通常是直接拿业务数据的散列值作为 key，业务数据本身作为 value。  考虑到 DHT 需要承载的数据量通常比较大，散列函数产生的“散列值范围”（keyspace）要足够大，以防止太多的碰撞。更进一步，如果 keyspace【大到一定程度】，使得“随机碰撞”的概率小到忽略不计，就有助于简化 DHT 的系统设计。  通常的 DHT 都会采用大于等于 128 比特的散列值（2  128  比 “地球上所有电子文档总数” 还要大【很多数量级】）。        ◇同构的“node ID”与“data key” 
  DHT 属于分布式系统的一种。既然是分布式系统，意味着存在【多个】节点（电脑主机）。在设计分布式系统的时候，一种常见的做法是：给每一个节点（node）分配【唯一的】ID。有了这个节点 ID（node ID），在系统设计上的好处是——对分布式系统所依赖的物理网络的【解耦】。  很多 DHT 的设计会让“node ID”采用跟“data key”【同构】的散列值。这么搞的好处是：  1、当散列值空间足够大的时候，随机碰撞忽略不计，因此也就确保了 node ID 的唯一性  2、可以简化系统设计——比如简化路由算法（下面会提及）        ◇“拓扑结构”的设计 
  作为分布式系统，DHT 必然要定义某种拓扑结构；有了拓扑结构，自然就要设计某种“路由算法”。  如果某个 DHT 采用前面所说的——“node ID”与“data key”【同构】——那么很自然的就会引入“  Key-based routing  ”。  请注意，这【不是】某个具体的路由算法，而只是某种【风格】。采用这种风格来设计路由机制，好处是： 
   key 本身已经提供了足够多的路由信息
   。   当某个分布式系统具有自己的拓扑结构，它本身成为一个“覆盖网络”（洋文叫“Overlay Network”）。所谓的“覆盖网络”，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的“覆盖网络”，它们的数据通讯是依赖下层的互联网来实现的。  前面提到的“node ID”，其【解耦】的作用就体现在——分布式系统在设计拓扑结构和路由算法时，只需要考虑 node ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。        ◇“路由算法”的权衡 
  由于 DHT 中的节点数可能非常多（比如：几十万、几百万），而且这些节点是动态变化的。因此就【不可能】让每一个节点都记录所有其它节点的信息。实际情况是：每个节点通常只知道少数一些节点的信息。  这时候就需要设计某种路由算法，尽可能利用已知的节点来转发数据。“路由算法”这玩意儿很重要，直接决定了 DHT 的速度和资源消耗。  在确定了路由算法之后，还需要做一个两难的权衡——“路由表的大小”。  路由表越大，可以实现越短（跳数越少）的路由；缺点是：（由于节点动态变化）路由表的维护成本也就越高。  路由表数越小，其维护成本越小；缺点是：路由就会变长（跳数变多）。        ◇距离算法 
  某些 DHT 系统还会定义一种“距离算法”，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。  请注意：此处所说的“距离”属于【逻辑层面】，对应的是 DHT 自己的拓扑结构；它与地理位置【无关】，也与互联网的拓扑结构【无关】。  写到这里，某些聪明的读者就会明白：为啥前面要强调——“node ID”与“data key”【同构】。当这两者【同构】，就可以使用【同一种“距离算法”】；反之，如果这两者不同构，多半要引入几种不同的“距离算法”。        ◇数据定位 
  有了前面这一大砣东西作为铺垫，现在就可以来谈谈“数据定位”啦。对 DHT 而言，这是最关键的东东。  DHT 与传统的散列表在【功能】上是类似的。说白了，他们最关键的功能只有两个——“保存数据”和“获取数据”。如果用 C 语言来表示的话，函数原型大致如下：      void put(KEY k, VALUE v);  // 保存“键值对”
VALUE get(KEY k);  // 根据“键”获取“值”    
  
   保存数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点得到了新加入的数据（K/V），它会先计算自己与新数据的 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么这个数据就保持在自己这里。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。   
   获取数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点接收到查询数据的请求（key），它会先计算自己与 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么就在自己这里找有没有 key 对应的 value。有的话就返回 value，没有的话就报错。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。         ★  Chord 协议  简介 
       ◇概述 
  Chord 诞生于2001年。第一批 DHT 协议都是在那年涌现的，另外几个是：  CAN  、  Tapestry  、  Pastry  。  俺之所以选取 Chord 来介绍，主要是因为 Chord 的原理比较简单（概念好理解），而且相关的资料也很多。   （请允许俺稍微跑题，聊一下 IT 八卦）  Chord 是 MIT 的几个技术牛人一起搞出来的，这几个牛人中包括世界级的黑客：罗伯特·莫里斯（  Robert Morris  ）。  此人以“  莫里斯蠕虫  ”而享誉信息安全界。这是 IT 史上【第一个】蠕虫（注：蠕虫可以利用网络【实时】传播），这个蠕虫对当时（1988年）的互联网造成毁灭性打击（一天之内，约十分之一的互联网主机中招并下线）。  他不仅是编程高手兼顶级黑客，而且是创业者兼投资人。他与同样大名鼎鼎的保罗·格雷汉姆（  Paul Graham  ）以及  Trevor Blackwell  ，3人在1995年共同创立了  Viaweb  ，并在1998年把公司以5千万美元卖给 Yahoo。然后他们拿这笔钱创办了  Y Combinator  （如今世界闻名的风投机构）。        ◇拓扑结构——环形 
  要聊 Chord 的拓扑，必然要提到“  Consistent Hashing  ”（译作：“一致散列”或“稳定散列”）。搞明白“一致散列”也就知道 Chord 的拓扑设计了。  提出“一致散列”这个概念主要是为了解决“节点动态变化”的难点（前面有提及）。为了解决这个难点，“一致散列”把散列值空间（keyspace）构成一个【环】。对于 
   m
   比特的散列值，其范围是 
   [0, 2
   
    m
   
   -1]
   。你把这个区间头尾相接就变成一个环，其周长是 
   2
   
    m
   
   。然后对这个环规定了一个移动方向（比如顺时针）。  如果 node ID 和 data key 是同构的，那么这两者都可以映射到这个环上（对应于环上的某点）。          （示意图：环形的 keyspace） 
  假设有某个“节点A”，距离它最近的是“节点B”（以顺时针方向衡量距离）。那么称 B 是 A 的【继任】（successor），A 是 B 的【前任】（predecessor）。   数据隶属于【距离最小】的节点。以 
   m = 6
   的环形空间为例：  数据区间 
   [5,8]
   隶属于“节点8”  数据区间 
   [9,15]
   隶属于“节点15”  ......  数据区间 
   [59,4]
   隶属于“节点4”（注：“6比特”的环形空间， 
   63
   之后是 
   0
   ）          （示意图：“数据”与“节点”对应关系） 
  以上就是“一致性散列”的拓扑结构，同时也是 Chord 的拓扑结构。        ◇路由机制 
  接下来简单说一下路由的玩法。   
   基本路由（简单遍历）
    当收到请求（key），先看 key 是否在自己这里。如果在自己这里，就直接返回信息；否则就把 key 转发给自己的继任者。以此类推。  这种玩法的时间复杂度是： 
   O(N)
   。对于一个节点数很多的 DHT 网络，这种做法显然【非常低效】。   
   高级路由（Finger Table）
    由于“基本路由”非常低效，自然就引入更高级的玩法——基于“Finger Table”的路由。  “Finger Table”是一个列表，最多包含 
   m
   项（ 
   m
   就是散列值的比特数），每一项都是节点 ID。  假设当前节点的 ID 是 
   n
   ，那么表中第 
   i
   项的值是： 
   successor( (n + 2
   
    i
   
   ) mod 2
   
    m
   
   )
    当收到请求（key），就到“Finger Table”中找到【最大的且不超过 key】的那一项，然后把 key 转发给这一项对应的节点。  有了“Finger Table”之后，时间复杂度可以优化为： 
   O(log N)
   。          （示意图：Finger Table） 
       ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 通过跟 B 进行查询，找到自己这个 ID 在环上的接头人。也就是——找到自己这个 ID 对应的“继任”（假设叫 C）与“前任”（假设叫 D）  4  接下来，A 需要跟 C 和 D 进行一系列互动，使得自己成为 C 的前任，以及 D 的继任。  这个互动过程，大致类似于在双向链表当中插入元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【正常】退出 
  如果某个节点想要主动离开这个 DHT 网络，按照约定需要作一些善后的处理工作。比如说，通知自己的前任去更新其继任者......  这些善后处理，大致类似于：在双向链表中删除元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【异常】退出 
  作为一个分布式系统，任何节点都有可能意外下线（也就是说，来不及进行善后就挂掉了）  假设 节点A 的继任者【异常】下线了，那么 节点A 就抓瞎了。咋办捏？  为了保险起见，Chord 引入了一个“继任者候选列表”的概念。每个节点都用这个列表来包含：距离自己最近的 N 个节点的信息，顺序是【由近到远】。一旦自己的继任者下线了，就在列表中找到一个【距离最近且在线】的节点，作为新的继任者。然后 节点A 更新该列表，确保依然有 N 个候选。更新完“继任者候选列表”后，节点A 也会通知自己的前任，那么 A 的前任也就能更新自己的“继任者候选列表”。        ◇引申阅读 
  Chord 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Chord——A Scalable Peer-to-peer Lookup Service for Internet Applications  》         ★  Kademlia（Kad）协议  简介 
  （注：由于“Kademlia”这个词太长，为了打字省力，以下都采用“Kad”这个简写）        ◇概述 
  Kad 诞生于2002年，由纽约大学的两个牛人（Petar Maymounkov &amp; David Mazières）共同设计（他俩的论文，在本章节末尾附有链接）。  Kad 的原理比 Chord 稍微晦涩一些（涉及一点点数据结构的知识，如果你是程序猿，不用怕）。俺之所以选 Kad 来介绍，是因为——实际应用的 DHT 大部分都采用 Kad 及其变种。比如几种知名的 P2P 下载（BT、eDonkey/电驴、eMule/电骡）的 DHT 都是基于 Kad；知名的 I2P 暗网也依赖 Kad（说到 I2P，俺博客写过一篇扫盲教程，在“  这里  ”）。        ◇拓扑结构——二叉树 
  
   散列值的预处理
    Kad 也采用了“node ID 与 data key 同构”的设计思路。然后 Kad 采用某种算法把 key 映射到一个二叉树，每一个 key 都是这个二叉树的【叶子】。  在映射之前，先做一下预处理。  1. 先把 key 以二进制形式表示。  2. 把每一个 key 缩短为它的【最短唯一前缀】。   
   为啥要搞“最短唯一前缀”？
    Kad 使用 
   160比特
   的散列算法（比如 SHA1），完整的 key 用二进制表示有 
   160
   个数位（bit）。  首先，实际运行的 Kad 网络，即使有几百万个节点，相比 keyspace（2  160  ）也只是很小很小很小的一个子集。  其次，由于散列函数的特点，key 的分布是【高度随机】的。因此也是【高度离散】的——任何两个 key 都【不会】非常临近。  所以，使用“最短唯一前缀”来处理 key 的二进制形式，得到的结果就会很短（比特数远远小于 160）。   
   散列值的映射
    完成上述的预处理后，接下来的映射规则是：  1. 先把 key 以二进制形式表示，然后从高位到低位依次处理。  2. 二进制的第 
   n
   个 bit 就对应了二叉树的第 
   n
   层  3. 如果该位是 
   1
   ，进入左子树，是 
   0
   则进入右子树（这只是人为约定，反过来处理也可以）  4. 全部数位都处理完后，这个 key 就对应了二叉树上的某个【叶子】          （示意图：“最短唯一前缀”映射到二叉树的叶子） 
       ◇距离算法——异或（XOR） 
  接下来要聊的是 Kad【最精妙之处】——采用 XOR（按位异或操作）算法计算 key 之间的“距离”。  这种搞法使得它具备了类似于“几何距离”的某些特性（下面用 ⊕ 表示 XOR）      
      
        
          
      (A ⊕ B) == (B ⊕ A)
     
          XOR 符合“交换律”，具备对称性。相比之下，Chord 的距离算法不对称
        
        
          
      (A ⊕ A) == 0
     
          反身性，自身距离为零
        
        
          
      (A ⊕ B) &gt; 0
     
          【不同】的两个 key 之间的距离必大于零
        
        
          
      (A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)
     
          三角不等式
        
      
    
       ◇路由机制 
  
   二叉树的拆分
    对每一个节点，都可以【按照自己的视角】对整个二叉树进行拆分。  拆分的规则是：先从根节点开始，把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推，直到最后只剩下自己。  Kad 默认的散列值空间是 
   m = 160
   （散列值有 
   160 bits
   ），因此拆分出来的子树【最多】有 
   160
   个（考虑到实际的节点数【远远小于】 
   2
   
    160
   
   ，子树的个数会明显小于 
   160
   ）。  对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的【任何一个】节点（考虑到篇幅，具体的数学证明就不贴出来了）          （示意图：二叉树的拆分。 
    注：图中的“第三”与“第四”应对调。非常感谢热心读者在评论区指正！
    ） 
  
   K-桶（K-bucket）
    前面说了，每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（请始终牢记：分布式系统的节点是动态变化滴），光知道【一个】显然是不够滴，需要知道【多个】才比较保险。  所以 Kad 论文中给出了一个“K-桶（K-bucket）”的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 
   K
   个节点。这里所说的 
   K
   值是一个【系统级】的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 
   8
   ）。  这个“K-桶”其实就是【路由表】。对于某个节点而言，如果【以它自己为视角】拆分了 
   n
   个子树，那么它就需要维护 
   n
   个路由表，并且每个路由表的【上限】是 
   K
   。  说 K 只是一个【上限】，是因为有两种情况使得 K 桶的尺寸会小于 K。  1. 距离越近的子树就越小。如果整个子树【可能存在的】节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。  2. 有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。          （示意图：K = 2 的路由表） 
         （示意图：路由过程） 
  
   K-桶（K-bucket）的刷新机制
    刷新机制大致有如下几种：  1. 主动收集节点  任何节点都可以主动发起“查询节点”的请求（对应于协议类型 FIND_NODE），从而刷新 K 桶中的节点信息（下面聊“节点的加入”时，会提及这种）  2. 被动收集节点  如果收到其它节点发来的请求（协议类型 FIND_NODE 或 FIND_VALUE），会把对方的 ID 加入自己的某个 K 桶中。  3. 探测失效节点  Kad 还是支持一种探测机制（协议类型 PING），可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点，然后把下线的节点从路由表中干掉。   
   “并发请求”与“α 参数”
    “K桶”的这个设计思路【天生支持并发】。因为【同一个】“K桶”中的每个节点都是平等的，没有哪个更特殊；而且对【同一个】“K桶”中的节点发起请求，互相之间没有影响（无耦合）。  所以 Kad 协议还引入了一个“α参数/α因子”，默认设置为 
   3
   ，使用 Kad 的软件可以在具体使用场景中调整这个“α因子”。  当需要路由到某个“子树”，会从该子树对应的“K桶”中挑选【α个节点】，然后对这几个节点【同时】发出请求。  这么做有啥好处捏？俺在本文末尾聊“性能”和“安全性”时会具体介绍。        ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 向 B 发起一个查询请求（协议类型 FIND_NODE），请求的 ID 是自己（通俗地说，就是查询自己）  4  B 收到该请求之后，（如前面所说）会先把 A 的 ID 加入自己的某个 K 桶中。  然后，根据 FIND_NODE 协议的约定，B 会找到【K个】最接近 A 的节点，并返回给 A。  （B 怎么知道哪些节点接近 A 捏？这时候，【用 XOR 表示距离】的算法就发挥作用啦）  5  A 收到这 K 个节点的 ID 之后，（仅仅根据这批 ID 的值）就可以开始初始化自己的 K 桶。  6  然后 A 会继续向刚刚拿到的这批节点发送查询请求（协议类型 FIND_NODE），如此往复（递归），直至 A 建立了足够详细的路由表。        ◇节点的退出 
  与 Chord 不同，Kad 对于节点退出没有额外的要求（没有“主动退出”的说法）。  所以，Kad 的节点想离开 DHT 网络【不】需要任何操作（套用徐志摩的名言：  悄悄的我走了，正如我悄悄的来  ）        ◇引申阅读 
  Kad 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Kademlia——A Peer-to-peer Information System Based on the XOR Metric  》         ★为啥 Kad 成为 DHT 的主流？ 
  Kad 成为 DHT 的主流实现方式，这已经是很明显的事实。问题在于：为啥会是它？  这是一个比较发散的问题，以下是俺个人观点，供参考。        ◇简单性 
  在“简单性”方面，Kad 和 Chord 都属于很简单的。所以俺要拿一个【反面教程】作为对比。  下面俺来说说 CAN（Content Addressable Network）——它是最早出现的四个 DHT 协议之一（2001年），在学术界也算很有名气。  介绍 CAN 的资料，通常会在开篇提到：CAN 的拓扑结构是基于【多维笛卡尔环面】。俺相信很多程序员看到这个词汇，心里会咯噔一下，脑袋会大一圈。  和 CAN 的【多维环面】比起来，Kad 基于【二叉树】的拓扑结构，就显得异常简单、非常亲切。假如要让程序员在 “二叉树” 和 “多维笛卡尔环面” 二选一，都不用调查问卷，俺就敢打保票——超过 99% 的程序员会选择“二叉树”。  Kad 除了拓扑结构很简单，它的距离算法也很简单——只不过是节点 ID 的异或运算（XOR）。   （稍微跑题一下）  有很多充满学院派气息的系统设计，最终成为空中楼阁，就是因为：这些系统的【设计太复杂】了。当程序员对设计望而生畏，更有可能的情况是：要么没人愿意动手写，要么是有人动手写了，但是迟迟做不出来。        ◇灵活性 
  以 Kad 和 Chord 的路由表来作对比。  Kad 的“K-bucket”是可以根据使用场景来调整 K 值，而且对 K 值的调整完全不影响代码实现。这就是所谓的“适应需求的灵活性”（有时也称之为“设计的弹性”）。  相比之下，Chord 的“Finger Table”就没有这种灵活性。        ◇性能 
  Kad 的路由算法天生就支持【并发】（参见前面介绍的“α 参数”）。  而很多 DHT 协议（包括 Chord）没有这种优势。  由于公网上的线路具有很大的不确定性（极不稳定），哪怕是同样两个节点，之间的传输速率也可能时快时慢。由于 Kad 路由请求支持并发，发出请求的节点总是可以获得最快的那个 peer 的响应。        ◇安全性 
  考虑到本文只介绍了 Chord 和 Kad，还是拿它俩做对比。  假设某个攻击者想要搞 Chord 网络的某个节点（假设叫 A），他/她可以先获得此 节点A 的 ID（这并不难）。知道 节点A 的 ID 后，攻击者就可以运行若干个受控的 Chord 节点（恶意节点），并且精心设置这批恶意节点的 ID；当这批恶意节点加入 Chord 网络后，就可以顺利被添加到 节点A 的路由表中（具体的原理，参见前面对“Finger Table”的介绍）。一旦 节点A 的路由表加入【足够多】的恶意节点，那么 节点A 的路由就有【足够大】的概率会经过这批恶意节点。攻击者作为这批恶意节点的控制人，就可以对 节点A 做很多手脚。   从理论上讲，类似的手法也可以用来针对 Kad。但是攻击难度会显著变大。原因如下：  1  Kad 协议缺省约定——在线时间越长的节点越可能被加入“K桶”。所以攻击者哪怕构造了一批恶意节点，这些恶意节点要想被正常节点加入自己的“K桶”，难度也很大。  2  就算某个恶意节点（比如叫 X）被正常节点（比如叫 A）加入“K-桶”。由于一个“K-桶”只对应【一个子树】。所以，只有当 节点A 在针对某个【特定子树】进行路由的时候，才【有可能】会碰上这个恶意节点。  （唠叨一下：Kad 的路由算法中，对每个子树都维护一个“K-桶”作为路由表）  3  即便正好对这个子树路由，也【不一定】会碰上恶意节点——碰上的【概率】取决于：“K 的大小” 以及 “从桶中选取节点的策略”。  4  前面提到：Kad 协议支持【并发查询】——每次都会从同一个“K-桶”中取出【α个】节点，发出查询请求（参数 α 默认设为 3,可以调大）  所以，这【α 个节点】中，如果只有一个是恶意的，这个恶意节点也很难捣乱；除非这【α 个节点】全部都是恶意的，而这个概率又很小。   （注：俺并【没有】说 Kad 是最安全的。这段介绍只能让你体会一下“K-桶”的设计思路——除了增加性能，还顺便增加了攻击者的难度）        ◇小结 
  刚才聊的这几个方面，对每一个方面，Kad 未必能排第一，但至少它都能排进前几名。  几个方面综合起来，它就成为最有竞争力和活力的 DHT 技术方案。         ★结尾 
  刚才聊到了“安全性”，本来还想再写一个章节，谈谈“针对 DHT 网络的攻击手法”。不过捏，本文已经写了很长，为了照顾某些患有“阅读障碍症”的读者，就先到此为止吧。今后另外找时间谈“攻击 DHT”这个话题。  由于本文的某些内容，俺也是现学现卖。如有错漏之处，还望懂行的同学不吝赐教 :)    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲文件完整性校验——关于散列值和数字签名    聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？    “如何翻墙”系列：简单扫盲 I2P 的使用    “对抗专制、捍卫自由”的 N 种技术力量    聊聊“单点故障”——关于“德国空难”和“李光耀”的随想      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例" />
    <meta property="twitter:title" content="聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17499)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2017%2F09%2FIntroduction-DHT-Kademlia-Chord.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&text=聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&title=聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&title=聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例&body=

      聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例  
  
    
      
    
  
  
     ★引子——为啥要聊这个话题？ 
  这是一篇比较深入地谈技术的博文（而且还牵涉到一点算法）。俺很久没有写这种类型的博文了。  今天发这篇，主要是因为如下几点：  1  在“对抗 GFW、对抗政府审查”的过程中，【彻底无中心】的分布式系统是非常有用滴！  （关于这点，请参见前几年的博文：《  “对抗专制、捍卫自由”的 N 种技术力量  》）  2  DHT 是这类分布式系统的【关键基础设施】，俺希望追求自由的网民能多了解这方面的知识  3  俺也希望有更多程序员能参与这方面的【开源社区】。  在对抗政府审查的时候，商业公司是靠不住滴；只能指望开源社区。  4  虽然 GFW 已经在封杀 BT sync／Resilio Sync；但是，启用了 DHT 功能的 BTsync（必须是老版本），在墙内依然是【免翻墙】可用，让俺很受鼓舞 :)  （感兴趣的同学可以参见上个月的博文：《  聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？  》）  
       
        ★预备知识 
  （如果你自认为是一个熟练的程序员，请直接略过“预备知识”这个章节，看下一章节）        ◇什么是“散列/哈希（hash）”？ 
  （注：在本文中，凡是提及“散列”或“哈希”或“hash”，均表示相同含义）  关于 hash 的概念，俺曾经写过一篇相关的扫盲教程《  扫盲文件完整性校验——关于散列值和数字签名  》，不了解此概念的同学，可以先看看。  老实说，如果你还没有搞明白 hash 的概念，就不要浪费时间看本文的后续部分了。        ◇什么是“散列表/哈希表（hash table）”？ 
  “散列表/哈希表”是用来存储“键值对”的一种容器。“键值对”洋文称之为“key/value pairs”，简称“K/V”。有了“散列表”，你可以很方便快速地通过 key 来获得 value。  举个例子：  手机通讯簿可以通俗理解成一个“散列表”。里面的每一条记录都包含“姓名”和“电话号码”。“姓名”相当于“键值对”中的 key，电话号码相当于 value。你可以通过姓名方便地查找出电话号码。        ◇如何实现散列表？ 
  （考虑到本文的完整性，【简单介绍】一下散列表的实现）  在散列表这种数据结构中，会包含 N 个 bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是【固定不变】的。于是可以对每个桶进行编号，从 0 到 N-1。  “桶”是用来存储“键值对”的，你可以把它通俗理解成一个动态数组，里面可以存放【多个】“键值对”。  下面这张图是从维基百科上剽窃来的。它展示了散列表的【查找】原理。当使用某个 key 进行查找，会先用某个散列函数计算这个 key 的散列值。得到散列值通常是一个整数，然后用散列值对 N（桶数）进行“取模”运算（除法求余数），就可以算出对应的桶编号。  （注：取模运算是最常用的做法，但不是唯一的做法）          （使用散列表存储电话簿的示意图，剽窃自维基百科） 
       ◇什么是“散列表”的【碰撞/冲突】（Collision）？ 
  在俺那篇  扫盲教程  中，已经介绍了“散列碰撞”（也称为“散列冲突”）的概念。  当两个不同的 key 进行哈希计算却得到【相同的散列值】，就是所谓的【散列函数碰撞】。一旦出现这种情况，这两个 key 对应的两个键值对就会被存储在【同一个】桶（bucket）里面。  另一种情况是：虽然计算出来的散列值【不同】，但经过“取模运算”之后却得到【相同】的桶编号。这时候也会出现：两个键值对存储在一个桶里面。          （出现“散列碰撞”的示意图，剽窃自维基百科） 
  如果某个哈希表在存储数据时【完全没有碰撞】，那么每个桶里面都只有 0个 或 1个 键值对。查找起来就非常快。  反之，如果某个哈希表在存储数据时出现【严重碰撞】，就会导致某些桶里面存储了一大坨的键值对。将来查找 key 的时候，如果定位到的是这种“大桶”，就需要在这个桶里面逐一比对 key 是否相同——查找效率就会变得很差。        ◇“散列表”有哪些优点？ 
  主要优点是：（当数据量很大时）散列表可以提供快速且稳定的查找速度。  当然，这里有个前提就是：散列函数要【足够好】——  1、计算出的散列值要足够离散（从而使得不同的键值对可以比较【均匀】地分配到各个桶里面）  2、要尽可能降低碰撞（碰撞会降低性能）  另一个前提是：桶的数量也有一定的讲究——  1、桶数要足够大。否则的话，【必定会】导致某些桶里面的键值对太多（这点很明显，没想明白的同学，可参见“抽屉原理”）  2、（如果用常见的“取模”映射到桶）桶的总数最好是【质数/素数】（这个不解释，爱思考的同学自己想一下）         ★分布式散列表（DHT）概述 
       ◇什么是 DHT？ 
  “分布式散列表”也称为“分布式哈希表”，洋文是“distributed hash table”，简称 DHT。  “分布式散列表”在概念上类似与传统的“散列表”，差异在于——  “传统的散列表”主要是用于单机上的某个软件中；  “分布式散列表”主要是用于分布式系统（此时，分布式系统的节点可以通俗理解为散列表中的 bucket）   “分布式散列表”主要是用来存储大量的（甚至是海量的）数据。在实际使用场景中，直接对所存储的“每一个业务数据”计算散列值，然后用散列值作为 key，业务数据本身是 value。          （分布式散列表的示意图，此图剽窃自维基百科） 
  （为了偷懒，本文以下部分均使用 DHT 来表示“分布式散列表”）        ◇为啥会出现 DHT？ 
  在 P2P 文件共享的发展史上，出现过3种不同的技术路线（三代）。   
   第1代
    采用【中央服务器】的模式——每个节点都需要先连接到中央服务器，然后才能查找到自己想要的文件在哪里。  这种技术的最大缺点是——中央服务器成为整个 P2P 网络的【单点故障】。  （关于“单点故障”这个概念，可以看另一篇介绍：《  聊聊“单点故障”——关于“德国空难”和“李光耀”的随想  》）  这类 p2p 的典型代表是  Napster  。   
   第2代
    采用【广播】的模式——要找文件的时候，每个节点都向自己相连的【所有节点】进行询问；被询问的节点如果不知道这个文件在哪里，就再次进行“广播”......如此往复，直至找到所需文件。  这种技术的最大缺点是——会引发“广播风暴”并严重占用网络带宽，也会严重消耗节点的系统资源。即使在协议层面通过设置 TTL（time to live），限制查询过程只递归 N 轮，依然【无法】彻底解决此弊端。  因为这种手法太吓人，获得“Query Flooding”的绰号。下面放一张示意图。          （示意图：第2代 P2P 的 Query Flooding） 
  这类 p2p 的典型代表是  Gnutella  的早期版本。   
   第3代
    这一代采用的技术就是今天要聊的 DHT。  通过 DHT 这个玩意儿，不但避免了第一代技术的【单点故障】，也避免了第二代技术的【广播风暴】。        ◇DHT 有哪些应用场景？ 
  DHT 最早用于 P2P 文件共享和文件下载（比如：BT、电驴、电骡），之后也被广泛用于某些分布式系统中，比如：      
分布式文件系统  分布式缓存  暗网（比如：  I2P  、  Freenet  ）  无中心的聊天工具/IM（比如：  TOX  ）  无中心的微博客/microblogging（比如：  Twister  ）  无中心的社交网络/SNS    
 正是因为【无中心】的分布式系统普遍使用 DHT，所以本文开头称之为：分布式系统的【基础设施】。         ★分布式散列表（DHT）的难点 
       ◇“无中心”导致的难点 
  前面提到了 DHT 的诞生，是为了解决前面两代 P2P 技术的缺陷。其中一个缺陷是“中央服务器”导致的【单点故障】。  因此 DHT 就【不能】再依靠中央服务器。而没有了中央服务器，就需要提供一系列机制来实现节点之间的通讯。        ◇“海量数据”导致的难点 
  DHT 的很多使用场景是为了承载海量数据（PB 或更高级别）。  由于数据是海量的，每个节点只能存储（整个系统的）一小部分数据。需要把数据【均匀分摊】到每个节点。        ◇“节点动态变化”导致的难点 
  很多 DHT 的使用场景是在公网（互联网）上，参与 DHT 的节点（主机）会出现【频繁变化】——每时每刻都有新的节点上线，也会有旧的节点下线。在这种情况下，需要确保数据依然是【均匀分摊】到所有节点。   （俺特别强调一下：传统的散列表在这种情况下的困难）  前面提到：传统散列表所含的【桶数】是固定不变滴。为啥捏？  因为传统散列表在针对 key 计算出散列值之后，需要用“散列值”和“桶数”进行某种运算（比如：取模运算），从而得到桶的编号。  如果桶的数量出现变化，就会影响到上述“取模运算”的结果，然后导致数据错乱。        ◇“高效查询”导致的难点 
  对于节点数很多的分布式系统，如何快速定位节点，同时又不消耗太多网络资源，这也是一个挑战。  比如前面提到第二代 P2P 技术，在查找所需文件时会导致【广播风暴】。这就成为其致命弱点。  DHT 必须有更高效的查找机制。而且这种查找机制要能适应“节点动态变化”这个特点。         ★分布式散列表（DHT）如何解决上述难点？ 
  DHT 采用如下一些机制来解决上述问题，并满足分布式系统比较苛刻的需求。        ◇“散列算法”的选择 
  前面提到：DHT 通常是直接拿业务数据的散列值作为 key，业务数据本身作为 value。  考虑到 DHT 需要承载的数据量通常比较大，散列函数产生的“散列值范围”（keyspace）要足够大，以防止太多的碰撞。更进一步，如果 keyspace【大到一定程度】，使得“随机碰撞”的概率小到忽略不计，就有助于简化 DHT 的系统设计。  通常的 DHT 都会采用大于等于 128 比特的散列值（2  128  比 “地球上所有电子文档总数” 还要大【很多数量级】）。        ◇同构的“node ID”与“data key” 
  DHT 属于分布式系统的一种。既然是分布式系统，意味着存在【多个】节点（电脑主机）。在设计分布式系统的时候，一种常见的做法是：给每一个节点（node）分配【唯一的】ID。有了这个节点 ID（node ID），在系统设计上的好处是——对分布式系统所依赖的物理网络的【解耦】。  很多 DHT 的设计会让“node ID”采用跟“data key”【同构】的散列值。这么搞的好处是：  1、当散列值空间足够大的时候，随机碰撞忽略不计，因此也就确保了 node ID 的唯一性  2、可以简化系统设计——比如简化路由算法（下面会提及）        ◇“拓扑结构”的设计 
  作为分布式系统，DHT 必然要定义某种拓扑结构；有了拓扑结构，自然就要设计某种“路由算法”。  如果某个 DHT 采用前面所说的——“node ID”与“data key”【同构】——那么很自然的就会引入“  Key-based routing  ”。  请注意，这【不是】某个具体的路由算法，而只是某种【风格】。采用这种风格来设计路由机制，好处是： 
   key 本身已经提供了足够多的路由信息
   。   当某个分布式系统具有自己的拓扑结构，它本身成为一个“覆盖网络”（洋文叫“Overlay Network”）。所谓的“覆盖网络”，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的“覆盖网络”，它们的数据通讯是依赖下层的互联网来实现的。  前面提到的“node ID”，其【解耦】的作用就体现在——分布式系统在设计拓扑结构和路由算法时，只需要考虑 node ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。        ◇“路由算法”的权衡 
  由于 DHT 中的节点数可能非常多（比如：几十万、几百万），而且这些节点是动态变化的。因此就【不可能】让每一个节点都记录所有其它节点的信息。实际情况是：每个节点通常只知道少数一些节点的信息。  这时候就需要设计某种路由算法，尽可能利用已知的节点来转发数据。“路由算法”这玩意儿很重要，直接决定了 DHT 的速度和资源消耗。  在确定了路由算法之后，还需要做一个两难的权衡——“路由表的大小”。  路由表越大，可以实现越短（跳数越少）的路由；缺点是：（由于节点动态变化）路由表的维护成本也就越高。  路由表数越小，其维护成本越小；缺点是：路由就会变长（跳数变多）。        ◇距离算法 
  某些 DHT 系统还会定义一种“距离算法”，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。  请注意：此处所说的“距离”属于【逻辑层面】，对应的是 DHT 自己的拓扑结构；它与地理位置【无关】，也与互联网的拓扑结构【无关】。  写到这里，某些聪明的读者就会明白：为啥前面要强调——“node ID”与“data key”【同构】。当这两者【同构】，就可以使用【同一种“距离算法”】；反之，如果这两者不同构，多半要引入几种不同的“距离算法”。        ◇数据定位 
  有了前面这一大砣东西作为铺垫，现在就可以来谈谈“数据定位”啦。对 DHT 而言，这是最关键的东东。  DHT 与传统的散列表在【功能】上是类似的。说白了，他们最关键的功能只有两个——“保存数据”和“获取数据”。如果用 C 语言来表示的话，函数原型大致如下：      void put(KEY k, VALUE v);  // 保存“键值对”
VALUE get(KEY k);  // 根据“键”获取“值”    
  
   保存数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点得到了新加入的数据（K/V），它会先计算自己与新数据的 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么这个数据就保持在自己这里。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。   
   获取数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点接收到查询数据的请求（key），它会先计算自己与 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么就在自己这里找有没有 key 对应的 value。有的话就返回 value，没有的话就报错。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。         ★  Chord 协议  简介 
       ◇概述 
  Chord 诞生于2001年。第一批 DHT 协议都是在那年涌现的，另外几个是：  CAN  、  Tapestry  、  Pastry  。  俺之所以选取 Chord 来介绍，主要是因为 Chord 的原理比较简单（概念好理解），而且相关的资料也很多。   （请允许俺稍微跑题，聊一下 IT 八卦）  Chord 是 MIT 的几个技术牛人一起搞出来的，这几个牛人中包括世界级的黑客：罗伯特·莫里斯（  Robert Morris  ）。  此人以“  莫里斯蠕虫  ”而享誉信息安全界。这是 IT 史上【第一个】蠕虫（注：蠕虫可以利用网络【实时】传播），这个蠕虫对当时（1988年）的互联网造成毁灭性打击（一天之内，约十分之一的互联网主机中招并下线）。  他不仅是编程高手兼顶级黑客，而且是创业者兼投资人。他与同样大名鼎鼎的保罗·格雷汉姆（  Paul Graham  ）以及  Trevor Blackwell  ，3人在1995年共同创立了  Viaweb  ，并在1998年把公司以5千万美元卖给 Yahoo。然后他们拿这笔钱创办了  Y Combinator  （如今世界闻名的风投机构）。        ◇拓扑结构——环形 
  要聊 Chord 的拓扑，必然要提到“  Consistent Hashing  ”（译作：“一致散列”或“稳定散列”）。搞明白“一致散列”也就知道 Chord 的拓扑设计了。  提出“一致散列”这个概念主要是为了解决“节点动态变化”的难点（前面有提及）。为了解决这个难点，“一致散列”把散列值空间（keyspace）构成一个【环】。对于 
   m
   比特的散列值，其范围是 
   [0, 2
   
    m
   
   -1]
   。你把这个区间头尾相接就变成一个环，其周长是 
   2
   
    m
   
   。然后对这个环规定了一个移动方向（比如顺时针）。  如果 node ID 和 data key 是同构的，那么这两者都可以映射到这个环上（对应于环上的某点）。          （示意图：环形的 keyspace） 
  假设有某个“节点A”，距离它最近的是“节点B”（以顺时针方向衡量距离）。那么称 B 是 A 的【继任】（successor），A 是 B 的【前任】（predecessor）。   数据隶属于【距离最小】的节点。以 
   m = 6
   的环形空间为例：  数据区间 
   [5,8]
   隶属于“节点8”  数据区间 
   [9,15]
   隶属于“节点15”  ......  数据区间 
   [59,4]
   隶属于“节点4”（注：“6比特”的环形空间， 
   63
   之后是 
   0
   ）          （示意图：“数据”与“节点”对应关系） 
  以上就是“一致性散列”的拓扑结构，同时也是 Chord 的拓扑结构。        ◇路由机制 
  接下来简单说一下路由的玩法。   
   基本路由（简单遍历）
    当收到请求（key），先看 key 是否在自己这里。如果在自己这里，就直接返回信息；否则就把 key 转发给自己的继任者。以此类推。  这种玩法的时间复杂度是： 
   O(N)
   。对于一个节点数很多的 DHT 网络，这种做法显然【非常低效】。   
   高级路由（Finger Table）
    由于“基本路由”非常低效，自然就引入更高级的玩法——基于“Finger Table”的路由。  “Finger Table”是一个列表，最多包含 
   m
   项（ 
   m
   就是散列值的比特数），每一项都是节点 ID。  假设当前节点的 ID 是 
   n
   ，那么表中第 
   i
   项的值是： 
   successor( (n + 2
   
    i
   
   ) mod 2
   
    m
   
   )
    当收到请求（key），就到“Finger Table”中找到【最大的且不超过 key】的那一项，然后把 key 转发给这一项对应的节点。  有了“Finger Table”之后，时间复杂度可以优化为： 
   O(log N)
   。          （示意图：Finger Table） 
       ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 通过跟 B 进行查询，找到自己这个 ID 在环上的接头人。也就是——找到自己这个 ID 对应的“继任”（假设叫 C）与“前任”（假设叫 D）  4  接下来，A 需要跟 C 和 D 进行一系列互动，使得自己成为 C 的前任，以及 D 的继任。  这个互动过程，大致类似于在双向链表当中插入元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【正常】退出 
  如果某个节点想要主动离开这个 DHT 网络，按照约定需要作一些善后的处理工作。比如说，通知自己的前任去更新其继任者......  这些善后处理，大致类似于：在双向链表中删除元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【异常】退出 
  作为一个分布式系统，任何节点都有可能意外下线（也就是说，来不及进行善后就挂掉了）  假设 节点A 的继任者【异常】下线了，那么 节点A 就抓瞎了。咋办捏？  为了保险起见，Chord 引入了一个“继任者候选列表”的概念。每个节点都用这个列表来包含：距离自己最近的 N 个节点的信息，顺序是【由近到远】。一旦自己的继任者下线了，就在列表中找到一个【距离最近且在线】的节点，作为新的继任者。然后 节点A 更新该列表，确保依然有 N 个候选。更新完“继任者候选列表”后，节点A 也会通知自己的前任，那么 A 的前任也就能更新自己的“继任者候选列表”。        ◇引申阅读 
  Chord 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Chord——A Scalable Peer-to-peer Lookup Service for Internet Applications  》         ★  Kademlia（Kad）协议  简介 
  （注：由于“Kademlia”这个词太长，为了打字省力，以下都采用“Kad”这个简写）        ◇概述 
  Kad 诞生于2002年，由纽约大学的两个牛人（Petar Maymounkov &amp; David Mazières）共同设计（他俩的论文，在本章节末尾附有链接）。  Kad 的原理比 Chord 稍微晦涩一些（涉及一点点数据结构的知识，如果你是程序猿，不用怕）。俺之所以选 Kad 来介绍，是因为——实际应用的 DHT 大部分都采用 Kad 及其变种。比如几种知名的 P2P 下载（BT、eDonkey/电驴、eMule/电骡）的 DHT 都是基于 Kad；知名的 I2P 暗网也依赖 Kad（说到 I2P，俺博客写过一篇扫盲教程，在“  这里  ”）。        ◇拓扑结构——二叉树 
  
   散列值的预处理
    Kad 也采用了“node ID 与 data key 同构”的设计思路。然后 Kad 采用某种算法把 key 映射到一个二叉树，每一个 key 都是这个二叉树的【叶子】。  在映射之前，先做一下预处理。  1. 先把 key 以二进制形式表示。  2. 把每一个 key 缩短为它的【最短唯一前缀】。   
   为啥要搞“最短唯一前缀”？
    Kad 使用 
   160比特
   的散列算法（比如 SHA1），完整的 key 用二进制表示有 
   160
   个数位（bit）。  首先，实际运行的 Kad 网络，即使有几百万个节点，相比 keyspace（2  160  ）也只是很小很小很小的一个子集。  其次，由于散列函数的特点，key 的分布是【高度随机】的。因此也是【高度离散】的——任何两个 key 都【不会】非常临近。  所以，使用“最短唯一前缀”来处理 key 的二进制形式，得到的结果就会很短（比特数远远小于 160）。   
   散列值的映射
    完成上述的预处理后，接下来的映射规则是：  1. 先把 key 以二进制形式表示，然后从高位到低位依次处理。  2. 二进制的第 
   n
   个 bit 就对应了二叉树的第 
   n
   层  3. 如果该位是 
   1
   ，进入左子树，是 
   0
   则进入右子树（这只是人为约定，反过来处理也可以）  4. 全部数位都处理完后，这个 key 就对应了二叉树上的某个【叶子】          （示意图：“最短唯一前缀”映射到二叉树的叶子） 
       ◇距离算法——异或（XOR） 
  接下来要聊的是 Kad【最精妙之处】——采用 XOR（按位异或操作）算法计算 key 之间的“距离”。  这种搞法使得它具备了类似于“几何距离”的某些特性（下面用 ⊕ 表示 XOR）      
      
        
          
      (A ⊕ B) == (B ⊕ A)
     
          XOR 符合“交换律”，具备对称性。相比之下，Chord 的距离算法不对称
        
        
          
      (A ⊕ A) == 0
     
          反身性，自身距离为零
        
        
          
      (A ⊕ B) &gt; 0
     
          【不同】的两个 key 之间的距离必大于零
        
        
          
      (A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)
     
          三角不等式
        
      
    
       ◇路由机制 
  
   二叉树的拆分
    对每一个节点，都可以【按照自己的视角】对整个二叉树进行拆分。  拆分的规则是：先从根节点开始，把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推，直到最后只剩下自己。  Kad 默认的散列值空间是 
   m = 160
   （散列值有 
   160 bits
   ），因此拆分出来的子树【最多】有 
   160
   个（考虑到实际的节点数【远远小于】 
   2
   
    160
   
   ，子树的个数会明显小于 
   160
   ）。  对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的【任何一个】节点（考虑到篇幅，具体的数学证明就不贴出来了）          （示意图：二叉树的拆分。 
    注：图中的“第三”与“第四”应对调。非常感谢热心读者在评论区指正！
    ） 
  
   K-桶（K-bucket）
    前面说了，每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（请始终牢记：分布式系统的节点是动态变化滴），光知道【一个】显然是不够滴，需要知道【多个】才比较保险。  所以 Kad 论文中给出了一个“K-桶（K-bucket）”的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 
   K
   个节点。这里所说的 
   K
   值是一个【系统级】的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 
   8
   ）。  这个“K-桶”其实就是【路由表】。对于某个节点而言，如果【以它自己为视角】拆分了 
   n
   个子树，那么它就需要维护 
   n
   个路由表，并且每个路由表的【上限】是 
   K
   。  说 K 只是一个【上限】，是因为有两种情况使得 K 桶的尺寸会小于 K。  1. 距离越近的子树就越小。如果整个子树【可能存在的】节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。  2. 有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。          （示意图：K = 2 的路由表） 
         （示意图：路由过程） 
  
   K-桶（K-bucket）的刷新机制
    刷新机制大致有如下几种：  1. 主动收集节点  任何节点都可以主动发起“查询节点”的请求（对应于协议类型 FIND_NODE），从而刷新 K 桶中的节点信息（下面聊“节点的加入”时，会提及这种）  2. 被动收集节点  如果收到其它节点发来的请求（协议类型 FIND_NODE 或 FIND_VALUE），会把对方的 ID 加入自己的某个 K 桶中。  3. 探测失效节点  Kad 还是支持一种探测机制（协议类型 PING），可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点，然后把下线的节点从路由表中干掉。   
   “并发请求”与“α 参数”
    “K桶”的这个设计思路【天生支持并发】。因为【同一个】“K桶”中的每个节点都是平等的，没有哪个更特殊；而且对【同一个】“K桶”中的节点发起请求，互相之间没有影响（无耦合）。  所以 Kad 协议还引入了一个“α参数/α因子”，默认设置为 
   3
   ，使用 Kad 的软件可以在具体使用场景中调整这个“α因子”。  当需要路由到某个“子树”，会从该子树对应的“K桶”中挑选【α个节点】，然后对这几个节点【同时】发出请求。  这么做有啥好处捏？俺在本文末尾聊“性能”和“安全性”时会具体介绍。        ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 向 B 发起一个查询请求（协议类型 FIND_NODE），请求的 ID 是自己（通俗地说，就是查询自己）  4  B 收到该请求之后，（如前面所说）会先把 A 的 ID 加入自己的某个 K 桶中。  然后，根据 FIND_NODE 协议的约定，B 会找到【K个】最接近 A 的节点，并返回给 A。  （B 怎么知道哪些节点接近 A 捏？这时候，【用 XOR 表示距离】的算法就发挥作用啦）  5  A 收到这 K 个节点的 ID 之后，（仅仅根据这批 ID 的值）就可以开始初始化自己的 K 桶。  6  然后 A 会继续向刚刚拿到的这批节点发送查询请求（协议类型 FIND_NODE），如此往复（递归），直至 A 建立了足够详细的路由表。        ◇节点的退出 
  与 Chord 不同，Kad 对于节点退出没有额外的要求（没有“主动退出”的说法）。  所以，Kad 的节点想离开 DHT 网络【不】需要任何操作（套用徐志摩的名言：  悄悄的我走了，正如我悄悄的来  ）        ◇引申阅读 
  Kad 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Kademlia——A Peer-to-peer Information System Based on the XOR Metric  》         ★为啥 Kad 成为 DHT 的主流？ 
  Kad 成为 DHT 的主流实现方式，这已经是很明显的事实。问题在于：为啥会是它？  这是一个比较发散的问题，以下是俺个人观点，供参考。        ◇简单性 
  在“简单性”方面，Kad 和 Chord 都属于很简单的。所以俺要拿一个【反面教程】作为对比。  下面俺来说说 CAN（Content Addressable Network）——它是最早出现的四个 DHT 协议之一（2001年），在学术界也算很有名气。  介绍 CAN 的资料，通常会在开篇提到：CAN 的拓扑结构是基于【多维笛卡尔环面】。俺相信很多程序员看到这个词汇，心里会咯噔一下，脑袋会大一圈。  和 CAN 的【多维环面】比起来，Kad 基于【二叉树】的拓扑结构，就显得异常简单、非常亲切。假如要让程序员在 “二叉树” 和 “多维笛卡尔环面” 二选一，都不用调查问卷，俺就敢打保票——超过 99% 的程序员会选择“二叉树”。  Kad 除了拓扑结构很简单，它的距离算法也很简单——只不过是节点 ID 的异或运算（XOR）。   （稍微跑题一下）  有很多充满学院派气息的系统设计，最终成为空中楼阁，就是因为：这些系统的【设计太复杂】了。当程序员对设计望而生畏，更有可能的情况是：要么没人愿意动手写，要么是有人动手写了，但是迟迟做不出来。        ◇灵活性 
  以 Kad 和 Chord 的路由表来作对比。  Kad 的“K-bucket”是可以根据使用场景来调整 K 值，而且对 K 值的调整完全不影响代码实现。这就是所谓的“适应需求的灵活性”（有时也称之为“设计的弹性”）。  相比之下，Chord 的“Finger Table”就没有这种灵活性。        ◇性能 
  Kad 的路由算法天生就支持【并发】（参见前面介绍的“α 参数”）。  而很多 DHT 协议（包括 Chord）没有这种优势。  由于公网上的线路具有很大的不确定性（极不稳定），哪怕是同样两个节点，之间的传输速率也可能时快时慢。由于 Kad 路由请求支持并发，发出请求的节点总是可以获得最快的那个 peer 的响应。        ◇安全性 
  考虑到本文只介绍了 Chord 和 Kad，还是拿它俩做对比。  假设某个攻击者想要搞 Chord 网络的某个节点（假设叫 A），他/她可以先获得此 节点A 的 ID（这并不难）。知道 节点A 的 ID 后，攻击者就可以运行若干个受控的 Chord 节点（恶意节点），并且精心设置这批恶意节点的 ID；当这批恶意节点加入 Chord 网络后，就可以顺利被添加到 节点A 的路由表中（具体的原理，参见前面对“Finger Table”的介绍）。一旦 节点A 的路由表加入【足够多】的恶意节点，那么 节点A 的路由就有【足够大】的概率会经过这批恶意节点。攻击者作为这批恶意节点的控制人，就可以对 节点A 做很多手脚。   从理论上讲，类似的手法也可以用来针对 Kad。但是攻击难度会显著变大。原因如下：  1  Kad 协议缺省约定——在线时间越长的节点越可能被加入“K桶”。所以攻击者哪怕构造了一批恶意节点，这些恶意节点要想被正常节点加入自己的“K桶”，难度也很大。  2  就算某个恶意节点（比如叫 X）被正常节点（比如叫 A）加入“K-桶”。由于一个“K-桶”只对应【一个子树】。所以，只有当 节点A 在针对某个【特定子树】进行路由的时候，才【有可能】会碰上这个恶意节点。  （唠叨一下：Kad 的路由算法中，对每个子树都维护一个“K-桶”作为路由表）  3  即便正好对这个子树路由，也【不一定】会碰上恶意节点——碰上的【概率】取决于：“K 的大小” 以及 “从桶中选取节点的策略”。  4  前面提到：Kad 协议支持【并发查询】——每次都会从同一个“K-桶”中取出【α个】节点，发出查询请求（参数 α 默认设为 3,可以调大）  所以，这【α 个节点】中，如果只有一个是恶意的，这个恶意节点也很难捣乱；除非这【α 个节点】全部都是恶意的，而这个概率又很小。   （注：俺并【没有】说 Kad 是最安全的。这段介绍只能让你体会一下“K-桶”的设计思路——除了增加性能，还顺便增加了攻击者的难度）        ◇小结 
  刚才聊的这几个方面，对每一个方面，Kad 未必能排第一，但至少它都能排进前几名。  几个方面综合起来，它就成为最有竞争力和活力的 DHT 技术方案。         ★结尾 
  刚才聊到了“安全性”，本来还想再写一个章节，谈谈“针对 DHT 网络的攻击手法”。不过捏，本文已经写了很长，为了照顾某些患有“阅读障碍症”的读者，就先到此为止吧。今后另外找时间谈“攻击 DHT”这个话题。  由于本文的某些内容，俺也是现学现卖。如有错漏之处，还望懂行的同学不吝赐教 :)    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲文件完整性校验——关于散列值和数字签名    聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？    “如何翻墙”系列：简单扫盲 I2P 的使用    “对抗专制、捍卫自由”的 N 种技术力量    聊聊“单点故障”——关于“德国空难”和“李光耀”的随想      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&title=聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例&caption=

      聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例  
  
    
      
    
  
  
     ★引子——为啥要聊这个话题？ 
  这是一篇比较深入地谈技术的博文（而且还牵涉到一点算法）。俺很久没有写这种类型的博文了。  今天发这篇，主要是因为如下几点：  1  在“对抗 GFW、对抗政府审查”的过程中，【彻底无中心】的分布式系统是非常有用滴！  （关于这点，请参见前几年的博文：《  “对抗专制、捍卫自由”的 N 种技术力量  》）  2  DHT 是这类分布式系统的【关键基础设施】，俺希望追求自由的网民能多了解这方面的知识  3  俺也希望有更多程序员能参与这方面的【开源社区】。  在对抗政府审查的时候，商业公司是靠不住滴；只能指望开源社区。  4  虽然 GFW 已经在封杀 BT sync／Resilio Sync；但是，启用了 DHT 功能的 BTsync（必须是老版本），在墙内依然是【免翻墙】可用，让俺很受鼓舞 :)  （感兴趣的同学可以参见上个月的博文：《  聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？  》）  
       
        ★预备知识 
  （如果你自认为是一个熟练的程序员，请直接略过“预备知识”这个章节，看下一章节）        ◇什么是“散列/哈希（hash）”？ 
  （注：在本文中，凡是提及“散列”或“哈希”或“hash”，均表示相同含义）  关于 hash 的概念，俺曾经写过一篇相关的扫盲教程《  扫盲文件完整性校验——关于散列值和数字签名  》，不了解此概念的同学，可以先看看。  老实说，如果你还没有搞明白 hash 的概念，就不要浪费时间看本文的后续部分了。        ◇什么是“散列表/哈希表（hash table）”？ 
  “散列表/哈希表”是用来存储“键值对”的一种容器。“键值对”洋文称之为“key/value pairs”，简称“K/V”。有了“散列表”，你可以很方便快速地通过 key 来获得 value。  举个例子：  手机通讯簿可以通俗理解成一个“散列表”。里面的每一条记录都包含“姓名”和“电话号码”。“姓名”相当于“键值对”中的 key，电话号码相当于 value。你可以通过姓名方便地查找出电话号码。        ◇如何实现散列表？ 
  （考虑到本文的完整性，【简单介绍】一下散列表的实现）  在散列表这种数据结构中，会包含 N 个 bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是【固定不变】的。于是可以对每个桶进行编号，从 0 到 N-1。  “桶”是用来存储“键值对”的，你可以把它通俗理解成一个动态数组，里面可以存放【多个】“键值对”。  下面这张图是从维基百科上剽窃来的。它展示了散列表的【查找】原理。当使用某个 key 进行查找，会先用某个散列函数计算这个 key 的散列值。得到散列值通常是一个整数，然后用散列值对 N（桶数）进行“取模”运算（除法求余数），就可以算出对应的桶编号。  （注：取模运算是最常用的做法，但不是唯一的做法）          （使用散列表存储电话簿的示意图，剽窃自维基百科） 
       ◇什么是“散列表”的【碰撞/冲突】（Collision）？ 
  在俺那篇  扫盲教程  中，已经介绍了“散列碰撞”（也称为“散列冲突”）的概念。  当两个不同的 key 进行哈希计算却得到【相同的散列值】，就是所谓的【散列函数碰撞】。一旦出现这种情况，这两个 key 对应的两个键值对就会被存储在【同一个】桶（bucket）里面。  另一种情况是：虽然计算出来的散列值【不同】，但经过“取模运算”之后却得到【相同】的桶编号。这时候也会出现：两个键值对存储在一个桶里面。          （出现“散列碰撞”的示意图，剽窃自维基百科） 
  如果某个哈希表在存储数据时【完全没有碰撞】，那么每个桶里面都只有 0个 或 1个 键值对。查找起来就非常快。  反之，如果某个哈希表在存储数据时出现【严重碰撞】，就会导致某些桶里面存储了一大坨的键值对。将来查找 key 的时候，如果定位到的是这种“大桶”，就需要在这个桶里面逐一比对 key 是否相同——查找效率就会变得很差。        ◇“散列表”有哪些优点？ 
  主要优点是：（当数据量很大时）散列表可以提供快速且稳定的查找速度。  当然，这里有个前提就是：散列函数要【足够好】——  1、计算出的散列值要足够离散（从而使得不同的键值对可以比较【均匀】地分配到各个桶里面）  2、要尽可能降低碰撞（碰撞会降低性能）  另一个前提是：桶的数量也有一定的讲究——  1、桶数要足够大。否则的话，【必定会】导致某些桶里面的键值对太多（这点很明显，没想明白的同学，可参见“抽屉原理”）  2、（如果用常见的“取模”映射到桶）桶的总数最好是【质数/素数】（这个不解释，爱思考的同学自己想一下）         ★分布式散列表（DHT）概述 
       ◇什么是 DHT？ 
  “分布式散列表”也称为“分布式哈希表”，洋文是“distributed hash table”，简称 DHT。  “分布式散列表”在概念上类似与传统的“散列表”，差异在于——  “传统的散列表”主要是用于单机上的某个软件中；  “分布式散列表”主要是用于分布式系统（此时，分布式系统的节点可以通俗理解为散列表中的 bucket）   “分布式散列表”主要是用来存储大量的（甚至是海量的）数据。在实际使用场景中，直接对所存储的“每一个业务数据”计算散列值，然后用散列值作为 key，业务数据本身是 value。          （分布式散列表的示意图，此图剽窃自维基百科） 
  （为了偷懒，本文以下部分均使用 DHT 来表示“分布式散列表”）        ◇为啥会出现 DHT？ 
  在 P2P 文件共享的发展史上，出现过3种不同的技术路线（三代）。   
   第1代
    采用【中央服务器】的模式——每个节点都需要先连接到中央服务器，然后才能查找到自己想要的文件在哪里。  这种技术的最大缺点是——中央服务器成为整个 P2P 网络的【单点故障】。  （关于“单点故障”这个概念，可以看另一篇介绍：《  聊聊“单点故障”——关于“德国空难”和“李光耀”的随想  》）  这类 p2p 的典型代表是  Napster  。   
   第2代
    采用【广播】的模式——要找文件的时候，每个节点都向自己相连的【所有节点】进行询问；被询问的节点如果不知道这个文件在哪里，就再次进行“广播”......如此往复，直至找到所需文件。  这种技术的最大缺点是——会引发“广播风暴”并严重占用网络带宽，也会严重消耗节点的系统资源。即使在协议层面通过设置 TTL（time to live），限制查询过程只递归 N 轮，依然【无法】彻底解决此弊端。  因为这种手法太吓人，获得“Query Flooding”的绰号。下面放一张示意图。          （示意图：第2代 P2P 的 Query Flooding） 
  这类 p2p 的典型代表是  Gnutella  的早期版本。   
   第3代
    这一代采用的技术就是今天要聊的 DHT。  通过 DHT 这个玩意儿，不但避免了第一代技术的【单点故障】，也避免了第二代技术的【广播风暴】。        ◇DHT 有哪些应用场景？ 
  DHT 最早用于 P2P 文件共享和文件下载（比如：BT、电驴、电骡），之后也被广泛用于某些分布式系统中，比如：      
分布式文件系统  分布式缓存  暗网（比如：  I2P  、  Freenet  ）  无中心的聊天工具/IM（比如：  TOX  ）  无中心的微博客/microblogging（比如：  Twister  ）  无中心的社交网络/SNS    
 正是因为【无中心】的分布式系统普遍使用 DHT，所以本文开头称之为：分布式系统的【基础设施】。         ★分布式散列表（DHT）的难点 
       ◇“无中心”导致的难点 
  前面提到了 DHT 的诞生，是为了解决前面两代 P2P 技术的缺陷。其中一个缺陷是“中央服务器”导致的【单点故障】。  因此 DHT 就【不能】再依靠中央服务器。而没有了中央服务器，就需要提供一系列机制来实现节点之间的通讯。        ◇“海量数据”导致的难点 
  DHT 的很多使用场景是为了承载海量数据（PB 或更高级别）。  由于数据是海量的，每个节点只能存储（整个系统的）一小部分数据。需要把数据【均匀分摊】到每个节点。        ◇“节点动态变化”导致的难点 
  很多 DHT 的使用场景是在公网（互联网）上，参与 DHT 的节点（主机）会出现【频繁变化】——每时每刻都有新的节点上线，也会有旧的节点下线。在这种情况下，需要确保数据依然是【均匀分摊】到所有节点。   （俺特别强调一下：传统的散列表在这种情况下的困难）  前面提到：传统散列表所含的【桶数】是固定不变滴。为啥捏？  因为传统散列表在针对 key 计算出散列值之后，需要用“散列值”和“桶数”进行某种运算（比如：取模运算），从而得到桶的编号。  如果桶的数量出现变化，就会影响到上述“取模运算”的结果，然后导致数据错乱。        ◇“高效查询”导致的难点 
  对于节点数很多的分布式系统，如何快速定位节点，同时又不消耗太多网络资源，这也是一个挑战。  比如前面提到第二代 P2P 技术，在查找所需文件时会导致【广播风暴】。这就成为其致命弱点。  DHT 必须有更高效的查找机制。而且这种查找机制要能适应“节点动态变化”这个特点。         ★分布式散列表（DHT）如何解决上述难点？ 
  DHT 采用如下一些机制来解决上述问题，并满足分布式系统比较苛刻的需求。        ◇“散列算法”的选择 
  前面提到：DHT 通常是直接拿业务数据的散列值作为 key，业务数据本身作为 value。  考虑到 DHT 需要承载的数据量通常比较大，散列函数产生的“散列值范围”（keyspace）要足够大，以防止太多的碰撞。更进一步，如果 keyspace【大到一定程度】，使得“随机碰撞”的概率小到忽略不计，就有助于简化 DHT 的系统设计。  通常的 DHT 都会采用大于等于 128 比特的散列值（2  128  比 “地球上所有电子文档总数” 还要大【很多数量级】）。        ◇同构的“node ID”与“data key” 
  DHT 属于分布式系统的一种。既然是分布式系统，意味着存在【多个】节点（电脑主机）。在设计分布式系统的时候，一种常见的做法是：给每一个节点（node）分配【唯一的】ID。有了这个节点 ID（node ID），在系统设计上的好处是——对分布式系统所依赖的物理网络的【解耦】。  很多 DHT 的设计会让“node ID”采用跟“data key”【同构】的散列值。这么搞的好处是：  1、当散列值空间足够大的时候，随机碰撞忽略不计，因此也就确保了 node ID 的唯一性  2、可以简化系统设计——比如简化路由算法（下面会提及）        ◇“拓扑结构”的设计 
  作为分布式系统，DHT 必然要定义某种拓扑结构；有了拓扑结构，自然就要设计某种“路由算法”。  如果某个 DHT 采用前面所说的——“node ID”与“data key”【同构】——那么很自然的就会引入“  Key-based routing  ”。  请注意，这【不是】某个具体的路由算法，而只是某种【风格】。采用这种风格来设计路由机制，好处是： 
   key 本身已经提供了足够多的路由信息
   。   当某个分布式系统具有自己的拓扑结构，它本身成为一个“覆盖网络”（洋文叫“Overlay Network”）。所谓的“覆盖网络”，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的“覆盖网络”，它们的数据通讯是依赖下层的互联网来实现的。  前面提到的“node ID”，其【解耦】的作用就体现在——分布式系统在设计拓扑结构和路由算法时，只需要考虑 node ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。        ◇“路由算法”的权衡 
  由于 DHT 中的节点数可能非常多（比如：几十万、几百万），而且这些节点是动态变化的。因此就【不可能】让每一个节点都记录所有其它节点的信息。实际情况是：每个节点通常只知道少数一些节点的信息。  这时候就需要设计某种路由算法，尽可能利用已知的节点来转发数据。“路由算法”这玩意儿很重要，直接决定了 DHT 的速度和资源消耗。  在确定了路由算法之后，还需要做一个两难的权衡——“路由表的大小”。  路由表越大，可以实现越短（跳数越少）的路由；缺点是：（由于节点动态变化）路由表的维护成本也就越高。  路由表数越小，其维护成本越小；缺点是：路由就会变长（跳数变多）。        ◇距离算法 
  某些 DHT 系统还会定义一种“距离算法”，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。  请注意：此处所说的“距离”属于【逻辑层面】，对应的是 DHT 自己的拓扑结构；它与地理位置【无关】，也与互联网的拓扑结构【无关】。  写到这里，某些聪明的读者就会明白：为啥前面要强调——“node ID”与“data key”【同构】。当这两者【同构】，就可以使用【同一种“距离算法”】；反之，如果这两者不同构，多半要引入几种不同的“距离算法”。        ◇数据定位 
  有了前面这一大砣东西作为铺垫，现在就可以来谈谈“数据定位”啦。对 DHT 而言，这是最关键的东东。  DHT 与传统的散列表在【功能】上是类似的。说白了，他们最关键的功能只有两个——“保存数据”和“获取数据”。如果用 C 语言来表示的话，函数原型大致如下：      void put(KEY k, VALUE v);  // 保存“键值对”
VALUE get(KEY k);  // 根据“键”获取“值”    
  
   保存数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点得到了新加入的数据（K/V），它会先计算自己与新数据的 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么这个数据就保持在自己这里。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。   
   获取数据
    （以下只是大致原理，具体的协议实现可能会有差异）  当某个节点接收到查询数据的请求（key），它会先计算自己与 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。  如果计算下来，自己与 key 的距离最小，那么就在自己这里找有没有 key 对应的 value。有的话就返回 value，没有的话就报错。  否则的话，把这个数据转发给距离最小的节点。  收到数据的另一个节点，也采用上述过程进行处理（递归处理）。         ★  Chord 协议  简介 
       ◇概述 
  Chord 诞生于2001年。第一批 DHT 协议都是在那年涌现的，另外几个是：  CAN  、  Tapestry  、  Pastry  。  俺之所以选取 Chord 来介绍，主要是因为 Chord 的原理比较简单（概念好理解），而且相关的资料也很多。   （请允许俺稍微跑题，聊一下 IT 八卦）  Chord 是 MIT 的几个技术牛人一起搞出来的，这几个牛人中包括世界级的黑客：罗伯特·莫里斯（  Robert Morris  ）。  此人以“  莫里斯蠕虫  ”而享誉信息安全界。这是 IT 史上【第一个】蠕虫（注：蠕虫可以利用网络【实时】传播），这个蠕虫对当时（1988年）的互联网造成毁灭性打击（一天之内，约十分之一的互联网主机中招并下线）。  他不仅是编程高手兼顶级黑客，而且是创业者兼投资人。他与同样大名鼎鼎的保罗·格雷汉姆（  Paul Graham  ）以及  Trevor Blackwell  ，3人在1995年共同创立了  Viaweb  ，并在1998年把公司以5千万美元卖给 Yahoo。然后他们拿这笔钱创办了  Y Combinator  （如今世界闻名的风投机构）。        ◇拓扑结构——环形 
  要聊 Chord 的拓扑，必然要提到“  Consistent Hashing  ”（译作：“一致散列”或“稳定散列”）。搞明白“一致散列”也就知道 Chord 的拓扑设计了。  提出“一致散列”这个概念主要是为了解决“节点动态变化”的难点（前面有提及）。为了解决这个难点，“一致散列”把散列值空间（keyspace）构成一个【环】。对于 
   m
   比特的散列值，其范围是 
   [0, 2
   
    m
   
   -1]
   。你把这个区间头尾相接就变成一个环，其周长是 
   2
   
    m
   
   。然后对这个环规定了一个移动方向（比如顺时针）。  如果 node ID 和 data key 是同构的，那么这两者都可以映射到这个环上（对应于环上的某点）。          （示意图：环形的 keyspace） 
  假设有某个“节点A”，距离它最近的是“节点B”（以顺时针方向衡量距离）。那么称 B 是 A 的【继任】（successor），A 是 B 的【前任】（predecessor）。   数据隶属于【距离最小】的节点。以 
   m = 6
   的环形空间为例：  数据区间 
   [5,8]
   隶属于“节点8”  数据区间 
   [9,15]
   隶属于“节点15”  ......  数据区间 
   [59,4]
   隶属于“节点4”（注：“6比特”的环形空间， 
   63
   之后是 
   0
   ）          （示意图：“数据”与“节点”对应关系） 
  以上就是“一致性散列”的拓扑结构，同时也是 Chord 的拓扑结构。        ◇路由机制 
  接下来简单说一下路由的玩法。   
   基本路由（简单遍历）
    当收到请求（key），先看 key 是否在自己这里。如果在自己这里，就直接返回信息；否则就把 key 转发给自己的继任者。以此类推。  这种玩法的时间复杂度是： 
   O(N)
   。对于一个节点数很多的 DHT 网络，这种做法显然【非常低效】。   
   高级路由（Finger Table）
    由于“基本路由”非常低效，自然就引入更高级的玩法——基于“Finger Table”的路由。  “Finger Table”是一个列表，最多包含 
   m
   项（ 
   m
   就是散列值的比特数），每一项都是节点 ID。  假设当前节点的 ID 是 
   n
   ，那么表中第 
   i
   项的值是： 
   successor( (n + 2
   
    i
   
   ) mod 2
   
    m
   
   )
    当收到请求（key），就到“Finger Table”中找到【最大的且不超过 key】的那一项，然后把 key 转发给这一项对应的节点。  有了“Finger Table”之后，时间复杂度可以优化为： 
   O(log N)
   。          （示意图：Finger Table） 
       ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 通过跟 B 进行查询，找到自己这个 ID 在环上的接头人。也就是——找到自己这个 ID 对应的“继任”（假设叫 C）与“前任”（假设叫 D）  4  接下来，A 需要跟 C 和 D 进行一系列互动，使得自己成为 C 的前任，以及 D 的继任。  这个互动过程，大致类似于在双向链表当中插入元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【正常】退出 
  如果某个节点想要主动离开这个 DHT 网络，按照约定需要作一些善后的处理工作。比如说，通知自己的前任去更新其继任者......  这些善后处理，大致类似于：在双向链表中删除元素（考虑到篇幅，此处省略 XXX 字）。        ◇节点的【异常】退出 
  作为一个分布式系统，任何节点都有可能意外下线（也就是说，来不及进行善后就挂掉了）  假设 节点A 的继任者【异常】下线了，那么 节点A 就抓瞎了。咋办捏？  为了保险起见，Chord 引入了一个“继任者候选列表”的概念。每个节点都用这个列表来包含：距离自己最近的 N 个节点的信息，顺序是【由近到远】。一旦自己的继任者下线了，就在列表中找到一个【距离最近且在线】的节点，作为新的继任者。然后 节点A 更新该列表，确保依然有 N 个候选。更新完“继任者候选列表”后，节点A 也会通知自己的前任，那么 A 的前任也就能更新自己的“继任者候选列表”。        ◇引申阅读 
  Chord 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Chord——A Scalable Peer-to-peer Lookup Service for Internet Applications  》         ★  Kademlia（Kad）协议  简介 
  （注：由于“Kademlia”这个词太长，为了打字省力，以下都采用“Kad”这个简写）        ◇概述 
  Kad 诞生于2002年，由纽约大学的两个牛人（Petar Maymounkov &amp; David Mazières）共同设计（他俩的论文，在本章节末尾附有链接）。  Kad 的原理比 Chord 稍微晦涩一些（涉及一点点数据结构的知识，如果你是程序猿，不用怕）。俺之所以选 Kad 来介绍，是因为——实际应用的 DHT 大部分都采用 Kad 及其变种。比如几种知名的 P2P 下载（BT、eDonkey/电驴、eMule/电骡）的 DHT 都是基于 Kad；知名的 I2P 暗网也依赖 Kad（说到 I2P，俺博客写过一篇扫盲教程，在“  这里  ”）。        ◇拓扑结构——二叉树 
  
   散列值的预处理
    Kad 也采用了“node ID 与 data key 同构”的设计思路。然后 Kad 采用某种算法把 key 映射到一个二叉树，每一个 key 都是这个二叉树的【叶子】。  在映射之前，先做一下预处理。  1. 先把 key 以二进制形式表示。  2. 把每一个 key 缩短为它的【最短唯一前缀】。   
   为啥要搞“最短唯一前缀”？
    Kad 使用 
   160比特
   的散列算法（比如 SHA1），完整的 key 用二进制表示有 
   160
   个数位（bit）。  首先，实际运行的 Kad 网络，即使有几百万个节点，相比 keyspace（2  160  ）也只是很小很小很小的一个子集。  其次，由于散列函数的特点，key 的分布是【高度随机】的。因此也是【高度离散】的——任何两个 key 都【不会】非常临近。  所以，使用“最短唯一前缀”来处理 key 的二进制形式，得到的结果就会很短（比特数远远小于 160）。   
   散列值的映射
    完成上述的预处理后，接下来的映射规则是：  1. 先把 key 以二进制形式表示，然后从高位到低位依次处理。  2. 二进制的第 
   n
   个 bit 就对应了二叉树的第 
   n
   层  3. 如果该位是 
   1
   ，进入左子树，是 
   0
   则进入右子树（这只是人为约定，反过来处理也可以）  4. 全部数位都处理完后，这个 key 就对应了二叉树上的某个【叶子】          （示意图：“最短唯一前缀”映射到二叉树的叶子） 
       ◇距离算法——异或（XOR） 
  接下来要聊的是 Kad【最精妙之处】——采用 XOR（按位异或操作）算法计算 key 之间的“距离”。  这种搞法使得它具备了类似于“几何距离”的某些特性（下面用 ⊕ 表示 XOR）      
      
        
          
      (A ⊕ B) == (B ⊕ A)
     
          XOR 符合“交换律”，具备对称性。相比之下，Chord 的距离算法不对称
        
        
          
      (A ⊕ A) == 0
     
          反身性，自身距离为零
        
        
          
      (A ⊕ B) &gt; 0
     
          【不同】的两个 key 之间的距离必大于零
        
        
          
      (A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)
     
          三角不等式
        
      
    
       ◇路由机制 
  
   二叉树的拆分
    对每一个节点，都可以【按照自己的视角】对整个二叉树进行拆分。  拆分的规则是：先从根节点开始，把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推，直到最后只剩下自己。  Kad 默认的散列值空间是 
   m = 160
   （散列值有 
   160 bits
   ），因此拆分出来的子树【最多】有 
   160
   个（考虑到实际的节点数【远远小于】 
   2
   
    160
   
   ，子树的个数会明显小于 
   160
   ）。  对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的【任何一个】节点（考虑到篇幅，具体的数学证明就不贴出来了）          （示意图：二叉树的拆分。 
    注：图中的“第三”与“第四”应对调。非常感谢热心读者在评论区指正！
    ） 
  
   K-桶（K-bucket）
    前面说了，每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（请始终牢记：分布式系统的节点是动态变化滴），光知道【一个】显然是不够滴，需要知道【多个】才比较保险。  所以 Kad 论文中给出了一个“K-桶（K-bucket）”的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 
   K
   个节点。这里所说的 
   K
   值是一个【系统级】的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 
   8
   ）。  这个“K-桶”其实就是【路由表】。对于某个节点而言，如果【以它自己为视角】拆分了 
   n
   个子树，那么它就需要维护 
   n
   个路由表，并且每个路由表的【上限】是 
   K
   。  说 K 只是一个【上限】，是因为有两种情况使得 K 桶的尺寸会小于 K。  1. 距离越近的子树就越小。如果整个子树【可能存在的】节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。  2. 有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。          （示意图：K = 2 的路由表） 
         （示意图：路由过程） 
  
   K-桶（K-bucket）的刷新机制
    刷新机制大致有如下几种：  1. 主动收集节点  任何节点都可以主动发起“查询节点”的请求（对应于协议类型 FIND_NODE），从而刷新 K 桶中的节点信息（下面聊“节点的加入”时，会提及这种）  2. 被动收集节点  如果收到其它节点发来的请求（协议类型 FIND_NODE 或 FIND_VALUE），会把对方的 ID 加入自己的某个 K 桶中。  3. 探测失效节点  Kad 还是支持一种探测机制（协议类型 PING），可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点，然后把下线的节点从路由表中干掉。   
   “并发请求”与“α 参数”
    “K桶”的这个设计思路【天生支持并发】。因为【同一个】“K桶”中的每个节点都是平等的，没有哪个更特殊；而且对【同一个】“K桶”中的节点发起请求，互相之间没有影响（无耦合）。  所以 Kad 协议还引入了一个“α参数/α因子”，默认设置为 
   3
   ，使用 Kad 的软件可以在具体使用场景中调整这个“α因子”。  当需要路由到某个“子树”，会从该子树对应的“K桶”中挑选【α个节点】，然后对这几个节点【同时】发出请求。  这么做有啥好处捏？俺在本文末尾聊“性能”和“安全性”时会具体介绍。        ◇节点的加入 
  1  任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。  2  A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）  3  A 向 B 发起一个查询请求（协议类型 FIND_NODE），请求的 ID 是自己（通俗地说，就是查询自己）  4  B 收到该请求之后，（如前面所说）会先把 A 的 ID 加入自己的某个 K 桶中。  然后，根据 FIND_NODE 协议的约定，B 会找到【K个】最接近 A 的节点，并返回给 A。  （B 怎么知道哪些节点接近 A 捏？这时候，【用 XOR 表示距离】的算法就发挥作用啦）  5  A 收到这 K 个节点的 ID 之后，（仅仅根据这批 ID 的值）就可以开始初始化自己的 K 桶。  6  然后 A 会继续向刚刚拿到的这批节点发送查询请求（协议类型 FIND_NODE），如此往复（递归），直至 A 建立了足够详细的路由表。        ◇节点的退出 
  与 Chord 不同，Kad 对于节点退出没有额外的要求（没有“主动退出”的说法）。  所以，Kad 的节点想离开 DHT 网络【不】需要任何操作（套用徐志摩的名言：  悄悄的我走了，正如我悄悄的来  ）        ◇引申阅读 
  Kad 就介绍到这里。想要进一步了解的同学，可以参考其原创论文：  《  Kademlia——A Peer-to-peer Information System Based on the XOR Metric  》         ★为啥 Kad 成为 DHT 的主流？ 
  Kad 成为 DHT 的主流实现方式，这已经是很明显的事实。问题在于：为啥会是它？  这是一个比较发散的问题，以下是俺个人观点，供参考。        ◇简单性 
  在“简单性”方面，Kad 和 Chord 都属于很简单的。所以俺要拿一个【反面教程】作为对比。  下面俺来说说 CAN（Content Addressable Network）——它是最早出现的四个 DHT 协议之一（2001年），在学术界也算很有名气。  介绍 CAN 的资料，通常会在开篇提到：CAN 的拓扑结构是基于【多维笛卡尔环面】。俺相信很多程序员看到这个词汇，心里会咯噔一下，脑袋会大一圈。  和 CAN 的【多维环面】比起来，Kad 基于【二叉树】的拓扑结构，就显得异常简单、非常亲切。假如要让程序员在 “二叉树” 和 “多维笛卡尔环面” 二选一，都不用调查问卷，俺就敢打保票——超过 99% 的程序员会选择“二叉树”。  Kad 除了拓扑结构很简单，它的距离算法也很简单——只不过是节点 ID 的异或运算（XOR）。   （稍微跑题一下）  有很多充满学院派气息的系统设计，最终成为空中楼阁，就是因为：这些系统的【设计太复杂】了。当程序员对设计望而生畏，更有可能的情况是：要么没人愿意动手写，要么是有人动手写了，但是迟迟做不出来。        ◇灵活性 
  以 Kad 和 Chord 的路由表来作对比。  Kad 的“K-bucket”是可以根据使用场景来调整 K 值，而且对 K 值的调整完全不影响代码实现。这就是所谓的“适应需求的灵活性”（有时也称之为“设计的弹性”）。  相比之下，Chord 的“Finger Table”就没有这种灵活性。        ◇性能 
  Kad 的路由算法天生就支持【并发】（参见前面介绍的“α 参数”）。  而很多 DHT 协议（包括 Chord）没有这种优势。  由于公网上的线路具有很大的不确定性（极不稳定），哪怕是同样两个节点，之间的传输速率也可能时快时慢。由于 Kad 路由请求支持并发，发出请求的节点总是可以获得最快的那个 peer 的响应。        ◇安全性 
  考虑到本文只介绍了 Chord 和 Kad，还是拿它俩做对比。  假设某个攻击者想要搞 Chord 网络的某个节点（假设叫 A），他/她可以先获得此 节点A 的 ID（这并不难）。知道 节点A 的 ID 后，攻击者就可以运行若干个受控的 Chord 节点（恶意节点），并且精心设置这批恶意节点的 ID；当这批恶意节点加入 Chord 网络后，就可以顺利被添加到 节点A 的路由表中（具体的原理，参见前面对“Finger Table”的介绍）。一旦 节点A 的路由表加入【足够多】的恶意节点，那么 节点A 的路由就有【足够大】的概率会经过这批恶意节点。攻击者作为这批恶意节点的控制人，就可以对 节点A 做很多手脚。   从理论上讲，类似的手法也可以用来针对 Kad。但是攻击难度会显著变大。原因如下：  1  Kad 协议缺省约定——在线时间越长的节点越可能被加入“K桶”。所以攻击者哪怕构造了一批恶意节点，这些恶意节点要想被正常节点加入自己的“K桶”，难度也很大。  2  就算某个恶意节点（比如叫 X）被正常节点（比如叫 A）加入“K-桶”。由于一个“K-桶”只对应【一个子树】。所以，只有当 节点A 在针对某个【特定子树】进行路由的时候，才【有可能】会碰上这个恶意节点。  （唠叨一下：Kad 的路由算法中，对每个子树都维护一个“K-桶”作为路由表）  3  即便正好对这个子树路由，也【不一定】会碰上恶意节点——碰上的【概率】取决于：“K 的大小” 以及 “从桶中选取节点的策略”。  4  前面提到：Kad 协议支持【并发查询】——每次都会从同一个“K-桶”中取出【α个】节点，发出查询请求（参数 α 默认设为 3,可以调大）  所以，这【α 个节点】中，如果只有一个是恶意的，这个恶意节点也很难捣乱；除非这【α 个节点】全部都是恶意的，而这个概率又很小。   （注：俺并【没有】说 Kad 是最安全的。这段介绍只能让你体会一下“K-桶”的设计思路——除了增加性能，还顺便增加了攻击者的难度）        ◇小结 
  刚才聊的这几个方面，对每一个方面，Kad 未必能排第一，但至少它都能排进前几名。  几个方面综合起来，它就成为最有竞争力和活力的 DHT 技术方案。         ★结尾 
  刚才聊到了“安全性”，本来还想再写一个章节，谈谈“针对 DHT 网络的攻击手法”。不过捏，本文已经写了很长，为了照顾某些患有“阅读障碍症”的读者，就先到此为止吧。今后另外找时间谈“攻击 DHT”这个话题。  由于本文的某些内容，俺也是现学现卖。如有错漏之处，还望懂行的同学不吝赐教 :)    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲文件完整性校验——关于散列值和数字签名    聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？    “如何翻墙”系列：简单扫盲 I2P 的使用    “对抗专制、捍卫自由”的 N 种技术力量    聊聊“单点故障”——关于“德国空难”和“李光耀”的随想      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例&url=https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2017-09-21
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="4749619163960271295">
 </a>   <h1 class="post-title entry-title" id="dht-kademliakad--chord---"> <a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html"> 聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
    <h2 id="section"> ★引子——为啥要聊这个话题？ </h2>
 <br /> 这是一篇比较深入地谈技术的博文（而且还牵涉到一点算法）。俺很久没有写这种类型的博文了。 <br /> 今天发这篇，主要是因为如下几点： <br /> 1 <br /> 在“对抗 GFW、对抗政府审查”的过程中，【彻底无中心】的分布式系统是非常有用滴！ <br /> （关于这点，请参见前几年的博文：《 <a href="https://program-think.blogspot.com/2015/08/Technology-and-Freedom.html"> “对抗专制、捍卫自由”的 N 种技术力量 </a> 》） <br /> 2 <br /> DHT 是这类分布式系统的【关键基础设施】，俺希望追求自由的网民能多了解这方面的知识 <br /> 3 <br /> 俺也希望有更多程序员能参与这方面的【开源社区】。 <br /> 在对抗政府审查的时候，商业公司是靠不住滴；只能指望开源社区。 <br /> 4 <br /> 虽然 GFW 已经在封杀 BT sync／Resilio Sync；但是，启用了 DHT 功能的 BTsync（必须是老版本），在墙内依然是【免翻墙】可用，让俺很受鼓舞 :) <br /> （感兴趣的同学可以参见上个月的博文：《 <a href="https://program-think.blogspot.com/2017/08/GFW-Resilio-Sync.html"> 聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？ </a> 》） <br /> <a name="more">
  </a>     <!--program-think-->
 <br /> <br />     <h2 id="section-1"> ★预备知识 </h2>
 <br /> （如果你自认为是一个熟练的程序员，请直接略过“预备知识”这个章节，看下一章节） <br /> <br />     <h3 id="hash-"> ◇什么是“散列/哈希（hash）”？ </h3>
 <br /> （注：在本文中，凡是提及“散列”或“哈希”或“hash”，均表示相同含义） <br /> 关于 hash 的概念，俺曾经写过一篇相关的扫盲教程《 <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html"> 扫盲文件完整性校验——关于散列值和数字签名 </a> 》，不了解此概念的同学，可以先看看。 <br /> 老实说，如果你还没有搞明白 hash 的概念，就不要浪费时间看本文的后续部分了。 <br /> <br />     <h3 id="hash-table-"> ◇什么是“散列表/哈希表（hash table）”？ </h3>
 <br /> “散列表/哈希表”是用来存储“键值对”的一种容器。“键值对”洋文称之为“key/value pairs”，简称“K/V”。有了“散列表”，你可以很方便快速地通过 key 来获得 value。 <br /> 举个例子： <br /> 手机通讯簿可以通俗理解成一个“散列表”。里面的每一条记录都包含“姓名”和“电话号码”。“姓名”相当于“键值对”中的 key，电话号码相当于 value。你可以通过姓名方便地查找出电话号码。 <br /> <br />     <h3 id="section-2"> ◇如何实现散列表？ </h3>
 <br /> （考虑到本文的完整性，【简单介绍】一下散列表的实现） <br /> 在散列表这种数据结构中，会包含 N 个 bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是【固定不变】的。于是可以对每个桶进行编号，从 0 到 N-1。 <br /> “桶”是用来存储“键值对”的，你可以把它通俗理解成一个动态数组，里面可以存放【多个】“键值对”。 <br /> 下面这张图是从维基百科上剽窃来的。它展示了散列表的【查找】原理。当使用某个 key 进行查找，会先用某个散列函数计算这个 key 的散列值。得到散列值通常是一个整数，然后用散列值对 N（桶数）进行“取模”运算（除法求余数），就可以算出对应的桶编号。 <br /> （注：取模运算是最常用的做法，但不是唯一的做法） <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/g2t9an0nnQBFU15li-eEXeOT241zE01PPjDLdS2r0jrdx2ppj5dJgoNOmWol5w6RDiWSC65yl10cVp62oDMqoOY8Yg9IqGvNcx5_x0pBNYhSATC-YDRjFEwDU3gewOncaxDEQMo9kCM" /> <br /> （使用散列表存储电话簿的示意图，剽窃自维基百科） </center>
 <br />     <h3 id="collision-"> ◇什么是“散列表”的【碰撞/冲突】（Collision）？ </h3>
 <br /> 在俺那篇 <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html"> 扫盲教程 </a> 中，已经介绍了“散列碰撞”（也称为“散列冲突”）的概念。 <br /> 当两个不同的 key 进行哈希计算却得到【相同的散列值】，就是所谓的【散列函数碰撞】。一旦出现这种情况，这两个 key 对应的两个键值对就会被存储在【同一个】桶（bucket）里面。 <br /> 另一种情况是：虽然计算出来的散列值【不同】，但经过“取模运算”之后却得到【相同】的桶编号。这时候也会出现：两个键值对存储在一个桶里面。 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh6.googleusercontent.com/y80fWOX2cc76ATsjwTocHGZhB8vlXjq8VVGgrOp42ZAw1WQ8a4q8EuZQr_2OD09HSzTDrb22jRvSmM8WNfBWJh2_oUhkODZP2BVQQ44yTlzTB173yI0DeGPqYm7e-mZrb2RVbUR03SI" /> <br /> （出现“散列碰撞”的示意图，剽窃自维基百科） </center>
 <br /> 如果某个哈希表在存储数据时【完全没有碰撞】，那么每个桶里面都只有 0个 或 1个 键值对。查找起来就非常快。 <br /> 反之，如果某个哈希表在存储数据时出现【严重碰撞】，就会导致某些桶里面存储了一大坨的键值对。将来查找 key 的时候，如果定位到的是这种“大桶”，就需要在这个桶里面逐一比对 key 是否相同——查找效率就会变得很差。 <br /> <br />     <h3 id="section-3"> ◇“散列表”有哪些优点？ </h3>
 <br /> 主要优点是：（当数据量很大时）散列表可以提供快速且稳定的查找速度。 <br /> 当然，这里有个前提就是：散列函数要【足够好】—— <br /> 1、计算出的散列值要足够离散（从而使得不同的键值对可以比较【均匀】地分配到各个桶里面） <br /> 2、要尽可能降低碰撞（碰撞会降低性能） <br /> 另一个前提是：桶的数量也有一定的讲究—— <br /> 1、桶数要足够大。否则的话，【必定会】导致某些桶里面的键值对太多（这点很明显，没想明白的同学，可参见“抽屉原理”） <br /> 2、（如果用常见的“取模”映射到桶）桶的总数最好是【质数/素数】（这个不解释，爱思考的同学自己想一下） <br /> <br /> <br />     <h2 id="dht-"> ★分布式散列表（DHT）概述 </h2>
 <br />     <h3 id="dht--1"> ◇什么是 DHT？ </h3>
 <br /> “分布式散列表”也称为“分布式哈希表”，洋文是“distributed hash table”，简称 DHT。 <br /> “分布式散列表”在概念上类似与传统的“散列表”，差异在于—— <br /> “传统的散列表”主要是用于单机上的某个软件中； <br /> “分布式散列表”主要是用于分布式系统（此时，分布式系统的节点可以通俗理解为散列表中的 bucket） <br /> <br /> “分布式散列表”主要是用来存储大量的（甚至是海量的）数据。在实际使用场景中，直接对所存储的“每一个业务数据”计算散列值，然后用散列值作为 key，业务数据本身是 value。 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh3.googleusercontent.com/_cWzH9uqPYg9zsOUySCErLgstiiQYxKG2YYClponqFNlAZlFmIz8QA_5JIe6sP_vGphHifZZ-YGHtDp5UMvF9KBWKD5dZ_Lz9njho0pv14ChKlivbUHjYD8IpP6h16b8ZCGF2ipc7c8" /> <br /> （分布式散列表的示意图，此图剽窃自维基百科） </center>
 <br /> （为了偷懒，本文以下部分均使用 DHT 来表示“分布式散列表”） <br /> <br />     <h3 id="dht--2"> ◇为啥会出现 DHT？ </h3>
 <br /> 在 P2P 文件共享的发展史上，出现过3种不同的技术路线（三代）。 <br /> <br /> <b>
   第1代
  </b> <br /> 采用【中央服务器】的模式——每个节点都需要先连接到中央服务器，然后才能查找到自己想要的文件在哪里。 <br /> 这种技术的最大缺点是——中央服务器成为整个 P2P 网络的【单点故障】。 <br /> （关于“单点故障”这个概念，可以看另一篇介绍：《 <a href="https://program-think.blogspot.com/2015/04/Single-Point-of-Failure.html"> 聊聊“单点故障”——关于“德国空难”和“李光耀”的随想 </a> 》） <br /> 这类 p2p 的典型代表是 <a href="https://en.wikipedia.org/wiki/Napster" rel="nofollow" target="_blank"> Napster </a> 。 <br /> <br /> <b>
   第2代
  </b> <br /> 采用【广播】的模式——要找文件的时候，每个节点都向自己相连的【所有节点】进行询问；被询问的节点如果不知道这个文件在哪里，就再次进行“广播”......如此往复，直至找到所需文件。 <br /> 这种技术的最大缺点是——会引发“广播风暴”并严重占用网络带宽，也会严重消耗节点的系统资源。即使在协议层面通过设置 TTL（time to live），限制查询过程只递归 N 轮，依然【无法】彻底解决此弊端。 <br /> 因为这种手法太吓人，获得“Query Flooding”的绰号。下面放一张示意图。 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh6.googleusercontent.com/trmBi0r-sOJY0WJ0TjmXaCYgo602BxNc7D5LAA1kSSByWBWMJF2DOBP64XWMe_DDV8WVUvqTSxibnPvpAKJ5oIxMAHeY3gPahp9s2BRNXUDceQzmwrjk0aWEvvx-X6z1iauTFo1X32o" /> <br /> （示意图：第2代 P2P 的 Query Flooding） </center>
 <br /> 这类 p2p 的典型代表是 <a href="https://en.wikipedia.org/wiki/Gnutella" rel="nofollow" target="_blank"> Gnutella </a> 的早期版本。 <br /> <br /> <b>
   第3代
  </b> <br /> 这一代采用的技术就是今天要聊的 DHT。 <br /> 通过 DHT 这个玩意儿，不但避免了第一代技术的【单点故障】，也避免了第二代技术的【广播风暴】。 <br /> <br />     <h3 id="dht--"> ◇DHT 有哪些应用场景？ </h3>
 <br /> DHT 最早用于 P2P 文件共享和文件下载（比如：BT、电驴、电骡），之后也被广泛用于某些分布式系统中，比如： <br />     <blockquote style="background-color:#DDD;">
分布式文件系统 <br /> 分布式缓存 <br /> 暗网（比如： <a href="https://en.wikipedia.org/wiki/I2P" rel="nofollow" target="_blank"> I2P </a> 、 <a href="https://en.wikipedia.org/wiki/Freenet" rel="nofollow" target="_blank"> Freenet </a> ） <br /> 无中心的聊天工具/IM（比如： <a href="https://en.wikipedia.org/wiki/Tox_(protocol)" rel="nofollow" target="_blank"> TOX </a> ） <br /> 无中心的微博客/microblogging（比如： <a href="https://en.wikipedia.org/wiki/Twister_(software)" rel="nofollow" target="_blank"> Twister </a> ） <br /> 无中心的社交网络/SNS    </blockquote>
 正是因为【无中心】的分布式系统普遍使用 DHT，所以本文开头称之为：分布式系统的【基础设施】。 <br /> <br /> <br />     <h2 id="dht--3"> ★分布式散列表（DHT）的难点 </h2>
 <br />     <h3 id="section-4"> ◇“无中心”导致的难点 </h3>
 <br /> 前面提到了 DHT 的诞生，是为了解决前面两代 P2P 技术的缺陷。其中一个缺陷是“中央服务器”导致的【单点故障】。 <br /> 因此 DHT 就【不能】再依靠中央服务器。而没有了中央服务器，就需要提供一系列机制来实现节点之间的通讯。 <br /> <br />     <h3 id="section-5"> ◇“海量数据”导致的难点 </h3>
 <br /> DHT 的很多使用场景是为了承载海量数据（PB 或更高级别）。 <br /> 由于数据是海量的，每个节点只能存储（整个系统的）一小部分数据。需要把数据【均匀分摊】到每个节点。 <br /> <br />     <h3 id="section-6"> ◇“节点动态变化”导致的难点 </h3>
 <br /> 很多 DHT 的使用场景是在公网（互联网）上，参与 DHT 的节点（主机）会出现【频繁变化】——每时每刻都有新的节点上线，也会有旧的节点下线。在这种情况下，需要确保数据依然是【均匀分摊】到所有节点。 <br /> <br /> （俺特别强调一下：传统的散列表在这种情况下的困难） <br /> 前面提到：传统散列表所含的【桶数】是固定不变滴。为啥捏？ <br /> 因为传统散列表在针对 key 计算出散列值之后，需要用“散列值”和“桶数”进行某种运算（比如：取模运算），从而得到桶的编号。 <br /> 如果桶的数量出现变化，就会影响到上述“取模运算”的结果，然后导致数据错乱。 <br /> <br />     <h3 id="section-7"> ◇“高效查询”导致的难点 </h3>
 <br /> 对于节点数很多的分布式系统，如何快速定位节点，同时又不消耗太多网络资源，这也是一个挑战。 <br /> 比如前面提到第二代 P2P 技术，在查找所需文件时会导致【广播风暴】。这就成为其致命弱点。 <br /> DHT 必须有更高效的查找机制。而且这种查找机制要能适应“节点动态变化”这个特点。 <br /> <br /> <br />     <h2 id="dht--4"> ★分布式散列表（DHT）如何解决上述难点？ </h2>
 <br /> DHT 采用如下一些机制来解决上述问题，并满足分布式系统比较苛刻的需求。 <br /> <br />     <h3 id="section-8"> ◇“散列算法”的选择 </h3>
 <br /> 前面提到：DHT 通常是直接拿业务数据的散列值作为 key，业务数据本身作为 value。 <br /> 考虑到 DHT 需要承载的数据量通常比较大，散列函数产生的“散列值范围”（keyspace）要足够大，以防止太多的碰撞。更进一步，如果 keyspace【大到一定程度】，使得“随机碰撞”的概率小到忽略不计，就有助于简化 DHT 的系统设计。 <br /> 通常的 DHT 都会采用大于等于 128 比特的散列值（2 <sup> 128 </sup> 比 “地球上所有电子文档总数” 还要大【很多数量级】）。 <br /> <br />     <h3 id="node-iddata-key-"> ◇同构的“node ID”与“data key” </h3>
 <br /> DHT 属于分布式系统的一种。既然是分布式系统，意味着存在【多个】节点（电脑主机）。在设计分布式系统的时候，一种常见的做法是：给每一个节点（node）分配【唯一的】ID。有了这个节点 ID（node ID），在系统设计上的好处是——对分布式系统所依赖的物理网络的【解耦】。 <br /> 很多 DHT 的设计会让“node ID”采用跟“data key”【同构】的散列值。这么搞的好处是： <br /> 1、当散列值空间足够大的时候，随机碰撞忽略不计，因此也就确保了 node ID 的唯一性 <br /> 2、可以简化系统设计——比如简化路由算法（下面会提及） <br /> <br />     <h3 id="section-9"> ◇“拓扑结构”的设计 </h3>
 <br /> 作为分布式系统，DHT 必然要定义某种拓扑结构；有了拓扑结构，自然就要设计某种“路由算法”。 <br /> 如果某个 DHT 采用前面所说的——“node ID”与“data key”【同构】——那么很自然的就会引入“ <a href="https://en.wikipedia.org/wiki/Key_based_routing" rel="nofollow" target="_blank"> Key-based routing </a> ”。 <br /> 请注意，这【不是】某个具体的路由算法，而只是某种【风格】。采用这种风格来设计路由机制，好处是： <b>
   key 本身已经提供了足够多的路由信息
  </b> 。 <br /> <br /> 当某个分布式系统具有自己的拓扑结构，它本身成为一个“覆盖网络”（洋文叫“Overlay Network”）。所谓的“覆盖网络”，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的“覆盖网络”，它们的数据通讯是依赖下层的互联网来实现的。 <br /> 前面提到的“node ID”，其【解耦】的作用就体现在——分布式系统在设计拓扑结构和路由算法时，只需要考虑 node ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。 <br /> <br />     <h3 id="section-10"> ◇“路由算法”的权衡 </h3>
 <br /> 由于 DHT 中的节点数可能非常多（比如：几十万、几百万），而且这些节点是动态变化的。因此就【不可能】让每一个节点都记录所有其它节点的信息。实际情况是：每个节点通常只知道少数一些节点的信息。 <br /> 这时候就需要设计某种路由算法，尽可能利用已知的节点来转发数据。“路由算法”这玩意儿很重要，直接决定了 DHT 的速度和资源消耗。 <br /> 在确定了路由算法之后，还需要做一个两难的权衡——“路由表的大小”。 <br /> 路由表越大，可以实现越短（跳数越少）的路由；缺点是：（由于节点动态变化）路由表的维护成本也就越高。 <br /> 路由表数越小，其维护成本越小；缺点是：路由就会变长（跳数变多）。 <br /> <br />     <h3 id="section-11"> ◇距离算法 </h3>
 <br /> 某些 DHT 系统还会定义一种“距离算法”，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。 <br /> 请注意：此处所说的“距离”属于【逻辑层面】，对应的是 DHT 自己的拓扑结构；它与地理位置【无关】，也与互联网的拓扑结构【无关】。 <br /> 写到这里，某些聪明的读者就会明白：为啥前面要强调——“node ID”与“data key”【同构】。当这两者【同构】，就可以使用【同一种“距离算法”】；反之，如果这两者不同构，多半要引入几种不同的“距离算法”。 <br /> <br />     <h3 id="section-12"> ◇数据定位 </h3>
 <br /> 有了前面这一大砣东西作为铺垫，现在就可以来谈谈“数据定位”啦。对 DHT 而言，这是最关键的东东。 <br /> DHT 与传统的散列表在【功能】上是类似的。说白了，他们最关键的功能只有两个——“保存数据”和“获取数据”。如果用 C 语言来表示的话，函数原型大致如下： <br />     <div style="background-color:#DDD;font-family:Courier,monospace;" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void put(KEY k, VALUE v);  // 保存“键值对”
VALUE get(KEY k);  // 根据“键”获取“值”</code></pre></div>    </div>
 <br /> <b>
   保存数据
  </b> <br /> （以下只是大致原理，具体的协议实现可能会有差异） <br /> 当某个节点得到了新加入的数据（K/V），它会先计算自己与新数据的 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。 <br /> 如果计算下来，自己与 key 的距离最小，那么这个数据就保持在自己这里。 <br /> 否则的话，把这个数据转发给距离最小的节点。 <br /> 收到数据的另一个节点，也采用上述过程进行处理（递归处理）。 <br /> <br /> <b>
   获取数据
  </b> <br /> （以下只是大致原理，具体的协议实现可能会有差异） <br /> 当某个节点接收到查询数据的请求（key），它会先计算自己与 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。 <br /> 如果计算下来，自己与 key 的距离最小，那么就在自己这里找有没有 key 对应的 value。有的话就返回 value，没有的话就报错。 <br /> 否则的话，把这个数据转发给距离最小的节点。 <br /> 收到数据的另一个节点，也采用上述过程进行处理（递归处理）。 <br /> <br /> <br />     <h2 id="chord----"> ★ <a href="https://en.wikipedia.org/wiki/Chord_(peer-to-peer)" rel="nofollow" target="_blank"> Chord 协议 </a> 简介 </h2>
 <br />     <h3 id="section-13"> ◇概述 </h3>
 <br /> Chord 诞生于2001年。第一批 DHT 协议都是在那年涌现的，另外几个是： <a href="https://en.wikipedia.org/wiki/Content_addressable_network" rel="nofollow" target="_blank"> CAN </a> 、 <a href="https://en.wikipedia.org/wiki/Tapestry_(DHT)" rel="nofollow" target="_blank"> Tapestry </a> 、 <a href="https://en.wikipedia.org/wiki/Pastry_(DHT)" rel="nofollow" target="_blank"> Pastry </a> 。 <br /> 俺之所以选取 Chord 来介绍，主要是因为 Chord 的原理比较简单（概念好理解），而且相关的资料也很多。 <br /> <br /> （请允许俺稍微跑题，聊一下 IT 八卦） <br /> Chord 是 MIT 的几个技术牛人一起搞出来的，这几个牛人中包括世界级的黑客：罗伯特·莫里斯（ <a href="https://en.wikipedia.org/wiki/Robert_Tappan_Morris" rel="nofollow" target="_blank"> Robert Morris </a> ）。 <br /> 此人以“ <a href="https://zh.wikipedia.org/wiki/%E8%8E%AB%E9%87%8C%E6%96%AF%E8%A0%95%E8%99%AB" rel="nofollow" target="_blank"> 莫里斯蠕虫 </a> ”而享誉信息安全界。这是 IT 史上【第一个】蠕虫（注：蠕虫可以利用网络【实时】传播），这个蠕虫对当时（1988年）的互联网造成毁灭性打击（一天之内，约十分之一的互联网主机中招并下线）。 <br /> 他不仅是编程高手兼顶级黑客，而且是创业者兼投资人。他与同样大名鼎鼎的保罗·格雷汉姆（ <a href="https://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)" rel="nofollow" target="_blank"> Paul Graham </a> ）以及 <a href="https://en.wikipedia.org/wiki/Trevor_Blackwell" rel="nofollow" target="_blank"> Trevor Blackwell </a> ，3人在1995年共同创立了 <a href="https://en.wikipedia.org/wiki/Viaweb" rel="nofollow" target="_blank"> Viaweb </a> ，并在1998年把公司以5千万美元卖给 Yahoo。然后他们拿这笔钱创办了 <a href="https://en.wikipedia.org/wiki/Y_Combinator_(company)" rel="nofollow" target="_blank"> Y Combinator </a> （如今世界闻名的风投机构）。 <br /> <br />     <h3 id="section-14"> ◇拓扑结构——环形 </h3>
 <br /> 要聊 Chord 的拓扑，必然要提到“ <a href="https://en.wikipedia.org/wiki/Consistent_hashing" rel="nofollow" target="_blank"> Consistent Hashing </a> ”（译作：“一致散列”或“稳定散列”）。搞明白“一致散列”也就知道 Chord 的拓扑设计了。 <br /> 提出“一致散列”这个概念主要是为了解决“节点动态变化”的难点（前面有提及）。为了解决这个难点，“一致散列”把散列值空间（keyspace）构成一个【环】。对于 <code class="language-plaintext highlighter-rouge">
   m
  </code> 比特的散列值，其范围是 <code class="language-plaintext highlighter-rouge">
   [0, 2
   
    m
   
   -1]
  </code> 。你把这个区间头尾相接就变成一个环，其周长是 <code class="language-plaintext highlighter-rouge">
   2
   
    m
   
  </code> 。然后对这个环规定了一个移动方向（比如顺时针）。 <br /> 如果 node ID 和 data key 是同构的，那么这两者都可以映射到这个环上（对应于环上的某点）。 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh3.googleusercontent.com/pHKHOknJrB8e4YjUSR3CAT9GfKFQIHkBjs3qfAGCbAtbaOqd6VqgZPxPsU3BO7VrsuBzqu06FkJpD9wVrx_1STgruNmbfCU1ir0FZR4-af5yr5K2Ftg-h7sEZmwcgSX4zyPfiD3dFS8" /> <br /> （示意图：环形的 keyspace） </center>
 <br /> 假设有某个“节点A”，距离它最近的是“节点B”（以顺时针方向衡量距离）。那么称 B 是 A 的【继任】（successor），A 是 B 的【前任】（predecessor）。 <br /> <br /> 数据隶属于【距离最小】的节点。以 <code class="language-plaintext highlighter-rouge">
   m = 6
  </code> 的环形空间为例： <br /> 数据区间 <code class="language-plaintext highlighter-rouge">
   [5,8]
  </code> 隶属于“节点8” <br /> 数据区间 <code class="language-plaintext highlighter-rouge">
   [9,15]
  </code> 隶属于“节点15” <br /> ...... <br /> 数据区间 <code class="language-plaintext highlighter-rouge">
   [59,4]
  </code> 隶属于“节点4”（注：“6比特”的环形空间， <code class="language-plaintext highlighter-rouge">
   63
  </code> 之后是 <code class="language-plaintext highlighter-rouge">
   0
  </code> ） <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/_J5Qn7E9HxyHxnTIfDSU7eUgKIA8_4zTvtuTiO0lriovmKbhUv8tJzZwTTaHvxqZajt38g41H5l-HjsqHXRCJWNGSs4SxtK0AHhsGoug4Q_HvkZF6NdIEXnwqFKyStoTOQ3BPmFWfns" /> <br /> （示意图：“数据”与“节点”对应关系） </center>
 <br /> 以上就是“一致性散列”的拓扑结构，同时也是 Chord 的拓扑结构。 <br /> <br />     <h3 id="section-15"> ◇路由机制 </h3>
 <br /> 接下来简单说一下路由的玩法。 <br /> <br /> <b>
   基本路由（简单遍历）
  </b> <br /> 当收到请求（key），先看 key 是否在自己这里。如果在自己这里，就直接返回信息；否则就把 key 转发给自己的继任者。以此类推。 <br /> 这种玩法的时间复杂度是： <code class="language-plaintext highlighter-rouge">
   O(N)
  </code> 。对于一个节点数很多的 DHT 网络，这种做法显然【非常低效】。 <br /> <br /> <b>
   高级路由（Finger Table）
  </b> <br /> 由于“基本路由”非常低效，自然就引入更高级的玩法——基于“Finger Table”的路由。 <br /> “Finger Table”是一个列表，最多包含 <code class="language-plaintext highlighter-rouge">
   m
  </code> 项（ <code class="language-plaintext highlighter-rouge">
   m
  </code> 就是散列值的比特数），每一项都是节点 ID。 <br /> 假设当前节点的 ID 是 <code class="language-plaintext highlighter-rouge">
   n
  </code> ，那么表中第 <code class="language-plaintext highlighter-rouge">
   i
  </code> 项的值是： <code class="language-plaintext highlighter-rouge">
   successor( (n + 2
   
    i
   
   ) mod 2
   
    m
   
   )
  </code> <br /> 当收到请求（key），就到“Finger Table”中找到【最大的且不超过 key】的那一项，然后把 key 转发给这一项对应的节点。 <br /> 有了“Finger Table”之后，时间复杂度可以优化为： <code class="language-plaintext highlighter-rouge">
   O(log N)
  </code> 。 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/1sd-UYFyL-0BGjMA5bFSXnDU_X2n3WdfGLyVoO_24AJNSxC-YV44_8l4o_vZwPexxtOUmSfeNWwRR9q-FufSIAnzKlTmMTWHQ87PQKcQmPE4ygkZODCD1jtK71Th_8-7UGM5_PTzD58" /> <br /> （示意图：Finger Table） </center>
 <br />     <h3 id="section-16"> ◇节点的加入 </h3>
 <br /> 1 <br /> 任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。 <br /> 2 <br /> A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计） <br /> 3 <br /> A 通过跟 B 进行查询，找到自己这个 ID 在环上的接头人。也就是——找到自己这个 ID 对应的“继任”（假设叫 C）与“前任”（假设叫 D） <br /> 4 <br /> 接下来，A 需要跟 C 和 D 进行一系列互动，使得自己成为 C 的前任，以及 D 的继任。 <br /> 这个互动过程，大致类似于在双向链表当中插入元素（考虑到篇幅，此处省略 XXX 字）。 <br /> <br />     <h3 id="section-17"> ◇节点的【正常】退出 </h3>
 <br /> 如果某个节点想要主动离开这个 DHT 网络，按照约定需要作一些善后的处理工作。比如说，通知自己的前任去更新其继任者...... <br /> 这些善后处理，大致类似于：在双向链表中删除元素（考虑到篇幅，此处省略 XXX 字）。 <br /> <br />     <h3 id="section-18"> ◇节点的【异常】退出 </h3>
 <br /> 作为一个分布式系统，任何节点都有可能意外下线（也就是说，来不及进行善后就挂掉了） <br /> 假设 节点A 的继任者【异常】下线了，那么 节点A 就抓瞎了。咋办捏？ <br /> 为了保险起见，Chord 引入了一个“继任者候选列表”的概念。每个节点都用这个列表来包含：距离自己最近的 N 个节点的信息，顺序是【由近到远】。一旦自己的继任者下线了，就在列表中找到一个【距离最近且在线】的节点，作为新的继任者。然后 节点A 更新该列表，确保依然有 N 个候选。更新完“继任者候选列表”后，节点A 也会通知自己的前任，那么 A 的前任也就能更新自己的“继任者候选列表”。 <br /> <br />     <h3 id="section-19"> ◇引申阅读 </h3>
 <br /> Chord 就介绍到这里。想要进一步了解的同学，可以参考其原创论文： <br /> 《 <a href="https://docs.google.com/document/d/18z3kYelg0ZR5zcquRs_CAZiGee2affHNQ2Cdt7gjqMs/" target="_blank"> Chord——A Scalable Peer-to-peer Lookup Service for Internet Applications </a> 》 <br /> <br /> <br />     <h2 id="kademliakad---"> ★ <a href="https://en.wikipedia.org/wiki/Kademlia" rel="nofollow" target="_blank"> Kademlia（Kad）协议 </a> 简介 </h2>
 <br /> （注：由于“Kademlia”这个词太长，为了打字省力，以下都采用“Kad”这个简写） <br /> <br />     <h3 id="section-20"> ◇概述 </h3>
 <br /> Kad 诞生于2002年，由纽约大学的两个牛人（Petar Maymounkov &amp; David Mazières）共同设计（他俩的论文，在本章节末尾附有链接）。 <br /> Kad 的原理比 Chord 稍微晦涩一些（涉及一点点数据结构的知识，如果你是程序猿，不用怕）。俺之所以选 Kad 来介绍，是因为——实际应用的 DHT 大部分都采用 Kad 及其变种。比如几种知名的 P2P 下载（BT、eDonkey/电驴、eMule/电骡）的 DHT 都是基于 Kad；知名的 I2P 暗网也依赖 Kad（说到 I2P，俺博客写过一篇扫盲教程，在“ <a href="https://program-think.blogspot.com/2012/06/gfw-i2p.html"> 这里 </a> ”）。 <br /> <br />     <h3 id="section-21"> ◇拓扑结构——二叉树 </h3>
 <br /> <b>
   散列值的预处理
  </b> <br /> Kad 也采用了“node ID 与 data key 同构”的设计思路。然后 Kad 采用某种算法把 key 映射到一个二叉树，每一个 key 都是这个二叉树的【叶子】。 <br /> 在映射之前，先做一下预处理。 <br /> 1. 先把 key 以二进制形式表示。 <br /> 2. 把每一个 key 缩短为它的【最短唯一前缀】。 <br /> <br /> <b>
   为啥要搞“最短唯一前缀”？
  </b> <br /> Kad 使用 <code class="language-plaintext highlighter-rouge">
   160比特
  </code> 的散列算法（比如 SHA1），完整的 key 用二进制表示有 <code class="language-plaintext highlighter-rouge">
   160
  </code> 个数位（bit）。 <br /> 首先，实际运行的 Kad 网络，即使有几百万个节点，相比 keyspace（2 <sup> 160 </sup> ）也只是很小很小很小的一个子集。 <br /> 其次，由于散列函数的特点，key 的分布是【高度随机】的。因此也是【高度离散】的——任何两个 key 都【不会】非常临近。 <br /> 所以，使用“最短唯一前缀”来处理 key 的二进制形式，得到的结果就会很短（比特数远远小于 160）。 <br /> <br /> <b>
   散列值的映射
  </b> <br /> 完成上述的预处理后，接下来的映射规则是： <br /> 1. 先把 key 以二进制形式表示，然后从高位到低位依次处理。 <br /> 2. 二进制的第 <code class="language-plaintext highlighter-rouge">
   n
  </code> 个 bit 就对应了二叉树的第 <code class="language-plaintext highlighter-rouge">
   n
  </code> 层 <br /> 3. 如果该位是 <code class="language-plaintext highlighter-rouge">
   1
  </code> ，进入左子树，是 <code class="language-plaintext highlighter-rouge">
   0
  </code> 则进入右子树（这只是人为约定，反过来处理也可以） <br /> 4. 全部数位都处理完后，这个 key 就对应了二叉树上的某个【叶子】 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh6.googleusercontent.com/votM6Lmhf1s2CdZ8U6m98KX9vkIh1thszgLM6HjwQc46t_sZe9lNFLvrjBtZ2BXJebSc3fG3w1L3mkvYCQPkvB3tLdzvF__iEz1Xnq-3yu-E6JZLCr4Nkqq3Zc_hT2KlBI9JvnnDZs0" /> <br /> （示意图：“最短唯一前缀”映射到二叉树的叶子） </center>
 <br />     <h3 id="xor-"> ◇距离算法——异或（XOR） </h3>
 <br /> 接下来要聊的是 Kad【最精妙之处】——采用 XOR（按位异或操作）算法计算 key 之间的“距离”。 <br /> 这种搞法使得它具备了类似于“几何距离”的某些特性（下面用 ⊕ 表示 XOR） <br />     <table border="0">
      <tbody>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">
      (A ⊕ B) == (B ⊕ A)
     </code></td>
          <td>XOR 符合“交换律”，具备对称性。相比之下，Chord 的距离算法不对称</td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">
      (A ⊕ A) == 0
     </code></td>
          <td>反身性，自身距离为零</td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">
      (A ⊕ B) &gt; 0
     </code></td>
          <td>【不同】的两个 key 之间的距离必大于零</td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">
      (A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)
     </code></td>
          <td>三角不等式</td>
        </tr>
      </tbody>
    </table>
 <br />     <h3 id="section-22"> ◇路由机制 </h3>
 <br /> <b>
   二叉树的拆分
  </b> <br /> 对每一个节点，都可以【按照自己的视角】对整个二叉树进行拆分。 <br /> 拆分的规则是：先从根节点开始，把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推，直到最后只剩下自己。 <br /> Kad 默认的散列值空间是 <code class="language-plaintext highlighter-rouge">
   m = 160
  </code> （散列值有 <code class="language-plaintext highlighter-rouge">
   160 bits
  </code> ），因此拆分出来的子树【最多】有 <code class="language-plaintext highlighter-rouge">
   160
  </code> 个（考虑到实际的节点数【远远小于】 <code class="language-plaintext highlighter-rouge">
   2
   
    160
   
  </code> ，子树的个数会明显小于 <code class="language-plaintext highlighter-rouge">
   160
  </code> ）。 <br /> 对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的【任何一个】节点（考虑到篇幅，具体的数学证明就不贴出来了） <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/-swhYfmz9nzxDcA-UBx3T_3K51szQ00WW55E6wloi0w8KJ4izyHGS7nUOuwIhB05FqtqIwb4h1wOLFY_XrCSwpVBLvhgRB1-zIeuRHrtGx4X9ShaRmNqEUraom76qJI8DNwdKUdE9Mw" /> <br /> （示意图：二叉树的拆分。 <b>
    注：图中的“第三”与“第四”应对调。非常感谢热心读者在评论区指正！
   </b> ） </center>
 <br /> <b>
   K-桶（K-bucket）
  </b> <br /> 前面说了，每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（请始终牢记：分布式系统的节点是动态变化滴），光知道【一个】显然是不够滴，需要知道【多个】才比较保险。 <br /> 所以 Kad 论文中给出了一个“K-桶（K-bucket）”的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 <code class="language-plaintext highlighter-rouge">
   K
  </code> 个节点。这里所说的 <code class="language-plaintext highlighter-rouge">
   K
  </code> 值是一个【系统级】的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 <code class="language-plaintext highlighter-rouge">
   8
  </code> ）。 <br /> 这个“K-桶”其实就是【路由表】。对于某个节点而言，如果【以它自己为视角】拆分了 <code class="language-plaintext highlighter-rouge">
   n
  </code> 个子树，那么它就需要维护 <code class="language-plaintext highlighter-rouge">
   n
  </code> 个路由表，并且每个路由表的【上限】是 <code class="language-plaintext highlighter-rouge">
   K
  </code> 。 <br /> 说 K 只是一个【上限】，是因为有两种情况使得 K 桶的尺寸会小于 K。 <br /> 1. 距离越近的子树就越小。如果整个子树【可能存在的】节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。 <br /> 2. 有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh3.googleusercontent.com/HStkGemhWzLV6GkyBPtRfQCd18dKxLrF5NeFwNFNMfjKB3RYfwLFG4lTZNNJ5J8Qi95osKfR8_H5cpRQUEMGTKAyibgL82MrnO1J_eJuP41O2wsu8ryrzhBldT1exs7X1vwQ2jZAXb8" /> <br /> （示意图：K = 2 的路由表） </center>
 <br />     <center> <img alt="不见图 请翻墙" src="https://lh6.googleusercontent.com/J9ebpRdPW788CCFetj0KJhS4mTwHGeOwppibQ2-dBuwlMWjQoKdPi5VBbWMJpI_04XYvULA3Hm4kGIQF15RSFOWkq_qI4U93V39eDHrM3lxemgESNJ8JogVIBjjGNt3EXs-141V0GBg" /> <br /> （示意图：路由过程） </center>
 <br /> <b>
   K-桶（K-bucket）的刷新机制
  </b> <br /> 刷新机制大致有如下几种： <br /> 1. 主动收集节点 <br /> 任何节点都可以主动发起“查询节点”的请求（对应于协议类型 FIND_NODE），从而刷新 K 桶中的节点信息（下面聊“节点的加入”时，会提及这种） <br /> 2. 被动收集节点 <br /> 如果收到其它节点发来的请求（协议类型 FIND_NODE 或 FIND_VALUE），会把对方的 ID 加入自己的某个 K 桶中。 <br /> 3. 探测失效节点 <br /> Kad 还是支持一种探测机制（协议类型 PING），可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点，然后把下线的节点从路由表中干掉。 <br /> <br /> <b>
   “并发请求”与“α 参数”
  </b> <br /> “K桶”的这个设计思路【天生支持并发】。因为【同一个】“K桶”中的每个节点都是平等的，没有哪个更特殊；而且对【同一个】“K桶”中的节点发起请求，互相之间没有影响（无耦合）。 <br /> 所以 Kad 协议还引入了一个“α参数/α因子”，默认设置为 <code class="language-plaintext highlighter-rouge">
   3
  </code> ，使用 Kad 的软件可以在具体使用场景中调整这个“α因子”。 <br /> 当需要路由到某个“子树”，会从该子树对应的“K桶”中挑选【α个节点】，然后对这几个节点【同时】发出请求。 <br /> 这么做有啥好处捏？俺在本文末尾聊“性能”和“安全性”时会具体介绍。 <br /> <br />     <h3 id="section-23"> ◇节点的加入 </h3>
 <br /> 1 <br /> 任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。 <br /> 2 <br /> A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计） <br /> 3 <br /> A 向 B 发起一个查询请求（协议类型 FIND_NODE），请求的 ID 是自己（通俗地说，就是查询自己） <br /> 4 <br /> B 收到该请求之后，（如前面所说）会先把 A 的 ID 加入自己的某个 K 桶中。 <br /> 然后，根据 FIND_NODE 协议的约定，B 会找到【K个】最接近 A 的节点，并返回给 A。 <br /> （B 怎么知道哪些节点接近 A 捏？这时候，【用 XOR 表示距离】的算法就发挥作用啦） <br /> 5 <br /> A 收到这 K 个节点的 ID 之后，（仅仅根据这批 ID 的值）就可以开始初始化自己的 K 桶。 <br /> 6 <br /> 然后 A 会继续向刚刚拿到的这批节点发送查询请求（协议类型 FIND_NODE），如此往复（递归），直至 A 建立了足够详细的路由表。 <br /> <br />     <h3 id="section-24"> ◇节点的退出 </h3>
 <br /> 与 Chord 不同，Kad 对于节点退出没有额外的要求（没有“主动退出”的说法）。 <br /> 所以，Kad 的节点想离开 DHT 网络【不】需要任何操作（套用徐志摩的名言： <q> 悄悄的我走了，正如我悄悄的来 </q> ） <br /> <br />     <h3 id="section-25"> ◇引申阅读 </h3>
 <br /> Kad 就介绍到这里。想要进一步了解的同学，可以参考其原创论文： <br /> 《 <a href="https://docs.google.com/document/d/1YwjPkWK8roa933-cBnqbP4FtfD_fps7_YXz2_QKyvyY/" target="_blank"> Kademlia——A Peer-to-peer Information System Based on the XOR Metric </a> 》 <br /> <br /> <br />     <h2 id="kad--dht--"> ★为啥 Kad 成为 DHT 的主流？ </h2>
 <br /> Kad 成为 DHT 的主流实现方式，这已经是很明显的事实。问题在于：为啥会是它？ <br /> 这是一个比较发散的问题，以下是俺个人观点，供参考。 <br /> <br />     <h3 id="section-26"> ◇简单性 </h3>
 <br /> 在“简单性”方面，Kad 和 Chord 都属于很简单的。所以俺要拿一个【反面教程】作为对比。 <br /> 下面俺来说说 CAN（Content Addressable Network）——它是最早出现的四个 DHT 协议之一（2001年），在学术界也算很有名气。 <br /> 介绍 CAN 的资料，通常会在开篇提到：CAN 的拓扑结构是基于【多维笛卡尔环面】。俺相信很多程序员看到这个词汇，心里会咯噔一下，脑袋会大一圈。 <br /> 和 CAN 的【多维环面】比起来，Kad 基于【二叉树】的拓扑结构，就显得异常简单、非常亲切。假如要让程序员在 “二叉树” 和 “多维笛卡尔环面” 二选一，都不用调查问卷，俺就敢打保票——超过 99% 的程序员会选择“二叉树”。 <br /> Kad 除了拓扑结构很简单，它的距离算法也很简单——只不过是节点 ID 的异或运算（XOR）。 <br /> <br /> （稍微跑题一下） <br /> 有很多充满学院派气息的系统设计，最终成为空中楼阁，就是因为：这些系统的【设计太复杂】了。当程序员对设计望而生畏，更有可能的情况是：要么没人愿意动手写，要么是有人动手写了，但是迟迟做不出来。 <br /> <br />     <h3 id="section-27"> ◇灵活性 </h3>
 <br /> 以 Kad 和 Chord 的路由表来作对比。 <br /> Kad 的“K-bucket”是可以根据使用场景来调整 K 值，而且对 K 值的调整完全不影响代码实现。这就是所谓的“适应需求的灵活性”（有时也称之为“设计的弹性”）。 <br /> 相比之下，Chord 的“Finger Table”就没有这种灵活性。 <br /> <br />     <h3 id="section-28"> ◇性能 </h3>
 <br /> Kad 的路由算法天生就支持【并发】（参见前面介绍的“α 参数”）。 <br /> 而很多 DHT 协议（包括 Chord）没有这种优势。 <br /> 由于公网上的线路具有很大的不确定性（极不稳定），哪怕是同样两个节点，之间的传输速率也可能时快时慢。由于 Kad 路由请求支持并发，发出请求的节点总是可以获得最快的那个 peer 的响应。 <br /> <br />     <h3 id="section-29"> ◇安全性 </h3>
 <br /> 考虑到本文只介绍了 Chord 和 Kad，还是拿它俩做对比。 <br /> 假设某个攻击者想要搞 Chord 网络的某个节点（假设叫 A），他/她可以先获得此 节点A 的 ID（这并不难）。知道 节点A 的 ID 后，攻击者就可以运行若干个受控的 Chord 节点（恶意节点），并且精心设置这批恶意节点的 ID；当这批恶意节点加入 Chord 网络后，就可以顺利被添加到 节点A 的路由表中（具体的原理，参见前面对“Finger Table”的介绍）。一旦 节点A 的路由表加入【足够多】的恶意节点，那么 节点A 的路由就有【足够大】的概率会经过这批恶意节点。攻击者作为这批恶意节点的控制人，就可以对 节点A 做很多手脚。 <br /> <br /> 从理论上讲，类似的手法也可以用来针对 Kad。但是攻击难度会显著变大。原因如下： <br /> 1 <br /> Kad 协议缺省约定——在线时间越长的节点越可能被加入“K桶”。所以攻击者哪怕构造了一批恶意节点，这些恶意节点要想被正常节点加入自己的“K桶”，难度也很大。 <br /> 2 <br /> 就算某个恶意节点（比如叫 X）被正常节点（比如叫 A）加入“K-桶”。由于一个“K-桶”只对应【一个子树】。所以，只有当 节点A 在针对某个【特定子树】进行路由的时候，才【有可能】会碰上这个恶意节点。 <br /> （唠叨一下：Kad 的路由算法中，对每个子树都维护一个“K-桶”作为路由表） <br /> 3 <br /> 即便正好对这个子树路由，也【不一定】会碰上恶意节点——碰上的【概率】取决于：“K 的大小” 以及 “从桶中选取节点的策略”。 <br /> 4 <br /> 前面提到：Kad 协议支持【并发查询】——每次都会从同一个“K-桶”中取出【α个】节点，发出查询请求（参数 α 默认设为 3,可以调大） <br /> 所以，这【α 个节点】中，如果只有一个是恶意的，这个恶意节点也很难捣乱；除非这【α 个节点】全部都是恶意的，而这个概率又很小。 <br /> <br /> （注：俺并【没有】说 Kad 是最安全的。这段介绍只能让你体会一下“K-桶”的设计思路——除了增加性能，还顺便增加了攻击者的难度） <br /> <br />     <h3 id="section-30"> ◇小结 </h3>
 <br /> 刚才聊的这几个方面，对每一个方面，Kad 未必能排第一，但至少它都能排进前几名。 <br /> 几个方面综合起来，它就成为最有竞争力和活力的 DHT 技术方案。 <br /> <br /> <br />     <h2 id="section-31"> ★结尾 </h2>
 <br /> 刚才聊到了“安全性”，本来还想再写一个章节，谈谈“针对 DHT 网络的攻击手法”。不过捏，本文已经写了很长，为了照顾某些患有“阅读障碍症”的读者，就先到此为止吧。今后另外找时间谈“攻击 DHT”这个话题。 <br /> 由于本文的某些内容，俺也是现学现卖。如有错漏之处，还望懂行的同学不吝赐教 :) <br /> <br /> <br /> <b>
   俺博客上，和本文相关的帖子（需翻墙）
  </b> ： <br /> <a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html"> 扫盲文件完整性校验——关于散列值和数字签名 </a> <br /> <a href="https://program-think.blogspot.com/2017/08/GFW-Resilio-Sync.html"> 聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？ </a> <br /> <a href="https://program-think.blogspot.com/2012/06/gfw-i2p.html"> “如何翻墙”系列：简单扫盲 I2P 的使用 </a> <br /> <a href="https://program-think.blogspot.com/2015/08/Technology-and-Freedom.html"> “对抗专制、捍卫自由”的 N 种技术力量 </a> <br /> <a href="https://program-think.blogspot.com/2015/04/Single-Point-of-Failure.html"> 聊聊“单点故障”——关于“德国空难”和“李光耀”的随想 </a>     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2017-10-11</time>
        <a href="https://nodebe4.github.io/opinion/2017-10-11/2017%E5%B9%B410%E6%9C%88%E7%BF%BB%E5%A2%99%E5%BF%AB%E6%8A%A5-%E5%85%BC%E8%B0%88%E7%94%A8-I2P-%E7%AA%81%E7%A0%B4%E5%B0%81%E9%94%81/">
          2017年10月翻墙快报（兼谈用 I2P 突破封锁）
        </a>
      </li>
    
    
      <li>
        <time>2017-09-30</time>
        <a href="https://nodebe4.github.io/opinion/2017-09-30/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E4%B9%A0%E5%91%86%E5%91%86%E4%B8%8A%E5%8F%B0%E4%BA%94%E5%91%A8%E5%B9%B4-%E7%B3%97%E4%BA%8B%E4%B8%80%E7%AE%A9%E7%AD%90-%E5%9B%BE%E7%89%87%E5%8F%8A%E7%BD%91%E5%8F%8B%E8%AF%84%E8%AE%BA/">
          每周转载：习呆呆上台五周年，糗事一箩筐（图片及网友评论）
        </a>
      </li>
    
    
      <li>
        <time>2017-09-11</time>
        <a href="https://nodebe4.github.io/opinion/2017-09-11/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E6%9C%9D%E9%B2%9C%E8%AF%95%E7%88%86%E6%B0%A2%E5%BC%B9-%E5%90%84%E6%96%B9%E7%9A%84%E6%8A%A5%E9%81%93%E5%8F%8A%E8%AF%84%E8%AE%BA/">
          每周转载：朝鲜试爆氢弹（各方的报道及评论）
        </a>
      </li>
    
    
      <li>
        <time>2017-08-30</time>
        <a href="https://nodebe4.github.io/opinion/2017-08-30/%E8%81%8A%E8%81%8A-GFW-%E5%A6%82%E4%BD%95%E5%B0%81%E6%9D%80-Resilio-Sync-BTSync-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95-%E5%85%8D%E7%BF%BB%E5%A2%99-%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8/">
          聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2017-09-21/%E6%9D%8E%E4%BC%9F%E4%B8%9C-%E5%8D%81%E4%B9%9D%E5%A4%A7%E4%BF%AE%E6%94%B9%E5%85%9A%E7%AB%A0-%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%9D%E6%83%B3%E5%91%BC%E4%B9%8B%E6%AC%B2%E5%87%BA/">
            前一篇：李伟东：十九大修改党章，习近平思想呼之欲出？
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2017-09-22/%E4%BC%8A%E5%88%A9%E5%A4%8F%E6%8F%90-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%94%9F%E5%91%BD%E5%8E%BB%E6%8D%8D%E5%8D%AB%E7%BB%B4%E5%90%BE%E5%B0%94%E6%97%8F%E8%AF%AD%E8%A8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%AF%8D%E8%AF%AD%E7%9A%84%E6%96%B0%E7%96%86%E5%B0%B1%E4%B8%8D%E5%86%8D%E6%9C%89%E9%98%BF%E5%87%A1%E6%8F%90%E7%9A%84%E6%95%85%E4%BA%8B/">
            後一篇：伊利夏提：为什么要用生命去捍卫维吾尔族语言？为什么没有母语的新疆就不再有阿凡提的故事？
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2017-09-21/%E6%9D%8E%E4%BC%9F%E4%B8%9C-%E5%8D%81%E4%B9%9D%E5%A4%A7%E4%BF%AE%E6%94%B9%E5%85%9A%E7%AB%A0-%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%9D%E6%83%B3%E5%91%BC%E4%B9%8B%E6%AC%B2%E5%87%BA/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2017-09-22/%E4%BC%8A%E5%88%A9%E5%A4%8F%E6%8F%90-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%94%9F%E5%91%BD%E5%8E%BB%E6%8D%8D%E5%8D%AB%E7%BB%B4%E5%90%BE%E5%B0%94%E6%97%8F%E8%AF%AD%E8%A8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%AF%8D%E8%AF%AD%E7%9A%84%E6%96%B0%E7%96%86%E5%B0%B1%E4%B8%8D%E5%86%8D%E6%9C%89%E9%98%BF%E5%87%A1%E6%8F%90%E7%9A%84%E6%95%85%E4%BA%8B/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2017-09-30/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E4%B9%A0%E5%91%86%E5%91%86%E4%B8%8A%E5%8F%B0%E4%BA%94%E5%91%A8%E5%B9%B4-%E7%B3%97%E4%BA%8B%E4%B8%80%E7%AE%A9%E7%AD%90-%E5%9B%BE%E7%89%87%E5%8F%8A%E7%BD%91%E5%8F%8B%E8%AF%84%E8%AE%BA/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2017-09-11/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E6%9C%9D%E9%B2%9C%E8%AF%95%E7%88%86%E6%B0%A2%E5%BC%B9-%E5%90%84%E6%96%B9%E7%9A%84%E6%8A%A5%E9%81%93%E5%8F%8A%E8%AF%84%E8%AE%BA/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2017-09-21/%E6%9D%8E%E4%BC%9F%E4%B8%9C-%E5%8D%81%E4%B9%9D%E5%A4%A7%E4%BF%AE%E6%94%B9%E5%85%9A%E7%AB%A0-%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%9D%E6%83%B3%E5%91%BC%E4%B9%8B%E6%AC%B2%E5%87%BA/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2017-09-22/%E4%BC%8A%E5%88%A9%E5%A4%8F%E6%8F%90-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%94%9F%E5%91%BD%E5%8E%BB%E6%8D%8D%E5%8D%AB%E7%BB%B4%E5%90%BE%E5%B0%94%E6%97%8F%E8%AF%AD%E8%A8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%AF%8D%E8%AF%AD%E7%9A%84%E6%96%B0%E7%96%86%E5%B0%B1%E4%B8%8D%E5%86%8D%E6%9C%89%E9%98%BF%E5%87%A1%E6%8F%90%E7%9A%84%E6%95%85%E4%BA%8B/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2017-09-30/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E4%B9%A0%E5%91%86%E5%91%86%E4%B8%8A%E5%8F%B0%E4%BA%94%E5%91%A8%E5%B9%B4-%E7%B3%97%E4%BA%8B%E4%B8%80%E7%AE%A9%E7%AD%90-%E5%9B%BE%E7%89%87%E5%8F%8A%E7%BD%91%E5%8F%8B%E8%AF%84%E8%AE%BA/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2017-09-11/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E6%9C%9D%E9%B2%9C%E8%AF%95%E7%88%86%E6%B0%A2%E5%BC%B9-%E5%90%84%E6%96%B9%E7%9A%84%E6%8A%A5%E9%81%93%E5%8F%8A%E8%AF%84%E8%AE%BA/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
