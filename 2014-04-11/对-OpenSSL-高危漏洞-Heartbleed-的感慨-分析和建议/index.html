<!DOCTYPE html>
<html>
  <head>
  <title>对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议  
  
    
      
    
  
  
4月7日曝光的 Heartbleed 漏洞（编号CVE-2014-0160）已经在相关的 IT 领域（尤其是信息安全领域）造成很大的风波。在安全圈混了十多年，不写点啥有些说不过去。所以今天就这个话题，谈谈俺个人的观点，并给普通用户、程序员、开源社区、安全从业人员 分别提点建议。 
       
         
        ★关于 Heartbleed 漏洞 
  这个 Heartbleed，直译成中文就是“心脏出血”。听上去挺吓人滴，现实中也确实挺吓人滴。简而言之，这个漏洞足以载入史册。这几天，大伙儿正在经历信息安全历史上的一个重要时刻。或许你应该觉得荣幸 :)  关于这个漏洞的描述，请看中文维基百科的“  这里  ”，俺就不浪费口水了。         ★先发点感慨 
  先发一通抱怨。不喜欢听俺抱怨的，请直接略过。        ◇安全行业的耻辱 
  对整个安全行业而言，这是巨大的耻辱。  OpenSSL 是安全行业内应用非常广泛的开源加密库。一个用来保护安全的软件包，本身居然出现如此严重的漏洞（导致内存信息泄漏），实在太讽刺了。  耻辱的还不光是 OpenSSL——就在一个月之前，GnuTLS 同样出现过高危漏洞（编号 CVE-2014-0092）。这么短的时间之内，涉及到加密的两个最常用的基础库接连爆出高危漏洞，俺不禁要问：整个安全行业的面子要往哪儿搁？        ◇开源社区的耻辱 
  对整个开源社区而言，这是巨大的耻辱。  OpenSSL 作为非常知名的开源项目之一，这么严重的漏洞居然两年后才曝光（2012年3月的稳定版就已经包含此漏洞）。难道关键模块的代码变更之后不进行【Code Review】？亦或是 Code Review 只是走过场？         ★对该漏洞的风险评估 
  该漏洞曝光前后，风险是不同滴。以下俺分别介绍。  下面会涉及两个术语——“未公开漏洞”和“零日漏洞”——两者的区别请看  俺之前的博文  。        ◇漏洞曝光【之前】——作为“未公开漏洞” 
  目前已经有报道指出，在4月7日之前，这个漏洞就已经被骇客利用（报道在“  这里  ”）。另外，圈内也有小道消息流传，说某些攻击者早已拿到此漏洞并加以利用。  在这个阶段，知道漏洞的人很少。这时候，该漏洞属于“宝贵资源”，掌握它的人只会拿来攻击“高价值目标”。所以，如果你只是一个普通网友，或者只是一个小型网站，通常不用担心这个阶段的风险。        ◇漏洞曝光【之后】——作为“零日漏洞” 
  4月7日那天，OpenSSL 发布了公告。发现漏洞的 CloudFlare 公司也发布了公告。于是这个漏洞瞬间传遍全球。几小时之内，大量的攻击工具应运而生（这个漏洞太容易利用了）。然后大量的“脚本小子”（洋文叫“script kiddie”）就拿着这些别人写好的工具，对大量的网站进行扫描。  由于时差的关系，以及某些大公司的官僚风气，很多网站来不及在第一时间升级 OpenSSL 这个软件包（这就是所谓的“零日风险”）。估计某些效率低下的公司，甚至到今天都还没升级。  在这个阶段，对于普通网友  假设你登录过某个网站  假设该网站没有及时升级 OpenSSL  假设该网站存储的是【明文密码】 或者 该网站只在【服务端】加密/Hash密码  假设在你登录期间正好有人利用该漏洞进行信息收集  如果上述几个条件【同时】成立，那么你的密码【有一定的概率】可能被攻击者收集到。         ★对该漏洞的技术分析 
  （本节聊的是该漏洞在技术层面的细节。对 C 语言了解不多的同学，请自行略过，以免浪费时间）  这个漏洞从本质上讲，就是“缓冲区溢出（buffer overflow）”。几乎所有这类漏洞的根源，都是由于程序员的疏忽——对缓冲区涉及的相关“长度”没有仔细检查。  已经有老外写了详细的 Heartbleed 漏洞分析文档（洋文在“  这里  ”）。对于懒得看长篇的同学，俺把精华摘录如下：  问题出在 OpenSSL 中的 ssl/d1_both.c 文件中的 dtls1_process_heartbeat 函数（看名称就知道该函数是干啥滴）。相关代码有如下（俺补了中文注释）      
      int dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;  // p 指向对端发来的心跳数据包
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
    ......
    hbtype = *p++;  // 心跳数据包的第0个字节，表示心跳包的类型
    n2s(p, payload);  // 后面2字节是长度。n2s 这个宏把这2字节取出为整型，然后指针移2字节
    pl = p;  // 此时 p 指向第3个字节——也就是对端提供的心跳包载荷
    ......
    unsigned char *buffer, *bp;
    int r;
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);  // 多出的3字节用于存放类型和长度
    bp = buffer;
    ......
    *bp++ = TLS1_HB_RESPONSE;  // 填充类型
    s2n(payload, bp);  // 填充长度
    memcpy(bp, pl, payload);  // 填充回应包的载荷【亮点在这里】
      
    
  如果对端发来的心跳包有猫腻——包长度跟实际载荷不匹配，那么在发送回应包的时候，那句 memcpy 语句就会把心跳包之后的内存区块也一起 copy 进去，然后发给对端。内存信息就泄露了。  搞清楚问题的根源之后，补丁其实很简单——只需加入2个判断语句（寥寥4行代码）。      
      if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度为 0 的心跳包
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度与载荷不匹配的心跳包
pl = p;
      
    
       ★给普通用户的建议 
  前面的“风险评估”已经分析了——对于普通网友而言，你的风险主要在于“漏洞曝光之后那1-2天”（也就是“0day”导致的风险）。  从4月7日开始的这几天（尤其是4月8日和4月9日），如果你曾经登录过某个重要的帐号，为了以防万一，改一下密码。国内的很多大网站（包括：电子邮件、电子商务、网银、社交网络、等等）都被发现有 Heartbleed 漏洞。  不过值得庆幸的是，Google 应该没事。根据 OpenSSL 官方的公告（链接在“  这里  ”），漏洞的发现者之一 Neel Mehta 是 Google 的人。所以，俺非常确信，Google 的服务器肯定在4月7日之前就解决此问题了。         ★给程序员/架构师的建议 
       ◇“多进程”在安全方面的优点 
  刚开博的头一个季度，俺就发过一篇帖子《  架构设计：进程还是线程？是一个问题！  》，其中提到了多进程的若干优点。今天再来老调重弹，说说“多进程”在安全方面的优点。  
   针对“缓冲区溢出”
    绝大多数的“缓冲区溢出攻击”，都只对当前进程有效。如果你的系统切分成若干个进程，一旦不幸碰上这类攻击，顶多只有一个进程出问题——不至于死得太难看。  不少程序员存在一个误解：以为只有 C/C++ 才会存在缓冲区溢出。其实不然。像 Java/Python 之类的，虽然没有原生的指针，虽然语言的虚拟机/解释器本身对缓冲区越界有严格的检查。但是不要忘了：这些语言的虚拟机/解释器本身也是用 C/C++ 来编写的。说不定虚拟机自己就有问题。  
   针对“信息泄露”
    这次的“Heartbleed漏洞”，从技术上讲属于“缓冲区溢出”类型，从逻辑讲属于“信息泄漏”类型。  如果整个系统切分成很多轻量级的进程，每个进程包含的内存信息自然就少了。一旦出现“信息泄漏”的漏洞，损失会小很多。  
   针对“拒绝服务”
    多进程除了可以降低上述两类的受伤程度，还可以降低“拒绝服务攻击”导致的受伤程度。  比如某些漏洞通过让“进程崩溃”来起到“拒绝服务”的效果。如果系统的架构是多进程的，并且相关进程具有一定的自我恢复机制，那么就可以降低这类攻击造成的伤害程度。        ◇关于密码的“客户端加密/散列” 
  如今比较成熟的网站，应该不会采用“明文”的方式存储用户密码了。很多程序员/架构师都明白，要把用户密码进行散列（Hash）之后再存储。但是这里面有一个细节，很多人忽略了。那就是：“服务端散列”vs“客户端散列”？   
   “服务端散列”和“客户端散列”的差异
    所谓的“服务端散列”就是：用户输入密码之后，以明文的方式传送到服务端，然后在服务端进行散列，散列的结果保存到数据库。  所谓的“客户端散列”就是：用户输入密码之后，现在浏览器这端用 JavaScript 计算散列值，然后把算好的散列值传送到服务端，再保存到数据库。   
   HTTPS 可能出现的问题
    到目前为止，大多数网站（包括很多大型网站）还是采用服务端散列。其实捏，“客户端散列”比“服务器散列”的安全性更好。为啥捏？  对于成熟的大型网站，虽然用户登录过程都是基于加密 HTTPS 传输。但是 HTTPS 不是绝对安全的。俺相信 HTTPS 协议本身的设计是很完备的，但是“协议没问题”不等于“整个HTTPS传输没问题”。整个 HTTPS 传输，可能出问题的环节如下：  
   1. 软件可能出问题
    比如这次的 Heartbleed 漏洞，就属于典型的“基础软件库出问题”  
   2. 中间人攻击（比如证书出问题）
    因为 HTTPS 的加密需要依赖于证书体系。如果证书体系出问题就没戏了。  说两种常见的可能性。  可能性之一：某个 CA 的根证书私钥被盗，那么盗用者就可以随意伪造CA证书。真实的案例是 2011年 DigiNotar 被入侵。  可能性之二：某个 CA 自己就不检点。最贴切的例子非 CNNIC 莫属。这方面的介绍请参见俺4年前的博文《  CNNIC 干过的那些破事儿  》、《  CNNIC 证书的危害及各种清除方法  》   
   “客户端散列”的优点
    看完上述介绍，你应该明白，这几个环节出问题，都有可能让攻击者收集到传输过程中的【明文】密码。如果密码已经在客户端进行散列，那么风险就降低很多（但不是完全降为零，后面会提到）。  要采用“客户端散列”，有经验的开发人员会对密码进行【撒盐】的散列处理，并且精心选择合适的散列算法（速度足够慢）。如此一来，即使攻击者拿到散列结果，也非常非常难逆向推导出原始的密码。   
   “客户端散列”的局限性
    （看到几条读者留言，补充了本小节）  1、“客户端加密/散列”并不能保证绝对的安全（“绝对安全”是不存在滴）。采用“客户端加密/散列”的前提是——页面的JS代码一定采用可信任的方式传输（HTTPS传输）而不能采用明文的 HTTP 传输。因为 HTTP 传输过程，传输内容是可以被篡改的。如果采用 HTTP 明文传输，万一攻击者篡改了客户端的 JS 脚本，还是会导致密码泄漏。  2、HTTPS 通道出现的安全漏洞，大致可以分为两类：一类是攻击者可以窥探到传输内容，但无法修改传输内容（比如这次的 Heartbleed 漏洞属于此类）；还有一类是攻击者可以篡改内容（比如像 CNNIC 这类流氓 CA 就有条件做到这点）。对于前者，骇客无法突破“客户端加密”的防护；对于后者，骇客可以突破。         ★给有志于成为黑客的同学的建议 
  先声明：“黑客”与“骇客”是【完全不同】的两类人。俺之前发过一篇《  每周转载：关于黑客文化和黑客精神  》，或许有助于你了解两者的差异。  俺敢跟任何人打赌，OpenSSL 和 GnuTLS 的代码中，类似的低级错误还有好多。而且 GnuTLS 可能比 OpenSSL 还多。有志于成为黑客的同学，可以考虑去分析这俩的代码，找出其中的漏洞。  通过上面那段代码分析，你应该会意识到：这个漏洞本身并没有涉及到多么高深的 C 语法或技巧。那么，发现该漏洞的难点在哪里捏？俺觉得难在：  1. 对整体结构的把握  因为 OpenSSL 和 GnuTLS 的代码量还是比较庞大的。很少有人能把握整体的结构。  2. 对相关协议的了解  想通过看代码分析这两个软件的漏洞，你还需要对相关的协议很熟悉。比如这次的漏洞，就涉及到“心跳协议”的细节。  3. 耐心/恒心  同时具备上述两条的人本来就不多。然后捏，这些人还未必有足够的耐心去把整个代码（哪怕是其中某个模块的代码）通读一遍。  （第三点或许才是最难的）   如果能够搞定上述三点，并且你的运气足够好，那么你有望独立发现一个高危漏洞。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲 HTTPS 和 SSL/TLS 协议（系列）    如何防止骇客入侵（系列）    CNNIC 干过的那些破事儿    CNNIC 证书的危害及各种清除方法    每周转载：关于黑客文化和黑客精神    架构设计：进程还是线程？是一个问题！      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/04/openssl-heartbleed.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议  
  
    
      
    
  
  
4月7日曝光的 Heartbleed 漏洞（编号CVE-2014-0160）已经在相关的 IT 领域（尤其是信息安全领域）造成很大的风波。在安全圈混了十多年，不写点啥有些说不过去。所以今天就这个话题，谈谈俺个人的观点，并给普通用户、程序员、开源社区、安全从业人员 分别提点建议。 
       
         
        ★关于 Heartbleed 漏洞 
  这个 Heartbleed，直译成中文就是“心脏出血”。听上去挺吓人滴，现实中也确实挺吓人滴。简而言之，这个漏洞足以载入史册。这几天，大伙儿正在经历信息安全历史上的一个重要时刻。或许你应该觉得荣幸 :)  关于这个漏洞的描述，请看中文维基百科的“  这里  ”，俺就不浪费口水了。         ★先发点感慨 
  先发一通抱怨。不喜欢听俺抱怨的，请直接略过。        ◇安全行业的耻辱 
  对整个安全行业而言，这是巨大的耻辱。  OpenSSL 是安全行业内应用非常广泛的开源加密库。一个用来保护安全的软件包，本身居然出现如此严重的漏洞（导致内存信息泄漏），实在太讽刺了。  耻辱的还不光是 OpenSSL——就在一个月之前，GnuTLS 同样出现过高危漏洞（编号 CVE-2014-0092）。这么短的时间之内，涉及到加密的两个最常用的基础库接连爆出高危漏洞，俺不禁要问：整个安全行业的面子要往哪儿搁？        ◇开源社区的耻辱 
  对整个开源社区而言，这是巨大的耻辱。  OpenSSL 作为非常知名的开源项目之一，这么严重的漏洞居然两年后才曝光（2012年3月的稳定版就已经包含此漏洞）。难道关键模块的代码变更之后不进行【Code Review】？亦或是 Code Review 只是走过场？         ★对该漏洞的风险评估 
  该漏洞曝光前后，风险是不同滴。以下俺分别介绍。  下面会涉及两个术语——“未公开漏洞”和“零日漏洞”——两者的区别请看  俺之前的博文  。        ◇漏洞曝光【之前】——作为“未公开漏洞” 
  目前已经有报道指出，在4月7日之前，这个漏洞就已经被骇客利用（报道在“  这里  ”）。另外，圈内也有小道消息流传，说某些攻击者早已拿到此漏洞并加以利用。  在这个阶段，知道漏洞的人很少。这时候，该漏洞属于“宝贵资源”，掌握它的人只会拿来攻击“高价值目标”。所以，如果你只是一个普通网友，或者只是一个小型网站，通常不用担心这个阶段的风险。        ◇漏洞曝光【之后】——作为“零日漏洞” 
  4月7日那天，OpenSSL 发布了公告。发现漏洞的 CloudFlare 公司也发布了公告。于是这个漏洞瞬间传遍全球。几小时之内，大量的攻击工具应运而生（这个漏洞太容易利用了）。然后大量的“脚本小子”（洋文叫“script kiddie”）就拿着这些别人写好的工具，对大量的网站进行扫描。  由于时差的关系，以及某些大公司的官僚风气，很多网站来不及在第一时间升级 OpenSSL 这个软件包（这就是所谓的“零日风险”）。估计某些效率低下的公司，甚至到今天都还没升级。  在这个阶段，对于普通网友  假设你登录过某个网站  假设该网站没有及时升级 OpenSSL  假设该网站存储的是【明文密码】 或者 该网站只在【服务端】加密/Hash密码  假设在你登录期间正好有人利用该漏洞进行信息收集  如果上述几个条件【同时】成立，那么你的密码【有一定的概率】可能被攻击者收集到。         ★对该漏洞的技术分析 
  （本节聊的是该漏洞在技术层面的细节。对 C 语言了解不多的同学，请自行略过，以免浪费时间）  这个漏洞从本质上讲，就是“缓冲区溢出（buffer overflow）”。几乎所有这类漏洞的根源，都是由于程序员的疏忽——对缓冲区涉及的相关“长度”没有仔细检查。  已经有老外写了详细的 Heartbleed 漏洞分析文档（洋文在“  这里  ”）。对于懒得看长篇的同学，俺把精华摘录如下：  问题出在 OpenSSL 中的 ssl/d1_both.c 文件中的 dtls1_process_heartbeat 函数（看名称就知道该函数是干啥滴）。相关代码有如下（俺补了中文注释）      
      int dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;  // p 指向对端发来的心跳数据包
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
    ......
    hbtype = *p++;  // 心跳数据包的第0个字节，表示心跳包的类型
    n2s(p, payload);  // 后面2字节是长度。n2s 这个宏把这2字节取出为整型，然后指针移2字节
    pl = p;  // 此时 p 指向第3个字节——也就是对端提供的心跳包载荷
    ......
    unsigned char *buffer, *bp;
    int r;
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);  // 多出的3字节用于存放类型和长度
    bp = buffer;
    ......
    *bp++ = TLS1_HB_RESPONSE;  // 填充类型
    s2n(payload, bp);  // 填充长度
    memcpy(bp, pl, payload);  // 填充回应包的载荷【亮点在这里】
      
    
  如果对端发来的心跳包有猫腻——包长度跟实际载荷不匹配，那么在发送回应包的时候，那句 memcpy 语句就会把心跳包之后的内存区块也一起 copy 进去，然后发给对端。内存信息就泄露了。  搞清楚问题的根源之后，补丁其实很简单——只需加入2个判断语句（寥寥4行代码）。      
      if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度为 0 的心跳包
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度与载荷不匹配的心跳包
pl = p;
      
    
       ★给普通用户的建议 
  前面的“风险评估”已经分析了——对于普通网友而言，你的风险主要在于“漏洞曝光之后那1-2天”（也就是“0day”导致的风险）。  从4月7日开始的这几天（尤其是4月8日和4月9日），如果你曾经登录过某个重要的帐号，为了以防万一，改一下密码。国内的很多大网站（包括：电子邮件、电子商务、网银、社交网络、等等）都被发现有 Heartbleed 漏洞。  不过值得庆幸的是，Google 应该没事。根据 OpenSSL 官方的公告（链接在“  这里  ”），漏洞的发现者之一 Neel Mehta 是 Google 的人。所以，俺非常确信，Google 的服务器肯定在4月7日之前就解决此问题了。         ★给程序员/架构师的建议 
       ◇“多进程”在安全方面的优点 
  刚开博的头一个季度，俺就发过一篇帖子《  架构设计：进程还是线程？是一个问题！  》，其中提到了多进程的若干优点。今天再来老调重弹，说说“多进程”在安全方面的优点。  
   针对“缓冲区溢出”
    绝大多数的“缓冲区溢出攻击”，都只对当前进程有效。如果你的系统切分成若干个进程，一旦不幸碰上这类攻击，顶多只有一个进程出问题——不至于死得太难看。  不少程序员存在一个误解：以为只有 C/C++ 才会存在缓冲区溢出。其实不然。像 Java/Python 之类的，虽然没有原生的指针，虽然语言的虚拟机/解释器本身对缓冲区越界有严格的检查。但是不要忘了：这些语言的虚拟机/解释器本身也是用 C/C++ 来编写的。说不定虚拟机自己就有问题。  
   针对“信息泄露”
    这次的“Heartbleed漏洞”，从技术上讲属于“缓冲区溢出”类型，从逻辑讲属于“信息泄漏”类型。  如果整个系统切分成很多轻量级的进程，每个进程包含的内存信息自然就少了。一旦出现“信息泄漏”的漏洞，损失会小很多。  
   针对“拒绝服务”
    多进程除了可以降低上述两类的受伤程度，还可以降低“拒绝服务攻击”导致的受伤程度。  比如某些漏洞通过让“进程崩溃”来起到“拒绝服务”的效果。如果系统的架构是多进程的，并且相关进程具有一定的自我恢复机制，那么就可以降低这类攻击造成的伤害程度。        ◇关于密码的“客户端加密/散列” 
  如今比较成熟的网站，应该不会采用“明文”的方式存储用户密码了。很多程序员/架构师都明白，要把用户密码进行散列（Hash）之后再存储。但是这里面有一个细节，很多人忽略了。那就是：“服务端散列”vs“客户端散列”？   
   “服务端散列”和“客户端散列”的差异
    所谓的“服务端散列”就是：用户输入密码之后，以明文的方式传送到服务端，然后在服务端进行散列，散列的结果保存到数据库。  所谓的“客户端散列”就是：用户输入密码之后，现在浏览器这端用 JavaScript 计算散列值，然后把算好的散列值传送到服务端，再保存到数据库。   
   HTTPS 可能出现的问题
    到目前为止，大多数网站（包括很多大型网站）还是采用服务端散列。其实捏，“客户端散列”比“服务器散列”的安全性更好。为啥捏？  对于成熟的大型网站，虽然用户登录过程都是基于加密 HTTPS 传输。但是 HTTPS 不是绝对安全的。俺相信 HTTPS 协议本身的设计是很完备的，但是“协议没问题”不等于“整个HTTPS传输没问题”。整个 HTTPS 传输，可能出问题的环节如下：  
   1. 软件可能出问题
    比如这次的 Heartbleed 漏洞，就属于典型的“基础软件库出问题”  
   2. 中间人攻击（比如证书出问题）
    因为 HTTPS 的加密需要依赖于证书体系。如果证书体系出问题就没戏了。  说两种常见的可能性。  可能性之一：某个 CA 的根证书私钥被盗，那么盗用者就可以随意伪造CA证书。真实的案例是 2011年 DigiNotar 被入侵。  可能性之二：某个 CA 自己就不检点。最贴切的例子非 CNNIC 莫属。这方面的介绍请参见俺4年前的博文《  CNNIC 干过的那些破事儿  》、《  CNNIC 证书的危害及各种清除方法  》   
   “客户端散列”的优点
    看完上述介绍，你应该明白，这几个环节出问题，都有可能让攻击者收集到传输过程中的【明文】密码。如果密码已经在客户端进行散列，那么风险就降低很多（但不是完全降为零，后面会提到）。  要采用“客户端散列”，有经验的开发人员会对密码进行【撒盐】的散列处理，并且精心选择合适的散列算法（速度足够慢）。如此一来，即使攻击者拿到散列结果，也非常非常难逆向推导出原始的密码。   
   “客户端散列”的局限性
    （看到几条读者留言，补充了本小节）  1、“客户端加密/散列”并不能保证绝对的安全（“绝对安全”是不存在滴）。采用“客户端加密/散列”的前提是——页面的JS代码一定采用可信任的方式传输（HTTPS传输）而不能采用明文的 HTTP 传输。因为 HTTP 传输过程，传输内容是可以被篡改的。如果采用 HTTP 明文传输，万一攻击者篡改了客户端的 JS 脚本，还是会导致密码泄漏。  2、HTTPS 通道出现的安全漏洞，大致可以分为两类：一类是攻击者可以窥探到传输内容，但无法修改传输内容（比如这次的 Heartbleed 漏洞属于此类）；还有一类是攻击者可以篡改内容（比如像 CNNIC 这类流氓 CA 就有条件做到这点）。对于前者，骇客无法突破“客户端加密”的防护；对于后者，骇客可以突破。         ★给有志于成为黑客的同学的建议 
  先声明：“黑客”与“骇客”是【完全不同】的两类人。俺之前发过一篇《  每周转载：关于黑客文化和黑客精神  》，或许有助于你了解两者的差异。  俺敢跟任何人打赌，OpenSSL 和 GnuTLS 的代码中，类似的低级错误还有好多。而且 GnuTLS 可能比 OpenSSL 还多。有志于成为黑客的同学，可以考虑去分析这俩的代码，找出其中的漏洞。  通过上面那段代码分析，你应该会意识到：这个漏洞本身并没有涉及到多么高深的 C 语法或技巧。那么，发现该漏洞的难点在哪里捏？俺觉得难在：  1. 对整体结构的把握  因为 OpenSSL 和 GnuTLS 的代码量还是比较庞大的。很少有人能把握整体的结构。  2. 对相关协议的了解  想通过看代码分析这两个软件的漏洞，你还需要对相关的协议很熟悉。比如这次的漏洞，就涉及到“心跳协议”的细节。  3. 耐心/恒心  同时具备上述两条的人本来就不多。然后捏，这些人还未必有足够的耐心去把整个代码（哪怕是其中某个模块的代码）通读一遍。  （第三点或许才是最难的）   如果能够搞定上述三点，并且你的运气足够好，那么你有望独立发现一个高危漏洞。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲 HTTPS 和 SSL/TLS 协议（系列）    如何防止骇客入侵（系列）    CNNIC 干过的那些破事儿    CNNIC 证书的危害及各种清除方法    每周转载：关于黑客文化和黑客精神    架构设计：进程还是线程？是一个问题！      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/04/openssl-heartbleed.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议" />
    <meta property="twitter:title" content="对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17489)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2014%2F04%2Fopenssl-heartbleed.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html&text=对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html&title=对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html&title=对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议&body=

      对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议  
  
    
      
    
  
  
4月7日曝光的 Heartbleed 漏洞（编号CVE-2014-0160）已经在相关的 IT 领域（尤其是信息安全领域）造成很大的风波。在安全圈混了十多年，不写点啥有些说不过去。所以今天就这个话题，谈谈俺个人的观点，并给普通用户、程序员、开源社区、安全从业人员 分别提点建议。 
       
         
        ★关于 Heartbleed 漏洞 
  这个 Heartbleed，直译成中文就是“心脏出血”。听上去挺吓人滴，现实中也确实挺吓人滴。简而言之，这个漏洞足以载入史册。这几天，大伙儿正在经历信息安全历史上的一个重要时刻。或许你应该觉得荣幸 :)  关于这个漏洞的描述，请看中文维基百科的“  这里  ”，俺就不浪费口水了。         ★先发点感慨 
  先发一通抱怨。不喜欢听俺抱怨的，请直接略过。        ◇安全行业的耻辱 
  对整个安全行业而言，这是巨大的耻辱。  OpenSSL 是安全行业内应用非常广泛的开源加密库。一个用来保护安全的软件包，本身居然出现如此严重的漏洞（导致内存信息泄漏），实在太讽刺了。  耻辱的还不光是 OpenSSL——就在一个月之前，GnuTLS 同样出现过高危漏洞（编号 CVE-2014-0092）。这么短的时间之内，涉及到加密的两个最常用的基础库接连爆出高危漏洞，俺不禁要问：整个安全行业的面子要往哪儿搁？        ◇开源社区的耻辱 
  对整个开源社区而言，这是巨大的耻辱。  OpenSSL 作为非常知名的开源项目之一，这么严重的漏洞居然两年后才曝光（2012年3月的稳定版就已经包含此漏洞）。难道关键模块的代码变更之后不进行【Code Review】？亦或是 Code Review 只是走过场？         ★对该漏洞的风险评估 
  该漏洞曝光前后，风险是不同滴。以下俺分别介绍。  下面会涉及两个术语——“未公开漏洞”和“零日漏洞”——两者的区别请看  俺之前的博文  。        ◇漏洞曝光【之前】——作为“未公开漏洞” 
  目前已经有报道指出，在4月7日之前，这个漏洞就已经被骇客利用（报道在“  这里  ”）。另外，圈内也有小道消息流传，说某些攻击者早已拿到此漏洞并加以利用。  在这个阶段，知道漏洞的人很少。这时候，该漏洞属于“宝贵资源”，掌握它的人只会拿来攻击“高价值目标”。所以，如果你只是一个普通网友，或者只是一个小型网站，通常不用担心这个阶段的风险。        ◇漏洞曝光【之后】——作为“零日漏洞” 
  4月7日那天，OpenSSL 发布了公告。发现漏洞的 CloudFlare 公司也发布了公告。于是这个漏洞瞬间传遍全球。几小时之内，大量的攻击工具应运而生（这个漏洞太容易利用了）。然后大量的“脚本小子”（洋文叫“script kiddie”）就拿着这些别人写好的工具，对大量的网站进行扫描。  由于时差的关系，以及某些大公司的官僚风气，很多网站来不及在第一时间升级 OpenSSL 这个软件包（这就是所谓的“零日风险”）。估计某些效率低下的公司，甚至到今天都还没升级。  在这个阶段，对于普通网友  假设你登录过某个网站  假设该网站没有及时升级 OpenSSL  假设该网站存储的是【明文密码】 或者 该网站只在【服务端】加密/Hash密码  假设在你登录期间正好有人利用该漏洞进行信息收集  如果上述几个条件【同时】成立，那么你的密码【有一定的概率】可能被攻击者收集到。         ★对该漏洞的技术分析 
  （本节聊的是该漏洞在技术层面的细节。对 C 语言了解不多的同学，请自行略过，以免浪费时间）  这个漏洞从本质上讲，就是“缓冲区溢出（buffer overflow）”。几乎所有这类漏洞的根源，都是由于程序员的疏忽——对缓冲区涉及的相关“长度”没有仔细检查。  已经有老外写了详细的 Heartbleed 漏洞分析文档（洋文在“  这里  ”）。对于懒得看长篇的同学，俺把精华摘录如下：  问题出在 OpenSSL 中的 ssl/d1_both.c 文件中的 dtls1_process_heartbeat 函数（看名称就知道该函数是干啥滴）。相关代码有如下（俺补了中文注释）      
      int dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;  // p 指向对端发来的心跳数据包
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
    ......
    hbtype = *p++;  // 心跳数据包的第0个字节，表示心跳包的类型
    n2s(p, payload);  // 后面2字节是长度。n2s 这个宏把这2字节取出为整型，然后指针移2字节
    pl = p;  // 此时 p 指向第3个字节——也就是对端提供的心跳包载荷
    ......
    unsigned char *buffer, *bp;
    int r;
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);  // 多出的3字节用于存放类型和长度
    bp = buffer;
    ......
    *bp++ = TLS1_HB_RESPONSE;  // 填充类型
    s2n(payload, bp);  // 填充长度
    memcpy(bp, pl, payload);  // 填充回应包的载荷【亮点在这里】
      
    
  如果对端发来的心跳包有猫腻——包长度跟实际载荷不匹配，那么在发送回应包的时候，那句 memcpy 语句就会把心跳包之后的内存区块也一起 copy 进去，然后发给对端。内存信息就泄露了。  搞清楚问题的根源之后，补丁其实很简单——只需加入2个判断语句（寥寥4行代码）。      
      if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度为 0 的心跳包
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度与载荷不匹配的心跳包
pl = p;
      
    
       ★给普通用户的建议 
  前面的“风险评估”已经分析了——对于普通网友而言，你的风险主要在于“漏洞曝光之后那1-2天”（也就是“0day”导致的风险）。  从4月7日开始的这几天（尤其是4月8日和4月9日），如果你曾经登录过某个重要的帐号，为了以防万一，改一下密码。国内的很多大网站（包括：电子邮件、电子商务、网银、社交网络、等等）都被发现有 Heartbleed 漏洞。  不过值得庆幸的是，Google 应该没事。根据 OpenSSL 官方的公告（链接在“  这里  ”），漏洞的发现者之一 Neel Mehta 是 Google 的人。所以，俺非常确信，Google 的服务器肯定在4月7日之前就解决此问题了。         ★给程序员/架构师的建议 
       ◇“多进程”在安全方面的优点 
  刚开博的头一个季度，俺就发过一篇帖子《  架构设计：进程还是线程？是一个问题！  》，其中提到了多进程的若干优点。今天再来老调重弹，说说“多进程”在安全方面的优点。  
   针对“缓冲区溢出”
    绝大多数的“缓冲区溢出攻击”，都只对当前进程有效。如果你的系统切分成若干个进程，一旦不幸碰上这类攻击，顶多只有一个进程出问题——不至于死得太难看。  不少程序员存在一个误解：以为只有 C/C++ 才会存在缓冲区溢出。其实不然。像 Java/Python 之类的，虽然没有原生的指针，虽然语言的虚拟机/解释器本身对缓冲区越界有严格的检查。但是不要忘了：这些语言的虚拟机/解释器本身也是用 C/C++ 来编写的。说不定虚拟机自己就有问题。  
   针对“信息泄露”
    这次的“Heartbleed漏洞”，从技术上讲属于“缓冲区溢出”类型，从逻辑讲属于“信息泄漏”类型。  如果整个系统切分成很多轻量级的进程，每个进程包含的内存信息自然就少了。一旦出现“信息泄漏”的漏洞，损失会小很多。  
   针对“拒绝服务”
    多进程除了可以降低上述两类的受伤程度，还可以降低“拒绝服务攻击”导致的受伤程度。  比如某些漏洞通过让“进程崩溃”来起到“拒绝服务”的效果。如果系统的架构是多进程的，并且相关进程具有一定的自我恢复机制，那么就可以降低这类攻击造成的伤害程度。        ◇关于密码的“客户端加密/散列” 
  如今比较成熟的网站，应该不会采用“明文”的方式存储用户密码了。很多程序员/架构师都明白，要把用户密码进行散列（Hash）之后再存储。但是这里面有一个细节，很多人忽略了。那就是：“服务端散列”vs“客户端散列”？   
   “服务端散列”和“客户端散列”的差异
    所谓的“服务端散列”就是：用户输入密码之后，以明文的方式传送到服务端，然后在服务端进行散列，散列的结果保存到数据库。  所谓的“客户端散列”就是：用户输入密码之后，现在浏览器这端用 JavaScript 计算散列值，然后把算好的散列值传送到服务端，再保存到数据库。   
   HTTPS 可能出现的问题
    到目前为止，大多数网站（包括很多大型网站）还是采用服务端散列。其实捏，“客户端散列”比“服务器散列”的安全性更好。为啥捏？  对于成熟的大型网站，虽然用户登录过程都是基于加密 HTTPS 传输。但是 HTTPS 不是绝对安全的。俺相信 HTTPS 协议本身的设计是很完备的，但是“协议没问题”不等于“整个HTTPS传输没问题”。整个 HTTPS 传输，可能出问题的环节如下：  
   1. 软件可能出问题
    比如这次的 Heartbleed 漏洞，就属于典型的“基础软件库出问题”  
   2. 中间人攻击（比如证书出问题）
    因为 HTTPS 的加密需要依赖于证书体系。如果证书体系出问题就没戏了。  说两种常见的可能性。  可能性之一：某个 CA 的根证书私钥被盗，那么盗用者就可以随意伪造CA证书。真实的案例是 2011年 DigiNotar 被入侵。  可能性之二：某个 CA 自己就不检点。最贴切的例子非 CNNIC 莫属。这方面的介绍请参见俺4年前的博文《  CNNIC 干过的那些破事儿  》、《  CNNIC 证书的危害及各种清除方法  》   
   “客户端散列”的优点
    看完上述介绍，你应该明白，这几个环节出问题，都有可能让攻击者收集到传输过程中的【明文】密码。如果密码已经在客户端进行散列，那么风险就降低很多（但不是完全降为零，后面会提到）。  要采用“客户端散列”，有经验的开发人员会对密码进行【撒盐】的散列处理，并且精心选择合适的散列算法（速度足够慢）。如此一来，即使攻击者拿到散列结果，也非常非常难逆向推导出原始的密码。   
   “客户端散列”的局限性
    （看到几条读者留言，补充了本小节）  1、“客户端加密/散列”并不能保证绝对的安全（“绝对安全”是不存在滴）。采用“客户端加密/散列”的前提是——页面的JS代码一定采用可信任的方式传输（HTTPS传输）而不能采用明文的 HTTP 传输。因为 HTTP 传输过程，传输内容是可以被篡改的。如果采用 HTTP 明文传输，万一攻击者篡改了客户端的 JS 脚本，还是会导致密码泄漏。  2、HTTPS 通道出现的安全漏洞，大致可以分为两类：一类是攻击者可以窥探到传输内容，但无法修改传输内容（比如这次的 Heartbleed 漏洞属于此类）；还有一类是攻击者可以篡改内容（比如像 CNNIC 这类流氓 CA 就有条件做到这点）。对于前者，骇客无法突破“客户端加密”的防护；对于后者，骇客可以突破。         ★给有志于成为黑客的同学的建议 
  先声明：“黑客”与“骇客”是【完全不同】的两类人。俺之前发过一篇《  每周转载：关于黑客文化和黑客精神  》，或许有助于你了解两者的差异。  俺敢跟任何人打赌，OpenSSL 和 GnuTLS 的代码中，类似的低级错误还有好多。而且 GnuTLS 可能比 OpenSSL 还多。有志于成为黑客的同学，可以考虑去分析这俩的代码，找出其中的漏洞。  通过上面那段代码分析，你应该会意识到：这个漏洞本身并没有涉及到多么高深的 C 语法或技巧。那么，发现该漏洞的难点在哪里捏？俺觉得难在：  1. 对整体结构的把握  因为 OpenSSL 和 GnuTLS 的代码量还是比较庞大的。很少有人能把握整体的结构。  2. 对相关协议的了解  想通过看代码分析这两个软件的漏洞，你还需要对相关的协议很熟悉。比如这次的漏洞，就涉及到“心跳协议”的细节。  3. 耐心/恒心  同时具备上述两条的人本来就不多。然后捏，这些人还未必有足够的耐心去把整个代码（哪怕是其中某个模块的代码）通读一遍。  （第三点或许才是最难的）   如果能够搞定上述三点，并且你的运气足够好，那么你有望独立发现一个高危漏洞。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲 HTTPS 和 SSL/TLS 协议（系列）    如何防止骇客入侵（系列）    CNNIC 干过的那些破事儿    CNNIC 证书的危害及各种清除方法    每周转载：关于黑客文化和黑客精神    架构设计：进程还是线程？是一个问题！      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/04/openssl-heartbleed.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html&title=对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议&caption=

      对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议  
  
    
      
    
  
  
4月7日曝光的 Heartbleed 漏洞（编号CVE-2014-0160）已经在相关的 IT 领域（尤其是信息安全领域）造成很大的风波。在安全圈混了十多年，不写点啥有些说不过去。所以今天就这个话题，谈谈俺个人的观点，并给普通用户、程序员、开源社区、安全从业人员 分别提点建议。 
       
         
        ★关于 Heartbleed 漏洞 
  这个 Heartbleed，直译成中文就是“心脏出血”。听上去挺吓人滴，现实中也确实挺吓人滴。简而言之，这个漏洞足以载入史册。这几天，大伙儿正在经历信息安全历史上的一个重要时刻。或许你应该觉得荣幸 :)  关于这个漏洞的描述，请看中文维基百科的“  这里  ”，俺就不浪费口水了。         ★先发点感慨 
  先发一通抱怨。不喜欢听俺抱怨的，请直接略过。        ◇安全行业的耻辱 
  对整个安全行业而言，这是巨大的耻辱。  OpenSSL 是安全行业内应用非常广泛的开源加密库。一个用来保护安全的软件包，本身居然出现如此严重的漏洞（导致内存信息泄漏），实在太讽刺了。  耻辱的还不光是 OpenSSL——就在一个月之前，GnuTLS 同样出现过高危漏洞（编号 CVE-2014-0092）。这么短的时间之内，涉及到加密的两个最常用的基础库接连爆出高危漏洞，俺不禁要问：整个安全行业的面子要往哪儿搁？        ◇开源社区的耻辱 
  对整个开源社区而言，这是巨大的耻辱。  OpenSSL 作为非常知名的开源项目之一，这么严重的漏洞居然两年后才曝光（2012年3月的稳定版就已经包含此漏洞）。难道关键模块的代码变更之后不进行【Code Review】？亦或是 Code Review 只是走过场？         ★对该漏洞的风险评估 
  该漏洞曝光前后，风险是不同滴。以下俺分别介绍。  下面会涉及两个术语——“未公开漏洞”和“零日漏洞”——两者的区别请看  俺之前的博文  。        ◇漏洞曝光【之前】——作为“未公开漏洞” 
  目前已经有报道指出，在4月7日之前，这个漏洞就已经被骇客利用（报道在“  这里  ”）。另外，圈内也有小道消息流传，说某些攻击者早已拿到此漏洞并加以利用。  在这个阶段，知道漏洞的人很少。这时候，该漏洞属于“宝贵资源”，掌握它的人只会拿来攻击“高价值目标”。所以，如果你只是一个普通网友，或者只是一个小型网站，通常不用担心这个阶段的风险。        ◇漏洞曝光【之后】——作为“零日漏洞” 
  4月7日那天，OpenSSL 发布了公告。发现漏洞的 CloudFlare 公司也发布了公告。于是这个漏洞瞬间传遍全球。几小时之内，大量的攻击工具应运而生（这个漏洞太容易利用了）。然后大量的“脚本小子”（洋文叫“script kiddie”）就拿着这些别人写好的工具，对大量的网站进行扫描。  由于时差的关系，以及某些大公司的官僚风气，很多网站来不及在第一时间升级 OpenSSL 这个软件包（这就是所谓的“零日风险”）。估计某些效率低下的公司，甚至到今天都还没升级。  在这个阶段，对于普通网友  假设你登录过某个网站  假设该网站没有及时升级 OpenSSL  假设该网站存储的是【明文密码】 或者 该网站只在【服务端】加密/Hash密码  假设在你登录期间正好有人利用该漏洞进行信息收集  如果上述几个条件【同时】成立，那么你的密码【有一定的概率】可能被攻击者收集到。         ★对该漏洞的技术分析 
  （本节聊的是该漏洞在技术层面的细节。对 C 语言了解不多的同学，请自行略过，以免浪费时间）  这个漏洞从本质上讲，就是“缓冲区溢出（buffer overflow）”。几乎所有这类漏洞的根源，都是由于程序员的疏忽——对缓冲区涉及的相关“长度”没有仔细检查。  已经有老外写了详细的 Heartbleed 漏洞分析文档（洋文在“  这里  ”）。对于懒得看长篇的同学，俺把精华摘录如下：  问题出在 OpenSSL 中的 ssl/d1_both.c 文件中的 dtls1_process_heartbeat 函数（看名称就知道该函数是干啥滴）。相关代码有如下（俺补了中文注释）      
      int dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;  // p 指向对端发来的心跳数据包
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
    ......
    hbtype = *p++;  // 心跳数据包的第0个字节，表示心跳包的类型
    n2s(p, payload);  // 后面2字节是长度。n2s 这个宏把这2字节取出为整型，然后指针移2字节
    pl = p;  // 此时 p 指向第3个字节——也就是对端提供的心跳包载荷
    ......
    unsigned char *buffer, *bp;
    int r;
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);  // 多出的3字节用于存放类型和长度
    bp = buffer;
    ......
    *bp++ = TLS1_HB_RESPONSE;  // 填充类型
    s2n(payload, bp);  // 填充长度
    memcpy(bp, pl, payload);  // 填充回应包的载荷【亮点在这里】
      
    
  如果对端发来的心跳包有猫腻——包长度跟实际载荷不匹配，那么在发送回应包的时候，那句 memcpy 语句就会把心跳包之后的内存区块也一起 copy 进去，然后发给对端。内存信息就泄露了。  搞清楚问题的根源之后，补丁其实很简单——只需加入2个判断语句（寥寥4行代码）。      
      if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度为 0 的心跳包
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度与载荷不匹配的心跳包
pl = p;
      
    
       ★给普通用户的建议 
  前面的“风险评估”已经分析了——对于普通网友而言，你的风险主要在于“漏洞曝光之后那1-2天”（也就是“0day”导致的风险）。  从4月7日开始的这几天（尤其是4月8日和4月9日），如果你曾经登录过某个重要的帐号，为了以防万一，改一下密码。国内的很多大网站（包括：电子邮件、电子商务、网银、社交网络、等等）都被发现有 Heartbleed 漏洞。  不过值得庆幸的是，Google 应该没事。根据 OpenSSL 官方的公告（链接在“  这里  ”），漏洞的发现者之一 Neel Mehta 是 Google 的人。所以，俺非常确信，Google 的服务器肯定在4月7日之前就解决此问题了。         ★给程序员/架构师的建议 
       ◇“多进程”在安全方面的优点 
  刚开博的头一个季度，俺就发过一篇帖子《  架构设计：进程还是线程？是一个问题！  》，其中提到了多进程的若干优点。今天再来老调重弹，说说“多进程”在安全方面的优点。  
   针对“缓冲区溢出”
    绝大多数的“缓冲区溢出攻击”，都只对当前进程有效。如果你的系统切分成若干个进程，一旦不幸碰上这类攻击，顶多只有一个进程出问题——不至于死得太难看。  不少程序员存在一个误解：以为只有 C/C++ 才会存在缓冲区溢出。其实不然。像 Java/Python 之类的，虽然没有原生的指针，虽然语言的虚拟机/解释器本身对缓冲区越界有严格的检查。但是不要忘了：这些语言的虚拟机/解释器本身也是用 C/C++ 来编写的。说不定虚拟机自己就有问题。  
   针对“信息泄露”
    这次的“Heartbleed漏洞”，从技术上讲属于“缓冲区溢出”类型，从逻辑讲属于“信息泄漏”类型。  如果整个系统切分成很多轻量级的进程，每个进程包含的内存信息自然就少了。一旦出现“信息泄漏”的漏洞，损失会小很多。  
   针对“拒绝服务”
    多进程除了可以降低上述两类的受伤程度，还可以降低“拒绝服务攻击”导致的受伤程度。  比如某些漏洞通过让“进程崩溃”来起到“拒绝服务”的效果。如果系统的架构是多进程的，并且相关进程具有一定的自我恢复机制，那么就可以降低这类攻击造成的伤害程度。        ◇关于密码的“客户端加密/散列” 
  如今比较成熟的网站，应该不会采用“明文”的方式存储用户密码了。很多程序员/架构师都明白，要把用户密码进行散列（Hash）之后再存储。但是这里面有一个细节，很多人忽略了。那就是：“服务端散列”vs“客户端散列”？   
   “服务端散列”和“客户端散列”的差异
    所谓的“服务端散列”就是：用户输入密码之后，以明文的方式传送到服务端，然后在服务端进行散列，散列的结果保存到数据库。  所谓的“客户端散列”就是：用户输入密码之后，现在浏览器这端用 JavaScript 计算散列值，然后把算好的散列值传送到服务端，再保存到数据库。   
   HTTPS 可能出现的问题
    到目前为止，大多数网站（包括很多大型网站）还是采用服务端散列。其实捏，“客户端散列”比“服务器散列”的安全性更好。为啥捏？  对于成熟的大型网站，虽然用户登录过程都是基于加密 HTTPS 传输。但是 HTTPS 不是绝对安全的。俺相信 HTTPS 协议本身的设计是很完备的，但是“协议没问题”不等于“整个HTTPS传输没问题”。整个 HTTPS 传输，可能出问题的环节如下：  
   1. 软件可能出问题
    比如这次的 Heartbleed 漏洞，就属于典型的“基础软件库出问题”  
   2. 中间人攻击（比如证书出问题）
    因为 HTTPS 的加密需要依赖于证书体系。如果证书体系出问题就没戏了。  说两种常见的可能性。  可能性之一：某个 CA 的根证书私钥被盗，那么盗用者就可以随意伪造CA证书。真实的案例是 2011年 DigiNotar 被入侵。  可能性之二：某个 CA 自己就不检点。最贴切的例子非 CNNIC 莫属。这方面的介绍请参见俺4年前的博文《  CNNIC 干过的那些破事儿  》、《  CNNIC 证书的危害及各种清除方法  》   
   “客户端散列”的优点
    看完上述介绍，你应该明白，这几个环节出问题，都有可能让攻击者收集到传输过程中的【明文】密码。如果密码已经在客户端进行散列，那么风险就降低很多（但不是完全降为零，后面会提到）。  要采用“客户端散列”，有经验的开发人员会对密码进行【撒盐】的散列处理，并且精心选择合适的散列算法（速度足够慢）。如此一来，即使攻击者拿到散列结果，也非常非常难逆向推导出原始的密码。   
   “客户端散列”的局限性
    （看到几条读者留言，补充了本小节）  1、“客户端加密/散列”并不能保证绝对的安全（“绝对安全”是不存在滴）。采用“客户端加密/散列”的前提是——页面的JS代码一定采用可信任的方式传输（HTTPS传输）而不能采用明文的 HTTP 传输。因为 HTTP 传输过程，传输内容是可以被篡改的。如果采用 HTTP 明文传输，万一攻击者篡改了客户端的 JS 脚本，还是会导致密码泄漏。  2、HTTPS 通道出现的安全漏洞，大致可以分为两类：一类是攻击者可以窥探到传输内容，但无法修改传输内容（比如这次的 Heartbleed 漏洞属于此类）；还有一类是攻击者可以篡改内容（比如像 CNNIC 这类流氓 CA 就有条件做到这点）。对于前者，骇客无法突破“客户端加密”的防护；对于后者，骇客可以突破。         ★给有志于成为黑客的同学的建议 
  先声明：“黑客”与“骇客”是【完全不同】的两类人。俺之前发过一篇《  每周转载：关于黑客文化和黑客精神  》，或许有助于你了解两者的差异。  俺敢跟任何人打赌，OpenSSL 和 GnuTLS 的代码中，类似的低级错误还有好多。而且 GnuTLS 可能比 OpenSSL 还多。有志于成为黑客的同学，可以考虑去分析这俩的代码，找出其中的漏洞。  通过上面那段代码分析，你应该会意识到：这个漏洞本身并没有涉及到多么高深的 C 语法或技巧。那么，发现该漏洞的难点在哪里捏？俺觉得难在：  1. 对整体结构的把握  因为 OpenSSL 和 GnuTLS 的代码量还是比较庞大的。很少有人能把握整体的结构。  2. 对相关协议的了解  想通过看代码分析这两个软件的漏洞，你还需要对相关的协议很熟悉。比如这次的漏洞，就涉及到“心跳协议”的细节。  3. 耐心/恒心  同时具备上述两条的人本来就不多。然后捏，这些人还未必有足够的耐心去把整个代码（哪怕是其中某个模块的代码）通读一遍。  （第三点或许才是最难的）   如果能够搞定上述三点，并且你的运气足够好，那么你有望独立发现一个高危漏洞。    
   俺博客上，和本文相关的帖子（需翻墙）
   ：   扫盲 HTTPS 和 SSL/TLS 协议（系列）    如何防止骇客入侵（系列）    CNNIC 干过的那些破事儿    CNNIC 证书的危害及各种清除方法    每周转载：关于黑客文化和黑客精神    架构设计：进程还是线程？是一个问题！      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/04/openssl-heartbleed.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议&url=https://program-think.blogspot.com/2014/04/openssl-heartbleed.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2014-04-11
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2014/04/openssl-heartbleed.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="1378711348413028345">
 </a>   <h1 class="post-title entry-title" id="openssl--heartbleed---"> <a href="https://program-think.blogspot.com/2014/04/openssl-heartbleed.html"> 对 OpenSSL 高危漏洞 Heartbleed 的感慨、分析和建议 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
4月7日曝光的 Heartbleed 漏洞（编号CVE-2014-0160）已经在相关的 IT 领域（尤其是信息安全领域）造成很大的风波。在安全圈混了十多年，不写点啥有些说不过去。所以今天就这个话题，谈谈俺个人的观点，并给普通用户、程序员、开源社区、安全从业人员 分别提点建议。 <a name="more">
  </a>     <!--program-think-->
 <br /> <br />     <center> <img alt="不见图 请翻墙" src="https://lh3.googleusercontent.com/JCDXhWmeg8kJcSWTxfbUxMugX1Ryo1gHdjNiLA-OYO_MVtFAVEs2BBFwi2BlhRhj2bD7UZeEByZZl9YxvL73JdaVEU7wD2pt0KVHlNLlEYIt8hMUV-Bdru0tW5pSPQAs4BC-" /> </center>
 <br /> <br />     <h2 id="heartbleed--"> ★关于 Heartbleed 漏洞 </h2>
 <br /> 这个 Heartbleed，直译成中文就是“心脏出血”。听上去挺吓人滴，现实中也确实挺吓人滴。简而言之，这个漏洞足以载入史册。这几天，大伙儿正在经历信息安全历史上的一个重要时刻。或许你应该觉得荣幸 :) <br /> 关于这个漏洞的描述，请看中文维基百科的“ <a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E" rel="nofollow" target="_blank"> 这里 </a> ”，俺就不浪费口水了。 <br /> <br /> <br />     <h2 id="section"> ★先发点感慨 </h2>
 <br /> 先发一通抱怨。不喜欢听俺抱怨的，请直接略过。 <br /> <br />     <h3 id="section-1"> ◇安全行业的耻辱 </h3>
 <br /> 对整个安全行业而言，这是巨大的耻辱。 <br /> OpenSSL 是安全行业内应用非常广泛的开源加密库。一个用来保护安全的软件包，本身居然出现如此严重的漏洞（导致内存信息泄漏），实在太讽刺了。 <br /> 耻辱的还不光是 OpenSSL——就在一个月之前，GnuTLS 同样出现过高危漏洞（编号 CVE-2014-0092）。这么短的时间之内，涉及到加密的两个最常用的基础库接连爆出高危漏洞，俺不禁要问：整个安全行业的面子要往哪儿搁？ <br /> <br />     <h3 id="section-2"> ◇开源社区的耻辱 </h3>
 <br /> 对整个开源社区而言，这是巨大的耻辱。 <br /> OpenSSL 作为非常知名的开源项目之一，这么严重的漏洞居然两年后才曝光（2012年3月的稳定版就已经包含此漏洞）。难道关键模块的代码变更之后不进行【Code Review】？亦或是 Code Review 只是走过场？ <br /> <br /> <br />     <h2 id="section-3"> ★对该漏洞的风险评估 </h2>
 <br /> 该漏洞曝光前后，风险是不同滴。以下俺分别介绍。 <br /> 下面会涉及两个术语——“未公开漏洞”和“零日漏洞”——两者的区别请看 <a href="https://program-think.blogspot.com/2010/08/howto-prevent-hacker-attack-4.html"> 俺之前的博文 </a> 。 <br /> <br />     <h3 id="section-4"> ◇漏洞曝光【之前】——作为“未公开漏洞” </h3>
 <br /> 目前已经有报道指出，在4月7日之前，这个漏洞就已经被骇客利用（报道在“ <a href="http://arstechnica.com/security/2014/04/heartbleed-vulnerability-may-have-been-exploited-months-before-patch/" rel="nofollow" target="_blank"> 这里 </a> ”）。另外，圈内也有小道消息流传，说某些攻击者早已拿到此漏洞并加以利用。 <br /> 在这个阶段，知道漏洞的人很少。这时候，该漏洞属于“宝贵资源”，掌握它的人只会拿来攻击“高价值目标”。所以，如果你只是一个普通网友，或者只是一个小型网站，通常不用担心这个阶段的风险。 <br /> <br />     <h3 id="section-5"> ◇漏洞曝光【之后】——作为“零日漏洞” </h3>
 <br /> 4月7日那天，OpenSSL 发布了公告。发现漏洞的 CloudFlare 公司也发布了公告。于是这个漏洞瞬间传遍全球。几小时之内，大量的攻击工具应运而生（这个漏洞太容易利用了）。然后大量的“脚本小子”（洋文叫“script kiddie”）就拿着这些别人写好的工具，对大量的网站进行扫描。 <br /> 由于时差的关系，以及某些大公司的官僚风气，很多网站来不及在第一时间升级 OpenSSL 这个软件包（这就是所谓的“零日风险”）。估计某些效率低下的公司，甚至到今天都还没升级。 <br /> 在这个阶段，对于普通网友 <br /> 假设你登录过某个网站 <br /> 假设该网站没有及时升级 OpenSSL <br /> 假设该网站存储的是【明文密码】 或者 该网站只在【服务端】加密/Hash密码 <br /> 假设在你登录期间正好有人利用该漏洞进行信息收集 <br /> 如果上述几个条件【同时】成立，那么你的密码【有一定的概率】可能被攻击者收集到。 <br /> <br /> <br />     <h2 id="section-6"> ★对该漏洞的技术分析 </h2>
 <br /> （本节聊的是该漏洞在技术层面的细节。对 C 语言了解不多的同学，请自行略过，以免浪费时间） <br /> 这个漏洞从本质上讲，就是“缓冲区溢出（buffer overflow）”。几乎所有这类漏洞的根源，都是由于程序员的疏忽——对缓冲区涉及的相关“长度”没有仔细检查。 <br /> 已经有老外写了详细的 Heartbleed 漏洞分析文档（洋文在“ <a href="http://blog.existentialize.com/diagnosis-of-the-openssl-heartbleed-bug.html" rel="nofollow" target="_blank"> 这里 </a> ”）。对于懒得看长篇的同学，俺把精华摘录如下： <br /> 问题出在 OpenSSL 中的 ssl/d1_both.c 文件中的 dtls1_process_heartbeat 函数（看名称就知道该函数是干啥滴）。相关代码有如下（俺补了中文注释） <br />     <div class="source">
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;  // p 指向对端发来的心跳数据包
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
    ......
    hbtype = *p++;  // 心跳数据包的第0个字节，表示心跳包的类型
    n2s(p, payload);  // 后面2字节是长度。n2s 这个宏把这2字节取出为整型，然后指针移2字节
    pl = p;  // 此时 p 指向第3个字节——也就是对端提供的心跳包载荷
    ......
    unsigned char *buffer, *bp;
    int r;
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);  // 多出的3字节用于存放类型和长度
    bp = buffer;
    ......
    *bp++ = TLS1_HB_RESPONSE;  // 填充类型
    s2n(payload, bp);  // 填充长度
    memcpy(bp, pl, payload);  // 填充回应包的载荷【亮点在这里】
</code></pre></div>      </div>
    </div>
 <br /> 如果对端发来的心跳包有猫腻——包长度跟实际载荷不匹配，那么在发送回应包的时候，那句 memcpy 语句就会把心跳包之后的内存区块也一起 copy 进去，然后发给对端。内存信息就泄露了。 <br /> 搞清楚问题的根源之后，补丁其实很简单——只需加入2个判断语句（寥寥4行代码）。 <br />     <div class="source">
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度为 0 的心跳包
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
    return 0;  // 忽略长度与载荷不匹配的心跳包
pl = p;
</code></pre></div>      </div>
    </div>
 <br />     <h2 id="section-7"> ★给普通用户的建议 </h2>
 <br /> 前面的“风险评估”已经分析了——对于普通网友而言，你的风险主要在于“漏洞曝光之后那1-2天”（也就是“0day”导致的风险）。 <br /> 从4月7日开始的这几天（尤其是4月8日和4月9日），如果你曾经登录过某个重要的帐号，为了以防万一，改一下密码。国内的很多大网站（包括：电子邮件、电子商务、网银、社交网络、等等）都被发现有 Heartbleed 漏洞。 <br /> 不过值得庆幸的是，Google 应该没事。根据 OpenSSL 官方的公告（链接在“ <a href="http://www.openssl.org/news/secadv_20140407.txt" rel="nofollow" target="_blank"> 这里 </a> ”），漏洞的发现者之一 Neel Mehta 是 Google 的人。所以，俺非常确信，Google 的服务器肯定在4月7日之前就解决此问题了。 <br /> <br /> <br />     <h2 id="section-8"> ★给程序员/架构师的建议 </h2>
 <br />     <h3 id="section-9"> ◇“多进程”在安全方面的优点 </h3>
 <br /> 刚开博的头一个季度，俺就发过一篇帖子《 <a href="https://program-think.blogspot.com/2009/02/multi-process-vs-multi-thread.html"> 架构设计：进程还是线程？是一个问题！ </a> 》，其中提到了多进程的若干优点。今天再来老调重弹，说说“多进程”在安全方面的优点。 <br /> <b>
   针对“缓冲区溢出”
  </b> <br /> 绝大多数的“缓冲区溢出攻击”，都只对当前进程有效。如果你的系统切分成若干个进程，一旦不幸碰上这类攻击，顶多只有一个进程出问题——不至于死得太难看。 <br /> 不少程序员存在一个误解：以为只有 C/C++ 才会存在缓冲区溢出。其实不然。像 Java/Python 之类的，虽然没有原生的指针，虽然语言的虚拟机/解释器本身对缓冲区越界有严格的检查。但是不要忘了：这些语言的虚拟机/解释器本身也是用 C/C++ 来编写的。说不定虚拟机自己就有问题。 <br /> <b>
   针对“信息泄露”
  </b> <br /> 这次的“Heartbleed漏洞”，从技术上讲属于“缓冲区溢出”类型，从逻辑讲属于“信息泄漏”类型。 <br /> 如果整个系统切分成很多轻量级的进程，每个进程包含的内存信息自然就少了。一旦出现“信息泄漏”的漏洞，损失会小很多。 <br /> <b>
   针对“拒绝服务”
  </b> <br /> 多进程除了可以降低上述两类的受伤程度，还可以降低“拒绝服务攻击”导致的受伤程度。 <br /> 比如某些漏洞通过让“进程崩溃”来起到“拒绝服务”的效果。如果系统的架构是多进程的，并且相关进程具有一定的自我恢复机制，那么就可以降低这类攻击造成的伤害程度。 <br /> <br />     <h3 id="section-10"> ◇关于密码的“客户端加密/散列” </h3>
 <br /> 如今比较成熟的网站，应该不会采用“明文”的方式存储用户密码了。很多程序员/架构师都明白，要把用户密码进行散列（Hash）之后再存储。但是这里面有一个细节，很多人忽略了。那就是：“服务端散列”vs“客户端散列”？ <br /> <br /> <b>
   “服务端散列”和“客户端散列”的差异
  </b> <br /> 所谓的“服务端散列”就是：用户输入密码之后，以明文的方式传送到服务端，然后在服务端进行散列，散列的结果保存到数据库。 <br /> 所谓的“客户端散列”就是：用户输入密码之后，现在浏览器这端用 JavaScript 计算散列值，然后把算好的散列值传送到服务端，再保存到数据库。 <br /> <br /> <b>
   HTTPS 可能出现的问题
  </b> <br /> 到目前为止，大多数网站（包括很多大型网站）还是采用服务端散列。其实捏，“客户端散列”比“服务器散列”的安全性更好。为啥捏？ <br /> 对于成熟的大型网站，虽然用户登录过程都是基于加密 HTTPS 传输。但是 HTTPS 不是绝对安全的。俺相信 HTTPS 协议本身的设计是很完备的，但是“协议没问题”不等于“整个HTTPS传输没问题”。整个 HTTPS 传输，可能出问题的环节如下： <br /> <b>
   1. 软件可能出问题
  </b> <br /> 比如这次的 Heartbleed 漏洞，就属于典型的“基础软件库出问题” <br /> <b>
   2. 中间人攻击（比如证书出问题）
  </b> <br /> 因为 HTTPS 的加密需要依赖于证书体系。如果证书体系出问题就没戏了。 <br /> 说两种常见的可能性。 <br /> 可能性之一：某个 CA 的根证书私钥被盗，那么盗用者就可以随意伪造CA证书。真实的案例是 2011年 DigiNotar 被入侵。 <br /> 可能性之二：某个 CA 自己就不检点。最贴切的例子非 CNNIC 莫属。这方面的介绍请参见俺4年前的博文《 <a href="https://program-think.blogspot.com/2010/02/about-cnnic.html"> CNNIC 干过的那些破事儿 </a> 》、《 <a href="https://program-think.blogspot.com/2010/02/remove-cnnic-cert.html"> CNNIC 证书的危害及各种清除方法 </a> 》 <br /> <br /> <b>
   “客户端散列”的优点
  </b> <br /> 看完上述介绍，你应该明白，这几个环节出问题，都有可能让攻击者收集到传输过程中的【明文】密码。如果密码已经在客户端进行散列，那么风险就降低很多（但不是完全降为零，后面会提到）。 <br /> 要采用“客户端散列”，有经验的开发人员会对密码进行【撒盐】的散列处理，并且精心选择合适的散列算法（速度足够慢）。如此一来，即使攻击者拿到散列结果，也非常非常难逆向推导出原始的密码。 <br /> <br /> <b>
   “客户端散列”的局限性
  </b> <br /> （看到几条读者留言，补充了本小节） <br /> 1、“客户端加密/散列”并不能保证绝对的安全（“绝对安全”是不存在滴）。采用“客户端加密/散列”的前提是——页面的JS代码一定采用可信任的方式传输（HTTPS传输）而不能采用明文的 HTTP 传输。因为 HTTP 传输过程，传输内容是可以被篡改的。如果采用 HTTP 明文传输，万一攻击者篡改了客户端的 JS 脚本，还是会导致密码泄漏。 <br /> 2、HTTPS 通道出现的安全漏洞，大致可以分为两类：一类是攻击者可以窥探到传输内容，但无法修改传输内容（比如这次的 Heartbleed 漏洞属于此类）；还有一类是攻击者可以篡改内容（比如像 CNNIC 这类流氓 CA 就有条件做到这点）。对于前者，骇客无法突破“客户端加密”的防护；对于后者，骇客可以突破。 <br /> <br /> <br />     <h2 id="section-11"> ★给有志于成为黑客的同学的建议 </h2>
 <br /> 先声明：“黑客”与“骇客”是【完全不同】的两类人。俺之前发过一篇《 <a href="https://program-think.blogspot.com/2013/01/weekly-share-37.html"> 每周转载：关于黑客文化和黑客精神 </a> 》，或许有助于你了解两者的差异。 <br /> 俺敢跟任何人打赌，OpenSSL 和 GnuTLS 的代码中，类似的低级错误还有好多。而且 GnuTLS 可能比 OpenSSL 还多。有志于成为黑客的同学，可以考虑去分析这俩的代码，找出其中的漏洞。 <br /> 通过上面那段代码分析，你应该会意识到：这个漏洞本身并没有涉及到多么高深的 C 语法或技巧。那么，发现该漏洞的难点在哪里捏？俺觉得难在： <br /> 1. 对整体结构的把握 <br /> 因为 OpenSSL 和 GnuTLS 的代码量还是比较庞大的。很少有人能把握整体的结构。 <br /> 2. 对相关协议的了解 <br /> 想通过看代码分析这两个软件的漏洞，你还需要对相关的协议很熟悉。比如这次的漏洞，就涉及到“心跳协议”的细节。 <br /> 3. 耐心/恒心 <br /> 同时具备上述两条的人本来就不多。然后捏，这些人还未必有足够的耐心去把整个代码（哪怕是其中某个模块的代码）通读一遍。 <br /> （第三点或许才是最难的） <br /> <br /> 如果能够搞定上述三点，并且你的运气足够好，那么你有望独立发现一个高危漏洞。 <br /> <br /> <br /> <b>
   俺博客上，和本文相关的帖子（需翻墙）
  </b> ： <br /> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html"> 扫盲 HTTPS 和 SSL/TLS 协议（系列） </a> <br /> <a href="https://program-think.blogspot.com/2010/06/howto-prevent-hacker-attack-0.html"> 如何防止骇客入侵（系列） </a> <br /> <a href="https://program-think.blogspot.com/2010/02/about-cnnic.html"> CNNIC 干过的那些破事儿 </a> <br /> <a href="https://program-think.blogspot.com/2010/02/remove-cnnic-cert.html"> CNNIC 证书的危害及各种清除方法 </a> <br /> <a href="https://program-think.blogspot.com/2013/01/weekly-share-37.html"> 每周转载：关于黑客文化和黑客精神 </a> <br /> <a href="https://program-think.blogspot.com/2009/02/multi-process-vs-multi-thread.html"> 架构设计：进程还是线程？是一个问题！ </a>     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2014/04/openssl-heartbleed.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2014/04/openssl-heartbleed.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2014-04-18</time>
        <a href="https://nodebe4.github.io/opinion/2014-04-18/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E6%9C%80%E8%BF%91%E5%8D%8A%E4%B8%AA%E6%9C%88%E7%9A%8415%E8%B5%B7%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%BD%A2%E5%B7%A5-%E7%BB%B4%E6%9D%83%E4%BA%8B%E4%BB%B6-%E4%B8%8A%E7%99%BE%E5%BC%A0%E7%85%A7%E7%89%87/">
          每周转载：最近半个月的15起大规模罢工-维权事件（上百张照片）
        </a>
      </li>
    
    
      <li>
        <time>2014-04-14</time>
        <a href="https://nodebe4.github.io/opinion/2014-04-14/%E7%89%87%E9%9D%A2%E5%BC%BA%E8%B0%83-PX-%E4%BD%8E%E6%AF%92-%E5%B1%9E%E4%BA%8E-%E5%81%B7%E6%8D%A2%E6%A6%82%E5%BF%B5-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D-PX-%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8%E9%9A%8F%E6%83%B3/">
          “片面强调 PX 低毒”属于【偷换概念】——广东茂名 PX 抗议活动随想
        </a>
      </li>
    
    
      <li>
        <time>2014-04-09</time>
        <a href="https://nodebe4.github.io/opinion/2014-04-09/%E4%B8%AD%E5%9B%BD%E6%98%AF%E4%BB%8E%E5%93%AA%E4%B8%AA%E6%9C%9D%E4%BB%A3%E5%BC%80%E5%A7%8B%E8%90%BD%E5%90%8E%E4%BA%8E%E8%A5%BF%E6%96%B9/">
          中国是从哪个朝代开始落后于西方？
        </a>
      </li>
    
    
      <li>
        <time>2014-04-04</time>
        <a href="https://nodebe4.github.io/opinion/2014-04-04/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D%E5%8F%8D-PX-%E7%8E%AF%E4%BF%9D%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8-%E7%85%A7%E7%89%87%E5%8F%8A%E7%BD%91%E5%8F%8B%E8%AF%84%E8%AE%BA/">
          每周转载：广东茂名反 PX 环保抗议活动（照片及网友评论）
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2014-04-11/%E9%9D%9E%E6%AD%A4%E6%88%96%E5%BD%BC-%E7%94%A8%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%A7%A3%E9%87%8A%E6%97%8F%E7%BE%A4%E5%86%B2%E7%AA%81-%E4%BB%A5%E5%8D%B0%E5%BA%A6%E4%B8%BA%E4%BE%8B/">
            前一篇：非此或彼 | 用经济学解释族群冲突：以印度为例
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2014-04-14/%E7%89%87%E9%9D%A2%E5%BC%BA%E8%B0%83-PX-%E4%BD%8E%E6%AF%92-%E5%B1%9E%E4%BA%8E-%E5%81%B7%E6%8D%A2%E6%A6%82%E5%BF%B5-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D-PX-%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8%E9%9A%8F%E6%83%B3/">
            後一篇：“片面强调 PX 低毒”属于【偷换概念】——广东茂名 PX 抗议活动随想
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2014-04-11/%E9%9D%9E%E6%AD%A4%E6%88%96%E5%BD%BC-%E7%94%A8%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%A7%A3%E9%87%8A%E6%97%8F%E7%BE%A4%E5%86%B2%E7%AA%81-%E4%BB%A5%E5%8D%B0%E5%BA%A6%E4%B8%BA%E4%BE%8B/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2014-04-14/%E7%89%87%E9%9D%A2%E5%BC%BA%E8%B0%83-PX-%E4%BD%8E%E6%AF%92-%E5%B1%9E%E4%BA%8E-%E5%81%B7%E6%8D%A2%E6%A6%82%E5%BF%B5-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D-PX-%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8%E9%9A%8F%E6%83%B3/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2014-04-14/%E7%89%87%E9%9D%A2%E5%BC%BA%E8%B0%83-PX-%E4%BD%8E%E6%AF%92-%E5%B1%9E%E4%BA%8E-%E5%81%B7%E6%8D%A2%E6%A6%82%E5%BF%B5-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D-PX-%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8%E9%9A%8F%E6%83%B3/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2014-04-09/%E4%B8%AD%E5%9B%BD%E6%98%AF%E4%BB%8E%E5%93%AA%E4%B8%AA%E6%9C%9D%E4%BB%A3%E5%BC%80%E5%A7%8B%E8%90%BD%E5%90%8E%E4%BA%8E%E8%A5%BF%E6%96%B9/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2014-04-11/%E9%9D%9E%E6%AD%A4%E6%88%96%E5%BD%BC-%E7%94%A8%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%A7%A3%E9%87%8A%E6%97%8F%E7%BE%A4%E5%86%B2%E7%AA%81-%E4%BB%A5%E5%8D%B0%E5%BA%A6%E4%B8%BA%E4%BE%8B/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2014-04-14/%E7%89%87%E9%9D%A2%E5%BC%BA%E8%B0%83-PX-%E4%BD%8E%E6%AF%92-%E5%B1%9E%E4%BA%8E-%E5%81%B7%E6%8D%A2%E6%A6%82%E5%BF%B5-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D-PX-%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8%E9%9A%8F%E6%83%B3/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2014-04-14/%E7%89%87%E9%9D%A2%E5%BC%BA%E8%B0%83-PX-%E4%BD%8E%E6%AF%92-%E5%B1%9E%E4%BA%8E-%E5%81%B7%E6%8D%A2%E6%A6%82%E5%BF%B5-%E5%B9%BF%E4%B8%9C%E8%8C%82%E5%90%8D-PX-%E6%8A%97%E8%AE%AE%E6%B4%BB%E5%8A%A8%E9%9A%8F%E6%83%B3/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2014-04-09/%E4%B8%AD%E5%9B%BD%E6%98%AF%E4%BB%8E%E5%93%AA%E4%B8%AA%E6%9C%9D%E4%BB%A3%E5%BC%80%E5%A7%8B%E8%90%BD%E5%90%8E%E4%BA%8E%E8%A5%BF%E6%96%B9/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
