<!DOCTYPE html>
<html>
  <head>
  <title>扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      扫盲 HTTPS 和 SSL/TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性  
  
    
      
    
  
  
     ★先插播一个安全通告 
  就在  本系列  刚开播之后没几天（11月11日），微软爆了一个  跟 SSL/TLS 相关的高危漏洞  ， 
   影响【几乎所有的】Windows 平台
   。至此，【所有】主流的 SSL/TLS 协议栈（至少包括：开源的 OpenSSL、开源的 GnuTLS、微软的 SSP、苹果的 SecureTransport），全都在今年爆了高危漏洞。（看来俺这个系列生逢其时啊）  个人觉得：【2014年】必将在信息安全历史上留下醒目的记录。  用 Windows 系统的同学，这几天要尽快升级微软的“安全更新”。因为该漏洞会导致“远程代码执行”，非常危险。  （微软的公告中没有提及 Win2000 和 WinXP 是因为这俩已经过了“产品支持周期”。【不】等于说这俩没问题）       
 在  本系列的前一篇  ，已经介绍了相关的背景知识以及设计 SSL 需要考虑的需求。当时俺提到：设计 HTTPS 的最大难点（没有之一）是——如何在互联网上进行安全的“密钥交换”。今天就来讲讲密钥交换的难点和解决方法（暂不谈技术实现）。  
       
        ★方案1——单纯用“对称加密算法”的可行性 
  首先简单阐述一下，“单纯用对称加密”为啥是【不可行】滴。  如果“单纯用对称加密”，浏览器和网站之间势必先要交换“对称加密的密钥”。  如果这个密钥直接用【明文】传输，很容易就会被第三方（有可能是“攻击者”）偷窥到；如果这个密钥用密文传输，那就再次引入了“如何交换加密密钥”的问题——这就变成“先有鸡还是先有蛋”的循环逻辑了。  所以，【单纯用】对称加密，是没戏滴。         ★方案2——单纯用“非对称加密算法”的风险 
  说完“对称加密”，再来说说“非对称加密”。  在前面的“  背景知识  ”中，已经大致介绍过“非对称加密”的特点——“加密和解密采用不同的密钥”。基于这个特点，可以避开前面提到的“循环逻辑”的困境。大致的步骤如下：      

    第1步
     网站服务器先基于“非对称加密算法”，随机生成一个“密钥对”（为叙述方便，称之为“k1 和 k2”）。因为是随机生成的，目前为止，只有网站服务器才知道 k1 和 k2。   
    第2步
     网站把 k1 保留在自己手中，把 k2 用【明文】的方式发送给访问者的浏览器。  因为 k2 是明文发送的，自然有可能被偷窥。不过不要紧。即使偷窥者拿到 k2，也【很难】根据 k2 推算出 k1  （这一点是由“非对称加密算法”从数学上保证的）。   
    第3步
     浏览器拿到 k2 之后，先【随机生成】第三个对称加密的密钥（简称 k）。  然后用 k2 加密 k，得到 k'（k' 是 k 的加密结果）  浏览器把 k' 发送给网站服务器。   由于 k1 和 k2 是成对的，所以只有 k1 才能解密 k2 的加密结果。  因此这个过程中，即使被第三方偷窥，第三方也【无法】从 k' 解密得到 k   
    第4步
     网站服务器拿到 k' 之后，用 k1 进行解密，得到 k  至此，浏览器和网站服务器就完成了密钥交换，双方都知道 k，而且【貌似】第三方无法拿到 k  然后，双方就可以用 k 来进行数据双向传输的加密。    
  
   现在，给大伙儿留一点【思考时间】——你觉得上述过程是否严密？如果不严密，漏洞在哪里？
     建   议   你   思   考   一   柱   香   的   时   间   ，   再   来   看   答   案   OK，现在俺来揭晓答案（希望你没有事先偷看）  
   “方案2”依然是【不】安全滴
   ——虽然“方案2”可以在一定程度上防止网络数据的“偷窥/嗅探”，但是【无法】防范网络数据的【篡改】。  假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间，并且这个攻击者具备“【修改】双方传输数据”的能力。那么，这个攻击者就可以攻破“方案2”。具体的攻击过程如下：       

    第1步
     这一步跟原先一样——服务器先随机生成一个“非对称的密钥对”k1 和 k2（此时只有网站知道 k1 和 k2）   
    第2步
     当网站发送 k2 给浏览器的时候，攻击者截获 k2，保留在自己手上。  然后攻击者自己生成一个【伪造的】密钥对（以下称为 pk1 和 pk2）。  攻击者把 pk2 发送给浏览器。   
    第3步
     浏览器收到 pk2，以为 pk2 就是网站发送的。  浏览器不知情，依旧随机生成一个对称加密的密钥 k，然后用 pk2 加密 k，得到密文的 k'  浏览器把 k' 发送给网站。  （以下是关键）  发送的过程中，再次被攻击者截获。  因为 pk1 pk2 都是攻击者自己生成的，所以攻击者自然就可以用 pk1 来解密 k' 得到 k  然后，攻击者拿到 k 之后，用之前截获的 k2 重新加密，得到 k''，并把 k'' 发送给网站。   
    第4步
     网站服务器收到了 k'' 之后，用自己保存的 k1 可以正常解密，所以网站方面不会起疑心。  至此，攻击者完成了一次漂亮的偷梁换柱，而且让双方都没有起疑心。    
  
   上述过程，也就是传说中大名鼎鼎的“中间人攻击”
   。洋文叫做“Man-In-The-Middle attack”。缩写是 MITM。  “中间人攻击”有很多种“类型”，刚才演示的是针对“【单纯的】非对称加密”的中间人攻击。至于“中间人攻击”的其它类型，俺在  本系列  的后续博文中，还会再提到。   为了更加形象，补充两张示意图，分别对应“偷窥模式”和“中间人模式”。让你更直观地体会两者的差异。        
      
        ★方案2失败的根源——缺乏【可靠的】身份认证 
  为啥“方案2”会失败？  除了俺在图中提到的“攻击者具备篡改数据的能力”，还有另一点关键点——“方案2缺乏身份认证机制”。  正是因为“缺乏身份认证机制”，所以当攻击者一开始截获 k2 并把自己伪造的 pk2 发送给浏览器时，浏览器无法鉴别：自己收到的密钥是不是真的来自于网站服务器。  假如具备某种【可靠的】身份认证机制，即使攻击者能够篡改数据，但是篡改之后的数据很容易被识破。那篡改也就失去了意义。         ★身份认证的几种方式 
  下面，俺来介绍几种常见的“身份认证原理”。        ◇基于某些“私密的共享信息” 
  为了解释“私密的共享信息”这个概念，咱们先抛开“信息安全”，谈谈日常生活中的某个场景。  假设你有一个久未联系的老朋友。因为时间久远，你已经没有此人的联系方式了。某天，此人突然给你发了一封电子邮件。  那么，你如何确保——发邮件的人确实是你的老朋友捏？  有一个办法就是：你用邮件向对方询问某个私密的事情（这个事情只有你和你的这个朋友知道，其他人不知道）。如果对方能够回答出来，那么对方【很有可能】确实是你的老朋友。  从这个例子可以看出，如果通讯双方具有某些“私密的共享信息”（只有双方知道，第三方不知道），就能以此为基础，进行身份认证，从而建立信任。        ◇基于双方都信任的“公证人” 
  “私密的共享信息”，通常需要双方互相比较熟悉，才行得通。如果双方本来就互不相识，如何进行身份认证以建立信任关系捏？  这时候还有另一个办法——依靠双方都信任的某个“公证人”来建立信任关系。  如今 C2C 模式的电子商务，其实用的就是这种方式——由电商平台充当公证人，让买家与卖家建立某种程度的信任关系。  考虑到如今的网购已经相当普及，大伙儿应该对这类模式很熟悉吧。所以俺就不浪费口水了。         ★如何解决 SSL 的【身份认证】问题——CA 的引入 
  说完身份认证的方式/原理，再回到 SSL/TLS 的话题上。  对于 SSL/TLS 的应用场景，由于双方（“浏览器”和“网站服务器”）通常都是素不相识滴，显然【不可能】采用第一种方式（私密的共享信息），而只能采用第二种方式（依赖双方都信任的“公证人”）。  那么，谁来充当这个公证人捏？这时候，CA 就华丽地登场啦。  所谓的 CA，就是“数字证书认证机构”的缩写，洋文全称叫做“Certificate Authority”。关于 CA 以及 CA 颁发的“CA 证书”，俺已经写过一篇教程：《  数字证书及 CA 的扫盲介绍  》，介绍其基本概念和功能。所以，此处就不再重复唠叨了。  如果你看完那篇 CA 的扫盲，你自然就明白——CA 完全有资格和能力，充当这个“公证人”的角色。         ★方案3——基于 CA 证书进行密钥交换 
  其实“方案3”跟“方案2”很像的，主要差别在于——“方案3”增加了“CA 数字证书”这个环节。所谓的数字证书，技术上依赖的还是前面提到的“非对称加密”。为了描述“CA 证书”在 SSL/TLS 中的作用，俺大致说一下原理（仅仅是原理，具体的技术实现要略复杂些）：      

    第1步（这是“一次性”的准备工作）
     网站方面首先要花一笔银子，在某个 CA 那里购买一个数字证书。  该证书通常会对应几个文件：其中一个文件包含公钥，还有一个文件包含私钥。  此处的“私钥”，相当于“方案2”里面的 k1；而“公钥”类似于“方案2”里面的 k2。  网站方面必须在 Web 服务器上部署这两个文件。   所谓的“公钥”，顾名思义就是可以公开的 key；而所谓的“私钥”就是私密的 key。  其实前面已经说过了，这里再唠叨一下：  “非对称加密算法”从数学上确保了——即使你知道某个公钥，也很难（不是不可能，是很难）根据此公钥推导出对应的私钥。   
    第2步
     当浏览器访问该网站，Web 服务器首先把包含公钥的证书发送给浏览器。   
    第3步
     浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。  由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。   为啥浏览器能发现 CA 证书是否有诈？  因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。  （比如 Windows 中就内置了几十个权威 CA 的根证书）  因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。  （关于“根证书”和“证书信任链”的概念，请参见之前的教程《  数字证书及CA的扫盲介绍  》）   
    第4步
     如果网站发过来的 CA 证书没有问题，那么浏览器就从该 CA 证书中提取出“公钥”。  然后浏览器随机生成一个“对称加密的密钥”（以下称为 k）。用 CA 证书的公钥加密 k，得到密文 k'  浏览器把 k' 发送给网站。   
    第5步
     网站收到浏览器发过来的 k'，用服务器上的私钥进行解密，得到 k。  至此，浏览器和网站都拥有 k，“密钥交换”大功告成啦。    
  可能有同学会问：那么“方案3”是否就足够严密，无懈可击了捏？  俺只能说，“方案3”【从理论上讲】没有明显的漏洞。实际上 SSL 的早期版本（SSLv2）使用 RSA 进行身份认知和密钥交换，其原理与这个“方案3”类似。  但是，“理论”一旦落实到“实践”，往往是有差距滴，会引出新的问题。套用某 IT 大牛的名言，就是：  In theory, there is no difference between theory and practice. But in practice, there is.   所以在本系列的后续博文，俺还会再来介绍“针对 SSL/TLS 的种种攻击方式”以及“对应的防范措施”。         ★关于“客户端证书”的补充说明 
  前面介绍的“方案3”仅仅使用了“服务端证书”——通过服务端证书来确保服务器不是假冒的。  除了“服务端证书”，在某些场合中还会涉及到“客户端证书”。所谓的“客户端证书”就是用来证明客户端（浏览器端）访问者的身份。  比如在某些金融公司的内网，你的电脑上必须部署“客户端证书”，才能打开重要服务器的页面。  由于本文主要介绍的是【公网】上的场景，这种场景下大都【不需要】“客户端证书”。所以，对“客户端证书”这个话题，俺就偷个懒，略过不提。         ★总结 
  在本文结尾，来稍微总结一下：  如果没有引入某种身份认证机制，必定会导致“中间人攻击”。这种情况下，加密算法搞得再强大，也是然并卵。  本文介绍了两种身份认证的思路，分别是：  1、基于私密的共享信息；  2、基于双方都信任的公证人。  前者【不】适合用于互联网通讯，所以必须采用后者。也就是如今广泛使用的 CA 证书体系。CA 就是上述所说的“双方都信任的公证人”。   下一篇，扫盲几种“  密钥交换协议的算法  ”。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      扫盲 HTTPS 和 SSL/TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性  
  
    
      
    
  
  
     ★先插播一个安全通告 
  就在  本系列  刚开播之后没几天（11月11日），微软爆了一个  跟 SSL/TLS 相关的高危漏洞  ， 
   影响【几乎所有的】Windows 平台
   。至此，【所有】主流的 SSL/TLS 协议栈（至少包括：开源的 OpenSSL、开源的 GnuTLS、微软的 SSP、苹果的 SecureTransport），全都在今年爆了高危漏洞。（看来俺这个系列生逢其时啊）  个人觉得：【2014年】必将在信息安全历史上留下醒目的记录。  用 Windows 系统的同学，这几天要尽快升级微软的“安全更新”。因为该漏洞会导致“远程代码执行”，非常危险。  （微软的公告中没有提及 Win2000 和 WinXP 是因为这俩已经过了“产品支持周期”。【不】等于说这俩没问题）       
 在  本系列的前一篇  ，已经介绍了相关的背景知识以及设计 SSL 需要考虑的需求。当时俺提到：设计 HTTPS 的最大难点（没有之一）是——如何在互联网上进行安全的“密钥交换”。今天就来讲讲密钥交换的难点和解决方法（暂不谈技术实现）。  
       
        ★方案1——单纯用“对称加密算法”的可行性 
  首先简单阐述一下，“单纯用对称加密”为啥是【不可行】滴。  如果“单纯用对称加密”，浏览器和网站之间势必先要交换“对称加密的密钥”。  如果这个密钥直接用【明文】传输，很容易就会被第三方（有可能是“攻击者”）偷窥到；如果这个密钥用密文传输，那就再次引入了“如何交换加密密钥”的问题——这就变成“先有鸡还是先有蛋”的循环逻辑了。  所以，【单纯用】对称加密，是没戏滴。         ★方案2——单纯用“非对称加密算法”的风险 
  说完“对称加密”，再来说说“非对称加密”。  在前面的“  背景知识  ”中，已经大致介绍过“非对称加密”的特点——“加密和解密采用不同的密钥”。基于这个特点，可以避开前面提到的“循环逻辑”的困境。大致的步骤如下：      

    第1步
     网站服务器先基于“非对称加密算法”，随机生成一个“密钥对”（为叙述方便，称之为“k1 和 k2”）。因为是随机生成的，目前为止，只有网站服务器才知道 k1 和 k2。   
    第2步
     网站把 k1 保留在自己手中，把 k2 用【明文】的方式发送给访问者的浏览器。  因为 k2 是明文发送的，自然有可能被偷窥。不过不要紧。即使偷窥者拿到 k2，也【很难】根据 k2 推算出 k1  （这一点是由“非对称加密算法”从数学上保证的）。   
    第3步
     浏览器拿到 k2 之后，先【随机生成】第三个对称加密的密钥（简称 k）。  然后用 k2 加密 k，得到 k'（k' 是 k 的加密结果）  浏览器把 k' 发送给网站服务器。   由于 k1 和 k2 是成对的，所以只有 k1 才能解密 k2 的加密结果。  因此这个过程中，即使被第三方偷窥，第三方也【无法】从 k' 解密得到 k   
    第4步
     网站服务器拿到 k' 之后，用 k1 进行解密，得到 k  至此，浏览器和网站服务器就完成了密钥交换，双方都知道 k，而且【貌似】第三方无法拿到 k  然后，双方就可以用 k 来进行数据双向传输的加密。    
  
   现在，给大伙儿留一点【思考时间】——你觉得上述过程是否严密？如果不严密，漏洞在哪里？
     建   议   你   思   考   一   柱   香   的   时   间   ，   再   来   看   答   案   OK，现在俺来揭晓答案（希望你没有事先偷看）  
   “方案2”依然是【不】安全滴
   ——虽然“方案2”可以在一定程度上防止网络数据的“偷窥/嗅探”，但是【无法】防范网络数据的【篡改】。  假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间，并且这个攻击者具备“【修改】双方传输数据”的能力。那么，这个攻击者就可以攻破“方案2”。具体的攻击过程如下：       

    第1步
     这一步跟原先一样——服务器先随机生成一个“非对称的密钥对”k1 和 k2（此时只有网站知道 k1 和 k2）   
    第2步
     当网站发送 k2 给浏览器的时候，攻击者截获 k2，保留在自己手上。  然后攻击者自己生成一个【伪造的】密钥对（以下称为 pk1 和 pk2）。  攻击者把 pk2 发送给浏览器。   
    第3步
     浏览器收到 pk2，以为 pk2 就是网站发送的。  浏览器不知情，依旧随机生成一个对称加密的密钥 k，然后用 pk2 加密 k，得到密文的 k'  浏览器把 k' 发送给网站。  （以下是关键）  发送的过程中，再次被攻击者截获。  因为 pk1 pk2 都是攻击者自己生成的，所以攻击者自然就可以用 pk1 来解密 k' 得到 k  然后，攻击者拿到 k 之后，用之前截获的 k2 重新加密，得到 k''，并把 k'' 发送给网站。   
    第4步
     网站服务器收到了 k'' 之后，用自己保存的 k1 可以正常解密，所以网站方面不会起疑心。  至此，攻击者完成了一次漂亮的偷梁换柱，而且让双方都没有起疑心。    
  
   上述过程，也就是传说中大名鼎鼎的“中间人攻击”
   。洋文叫做“Man-In-The-Middle attack”。缩写是 MITM。  “中间人攻击”有很多种“类型”，刚才演示的是针对“【单纯的】非对称加密”的中间人攻击。至于“中间人攻击”的其它类型，俺在  本系列  的后续博文中，还会再提到。   为了更加形象，补充两张示意图，分别对应“偷窥模式”和“中间人模式”。让你更直观地体会两者的差异。        
      
        ★方案2失败的根源——缺乏【可靠的】身份认证 
  为啥“方案2”会失败？  除了俺在图中提到的“攻击者具备篡改数据的能力”，还有另一点关键点——“方案2缺乏身份认证机制”。  正是因为“缺乏身份认证机制”，所以当攻击者一开始截获 k2 并把自己伪造的 pk2 发送给浏览器时，浏览器无法鉴别：自己收到的密钥是不是真的来自于网站服务器。  假如具备某种【可靠的】身份认证机制，即使攻击者能够篡改数据，但是篡改之后的数据很容易被识破。那篡改也就失去了意义。         ★身份认证的几种方式 
  下面，俺来介绍几种常见的“身份认证原理”。        ◇基于某些“私密的共享信息” 
  为了解释“私密的共享信息”这个概念，咱们先抛开“信息安全”，谈谈日常生活中的某个场景。  假设你有一个久未联系的老朋友。因为时间久远，你已经没有此人的联系方式了。某天，此人突然给你发了一封电子邮件。  那么，你如何确保——发邮件的人确实是你的老朋友捏？  有一个办法就是：你用邮件向对方询问某个私密的事情（这个事情只有你和你的这个朋友知道，其他人不知道）。如果对方能够回答出来，那么对方【很有可能】确实是你的老朋友。  从这个例子可以看出，如果通讯双方具有某些“私密的共享信息”（只有双方知道，第三方不知道），就能以此为基础，进行身份认证，从而建立信任。        ◇基于双方都信任的“公证人” 
  “私密的共享信息”，通常需要双方互相比较熟悉，才行得通。如果双方本来就互不相识，如何进行身份认证以建立信任关系捏？  这时候还有另一个办法——依靠双方都信任的某个“公证人”来建立信任关系。  如今 C2C 模式的电子商务，其实用的就是这种方式——由电商平台充当公证人，让买家与卖家建立某种程度的信任关系。  考虑到如今的网购已经相当普及，大伙儿应该对这类模式很熟悉吧。所以俺就不浪费口水了。         ★如何解决 SSL 的【身份认证】问题——CA 的引入 
  说完身份认证的方式/原理，再回到 SSL/TLS 的话题上。  对于 SSL/TLS 的应用场景，由于双方（“浏览器”和“网站服务器”）通常都是素不相识滴，显然【不可能】采用第一种方式（私密的共享信息），而只能采用第二种方式（依赖双方都信任的“公证人”）。  那么，谁来充当这个公证人捏？这时候，CA 就华丽地登场啦。  所谓的 CA，就是“数字证书认证机构”的缩写，洋文全称叫做“Certificate Authority”。关于 CA 以及 CA 颁发的“CA 证书”，俺已经写过一篇教程：《  数字证书及 CA 的扫盲介绍  》，介绍其基本概念和功能。所以，此处就不再重复唠叨了。  如果你看完那篇 CA 的扫盲，你自然就明白——CA 完全有资格和能力，充当这个“公证人”的角色。         ★方案3——基于 CA 证书进行密钥交换 
  其实“方案3”跟“方案2”很像的，主要差别在于——“方案3”增加了“CA 数字证书”这个环节。所谓的数字证书，技术上依赖的还是前面提到的“非对称加密”。为了描述“CA 证书”在 SSL/TLS 中的作用，俺大致说一下原理（仅仅是原理，具体的技术实现要略复杂些）：      

    第1步（这是“一次性”的准备工作）
     网站方面首先要花一笔银子，在某个 CA 那里购买一个数字证书。  该证书通常会对应几个文件：其中一个文件包含公钥，还有一个文件包含私钥。  此处的“私钥”，相当于“方案2”里面的 k1；而“公钥”类似于“方案2”里面的 k2。  网站方面必须在 Web 服务器上部署这两个文件。   所谓的“公钥”，顾名思义就是可以公开的 key；而所谓的“私钥”就是私密的 key。  其实前面已经说过了，这里再唠叨一下：  “非对称加密算法”从数学上确保了——即使你知道某个公钥，也很难（不是不可能，是很难）根据此公钥推导出对应的私钥。   
    第2步
     当浏览器访问该网站，Web 服务器首先把包含公钥的证书发送给浏览器。   
    第3步
     浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。  由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。   为啥浏览器能发现 CA 证书是否有诈？  因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。  （比如 Windows 中就内置了几十个权威 CA 的根证书）  因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。  （关于“根证书”和“证书信任链”的概念，请参见之前的教程《  数字证书及CA的扫盲介绍  》）   
    第4步
     如果网站发过来的 CA 证书没有问题，那么浏览器就从该 CA 证书中提取出“公钥”。  然后浏览器随机生成一个“对称加密的密钥”（以下称为 k）。用 CA 证书的公钥加密 k，得到密文 k'  浏览器把 k' 发送给网站。   
    第5步
     网站收到浏览器发过来的 k'，用服务器上的私钥进行解密，得到 k。  至此，浏览器和网站都拥有 k，“密钥交换”大功告成啦。    
  可能有同学会问：那么“方案3”是否就足够严密，无懈可击了捏？  俺只能说，“方案3”【从理论上讲】没有明显的漏洞。实际上 SSL 的早期版本（SSLv2）使用 RSA 进行身份认知和密钥交换，其原理与这个“方案3”类似。  但是，“理论”一旦落实到“实践”，往往是有差距滴，会引出新的问题。套用某 IT 大牛的名言，就是：  In theory, there is no difference between theory and practice. But in practice, there is.   所以在本系列的后续博文，俺还会再来介绍“针对 SSL/TLS 的种种攻击方式”以及“对应的防范措施”。         ★关于“客户端证书”的补充说明 
  前面介绍的“方案3”仅仅使用了“服务端证书”——通过服务端证书来确保服务器不是假冒的。  除了“服务端证书”，在某些场合中还会涉及到“客户端证书”。所谓的“客户端证书”就是用来证明客户端（浏览器端）访问者的身份。  比如在某些金融公司的内网，你的电脑上必须部署“客户端证书”，才能打开重要服务器的页面。  由于本文主要介绍的是【公网】上的场景，这种场景下大都【不需要】“客户端证书”。所以，对“客户端证书”这个话题，俺就偷个懒，略过不提。         ★总结 
  在本文结尾，来稍微总结一下：  如果没有引入某种身份认证机制，必定会导致“中间人攻击”。这种情况下，加密算法搞得再强大，也是然并卵。  本文介绍了两种身份认证的思路，分别是：  1、基于私密的共享信息；  2、基于双方都信任的公证人。  前者【不】适合用于互联网通讯，所以必须采用后者。也就是如今广泛使用的 CA 证书体系。CA 就是上述所说的“双方都信任的公证人”。   下一篇，扫盲几种“  密钥交换协议的算法  ”。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性" />
    <meta property="twitter:title" content="扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17499)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2014%2F11%2Fhttps-ssl-tls-2.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html&text=扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html&title=扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html&title=扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性&body=

      扫盲 HTTPS 和 SSL/TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性  
  
    
      
    
  
  
     ★先插播一个安全通告 
  就在  本系列  刚开播之后没几天（11月11日），微软爆了一个  跟 SSL/TLS 相关的高危漏洞  ， 
   影响【几乎所有的】Windows 平台
   。至此，【所有】主流的 SSL/TLS 协议栈（至少包括：开源的 OpenSSL、开源的 GnuTLS、微软的 SSP、苹果的 SecureTransport），全都在今年爆了高危漏洞。（看来俺这个系列生逢其时啊）  个人觉得：【2014年】必将在信息安全历史上留下醒目的记录。  用 Windows 系统的同学，这几天要尽快升级微软的“安全更新”。因为该漏洞会导致“远程代码执行”，非常危险。  （微软的公告中没有提及 Win2000 和 WinXP 是因为这俩已经过了“产品支持周期”。【不】等于说这俩没问题）       
 在  本系列的前一篇  ，已经介绍了相关的背景知识以及设计 SSL 需要考虑的需求。当时俺提到：设计 HTTPS 的最大难点（没有之一）是——如何在互联网上进行安全的“密钥交换”。今天就来讲讲密钥交换的难点和解决方法（暂不谈技术实现）。  
       
        ★方案1——单纯用“对称加密算法”的可行性 
  首先简单阐述一下，“单纯用对称加密”为啥是【不可行】滴。  如果“单纯用对称加密”，浏览器和网站之间势必先要交换“对称加密的密钥”。  如果这个密钥直接用【明文】传输，很容易就会被第三方（有可能是“攻击者”）偷窥到；如果这个密钥用密文传输，那就再次引入了“如何交换加密密钥”的问题——这就变成“先有鸡还是先有蛋”的循环逻辑了。  所以，【单纯用】对称加密，是没戏滴。         ★方案2——单纯用“非对称加密算法”的风险 
  说完“对称加密”，再来说说“非对称加密”。  在前面的“  背景知识  ”中，已经大致介绍过“非对称加密”的特点——“加密和解密采用不同的密钥”。基于这个特点，可以避开前面提到的“循环逻辑”的困境。大致的步骤如下：      

    第1步
     网站服务器先基于“非对称加密算法”，随机生成一个“密钥对”（为叙述方便，称之为“k1 和 k2”）。因为是随机生成的，目前为止，只有网站服务器才知道 k1 和 k2。   
    第2步
     网站把 k1 保留在自己手中，把 k2 用【明文】的方式发送给访问者的浏览器。  因为 k2 是明文发送的，自然有可能被偷窥。不过不要紧。即使偷窥者拿到 k2，也【很难】根据 k2 推算出 k1  （这一点是由“非对称加密算法”从数学上保证的）。   
    第3步
     浏览器拿到 k2 之后，先【随机生成】第三个对称加密的密钥（简称 k）。  然后用 k2 加密 k，得到 k'（k' 是 k 的加密结果）  浏览器把 k' 发送给网站服务器。   由于 k1 和 k2 是成对的，所以只有 k1 才能解密 k2 的加密结果。  因此这个过程中，即使被第三方偷窥，第三方也【无法】从 k' 解密得到 k   
    第4步
     网站服务器拿到 k' 之后，用 k1 进行解密，得到 k  至此，浏览器和网站服务器就完成了密钥交换，双方都知道 k，而且【貌似】第三方无法拿到 k  然后，双方就可以用 k 来进行数据双向传输的加密。    
  
   现在，给大伙儿留一点【思考时间】——你觉得上述过程是否严密？如果不严密，漏洞在哪里？
     建   议   你   思   考   一   柱   香   的   时   间   ，   再   来   看   答   案   OK，现在俺来揭晓答案（希望你没有事先偷看）  
   “方案2”依然是【不】安全滴
   ——虽然“方案2”可以在一定程度上防止网络数据的“偷窥/嗅探”，但是【无法】防范网络数据的【篡改】。  假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间，并且这个攻击者具备“【修改】双方传输数据”的能力。那么，这个攻击者就可以攻破“方案2”。具体的攻击过程如下：       

    第1步
     这一步跟原先一样——服务器先随机生成一个“非对称的密钥对”k1 和 k2（此时只有网站知道 k1 和 k2）   
    第2步
     当网站发送 k2 给浏览器的时候，攻击者截获 k2，保留在自己手上。  然后攻击者自己生成一个【伪造的】密钥对（以下称为 pk1 和 pk2）。  攻击者把 pk2 发送给浏览器。   
    第3步
     浏览器收到 pk2，以为 pk2 就是网站发送的。  浏览器不知情，依旧随机生成一个对称加密的密钥 k，然后用 pk2 加密 k，得到密文的 k'  浏览器把 k' 发送给网站。  （以下是关键）  发送的过程中，再次被攻击者截获。  因为 pk1 pk2 都是攻击者自己生成的，所以攻击者自然就可以用 pk1 来解密 k' 得到 k  然后，攻击者拿到 k 之后，用之前截获的 k2 重新加密，得到 k''，并把 k'' 发送给网站。   
    第4步
     网站服务器收到了 k'' 之后，用自己保存的 k1 可以正常解密，所以网站方面不会起疑心。  至此，攻击者完成了一次漂亮的偷梁换柱，而且让双方都没有起疑心。    
  
   上述过程，也就是传说中大名鼎鼎的“中间人攻击”
   。洋文叫做“Man-In-The-Middle attack”。缩写是 MITM。  “中间人攻击”有很多种“类型”，刚才演示的是针对“【单纯的】非对称加密”的中间人攻击。至于“中间人攻击”的其它类型，俺在  本系列  的后续博文中，还会再提到。   为了更加形象，补充两张示意图，分别对应“偷窥模式”和“中间人模式”。让你更直观地体会两者的差异。        
      
        ★方案2失败的根源——缺乏【可靠的】身份认证 
  为啥“方案2”会失败？  除了俺在图中提到的“攻击者具备篡改数据的能力”，还有另一点关键点——“方案2缺乏身份认证机制”。  正是因为“缺乏身份认证机制”，所以当攻击者一开始截获 k2 并把自己伪造的 pk2 发送给浏览器时，浏览器无法鉴别：自己收到的密钥是不是真的来自于网站服务器。  假如具备某种【可靠的】身份认证机制，即使攻击者能够篡改数据，但是篡改之后的数据很容易被识破。那篡改也就失去了意义。         ★身份认证的几种方式 
  下面，俺来介绍几种常见的“身份认证原理”。        ◇基于某些“私密的共享信息” 
  为了解释“私密的共享信息”这个概念，咱们先抛开“信息安全”，谈谈日常生活中的某个场景。  假设你有一个久未联系的老朋友。因为时间久远，你已经没有此人的联系方式了。某天，此人突然给你发了一封电子邮件。  那么，你如何确保——发邮件的人确实是你的老朋友捏？  有一个办法就是：你用邮件向对方询问某个私密的事情（这个事情只有你和你的这个朋友知道，其他人不知道）。如果对方能够回答出来，那么对方【很有可能】确实是你的老朋友。  从这个例子可以看出，如果通讯双方具有某些“私密的共享信息”（只有双方知道，第三方不知道），就能以此为基础，进行身份认证，从而建立信任。        ◇基于双方都信任的“公证人” 
  “私密的共享信息”，通常需要双方互相比较熟悉，才行得通。如果双方本来就互不相识，如何进行身份认证以建立信任关系捏？  这时候还有另一个办法——依靠双方都信任的某个“公证人”来建立信任关系。  如今 C2C 模式的电子商务，其实用的就是这种方式——由电商平台充当公证人，让买家与卖家建立某种程度的信任关系。  考虑到如今的网购已经相当普及，大伙儿应该对这类模式很熟悉吧。所以俺就不浪费口水了。         ★如何解决 SSL 的【身份认证】问题——CA 的引入 
  说完身份认证的方式/原理，再回到 SSL/TLS 的话题上。  对于 SSL/TLS 的应用场景，由于双方（“浏览器”和“网站服务器”）通常都是素不相识滴，显然【不可能】采用第一种方式（私密的共享信息），而只能采用第二种方式（依赖双方都信任的“公证人”）。  那么，谁来充当这个公证人捏？这时候，CA 就华丽地登场啦。  所谓的 CA，就是“数字证书认证机构”的缩写，洋文全称叫做“Certificate Authority”。关于 CA 以及 CA 颁发的“CA 证书”，俺已经写过一篇教程：《  数字证书及 CA 的扫盲介绍  》，介绍其基本概念和功能。所以，此处就不再重复唠叨了。  如果你看完那篇 CA 的扫盲，你自然就明白——CA 完全有资格和能力，充当这个“公证人”的角色。         ★方案3——基于 CA 证书进行密钥交换 
  其实“方案3”跟“方案2”很像的，主要差别在于——“方案3”增加了“CA 数字证书”这个环节。所谓的数字证书，技术上依赖的还是前面提到的“非对称加密”。为了描述“CA 证书”在 SSL/TLS 中的作用，俺大致说一下原理（仅仅是原理，具体的技术实现要略复杂些）：      

    第1步（这是“一次性”的准备工作）
     网站方面首先要花一笔银子，在某个 CA 那里购买一个数字证书。  该证书通常会对应几个文件：其中一个文件包含公钥，还有一个文件包含私钥。  此处的“私钥”，相当于“方案2”里面的 k1；而“公钥”类似于“方案2”里面的 k2。  网站方面必须在 Web 服务器上部署这两个文件。   所谓的“公钥”，顾名思义就是可以公开的 key；而所谓的“私钥”就是私密的 key。  其实前面已经说过了，这里再唠叨一下：  “非对称加密算法”从数学上确保了——即使你知道某个公钥，也很难（不是不可能，是很难）根据此公钥推导出对应的私钥。   
    第2步
     当浏览器访问该网站，Web 服务器首先把包含公钥的证书发送给浏览器。   
    第3步
     浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。  由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。   为啥浏览器能发现 CA 证书是否有诈？  因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。  （比如 Windows 中就内置了几十个权威 CA 的根证书）  因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。  （关于“根证书”和“证书信任链”的概念，请参见之前的教程《  数字证书及CA的扫盲介绍  》）   
    第4步
     如果网站发过来的 CA 证书没有问题，那么浏览器就从该 CA 证书中提取出“公钥”。  然后浏览器随机生成一个“对称加密的密钥”（以下称为 k）。用 CA 证书的公钥加密 k，得到密文 k'  浏览器把 k' 发送给网站。   
    第5步
     网站收到浏览器发过来的 k'，用服务器上的私钥进行解密，得到 k。  至此，浏览器和网站都拥有 k，“密钥交换”大功告成啦。    
  可能有同学会问：那么“方案3”是否就足够严密，无懈可击了捏？  俺只能说，“方案3”【从理论上讲】没有明显的漏洞。实际上 SSL 的早期版本（SSLv2）使用 RSA 进行身份认知和密钥交换，其原理与这个“方案3”类似。  但是，“理论”一旦落实到“实践”，往往是有差距滴，会引出新的问题。套用某 IT 大牛的名言，就是：  In theory, there is no difference between theory and practice. But in practice, there is.   所以在本系列的后续博文，俺还会再来介绍“针对 SSL/TLS 的种种攻击方式”以及“对应的防范措施”。         ★关于“客户端证书”的补充说明 
  前面介绍的“方案3”仅仅使用了“服务端证书”——通过服务端证书来确保服务器不是假冒的。  除了“服务端证书”，在某些场合中还会涉及到“客户端证书”。所谓的“客户端证书”就是用来证明客户端（浏览器端）访问者的身份。  比如在某些金融公司的内网，你的电脑上必须部署“客户端证书”，才能打开重要服务器的页面。  由于本文主要介绍的是【公网】上的场景，这种场景下大都【不需要】“客户端证书”。所以，对“客户端证书”这个话题，俺就偷个懒，略过不提。         ★总结 
  在本文结尾，来稍微总结一下：  如果没有引入某种身份认证机制，必定会导致“中间人攻击”。这种情况下，加密算法搞得再强大，也是然并卵。  本文介绍了两种身份认证的思路，分别是：  1、基于私密的共享信息；  2、基于双方都信任的公证人。  前者【不】适合用于互联网通讯，所以必须采用后者。也就是如今广泛使用的 CA 证书体系。CA 就是上述所说的“双方都信任的公证人”。   下一篇，扫盲几种“  密钥交换协议的算法  ”。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html&title=扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性&caption=

      扫盲 HTTPS 和 SSL/TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性  
  
    
      
    
  
  
     ★先插播一个安全通告 
  就在  本系列  刚开播之后没几天（11月11日），微软爆了一个  跟 SSL/TLS 相关的高危漏洞  ， 
   影响【几乎所有的】Windows 平台
   。至此，【所有】主流的 SSL/TLS 协议栈（至少包括：开源的 OpenSSL、开源的 GnuTLS、微软的 SSP、苹果的 SecureTransport），全都在今年爆了高危漏洞。（看来俺这个系列生逢其时啊）  个人觉得：【2014年】必将在信息安全历史上留下醒目的记录。  用 Windows 系统的同学，这几天要尽快升级微软的“安全更新”。因为该漏洞会导致“远程代码执行”，非常危险。  （微软的公告中没有提及 Win2000 和 WinXP 是因为这俩已经过了“产品支持周期”。【不】等于说这俩没问题）       
 在  本系列的前一篇  ，已经介绍了相关的背景知识以及设计 SSL 需要考虑的需求。当时俺提到：设计 HTTPS 的最大难点（没有之一）是——如何在互联网上进行安全的“密钥交换”。今天就来讲讲密钥交换的难点和解决方法（暂不谈技术实现）。  
       
        ★方案1——单纯用“对称加密算法”的可行性 
  首先简单阐述一下，“单纯用对称加密”为啥是【不可行】滴。  如果“单纯用对称加密”，浏览器和网站之间势必先要交换“对称加密的密钥”。  如果这个密钥直接用【明文】传输，很容易就会被第三方（有可能是“攻击者”）偷窥到；如果这个密钥用密文传输，那就再次引入了“如何交换加密密钥”的问题——这就变成“先有鸡还是先有蛋”的循环逻辑了。  所以，【单纯用】对称加密，是没戏滴。         ★方案2——单纯用“非对称加密算法”的风险 
  说完“对称加密”，再来说说“非对称加密”。  在前面的“  背景知识  ”中，已经大致介绍过“非对称加密”的特点——“加密和解密采用不同的密钥”。基于这个特点，可以避开前面提到的“循环逻辑”的困境。大致的步骤如下：      

    第1步
     网站服务器先基于“非对称加密算法”，随机生成一个“密钥对”（为叙述方便，称之为“k1 和 k2”）。因为是随机生成的，目前为止，只有网站服务器才知道 k1 和 k2。   
    第2步
     网站把 k1 保留在自己手中，把 k2 用【明文】的方式发送给访问者的浏览器。  因为 k2 是明文发送的，自然有可能被偷窥。不过不要紧。即使偷窥者拿到 k2，也【很难】根据 k2 推算出 k1  （这一点是由“非对称加密算法”从数学上保证的）。   
    第3步
     浏览器拿到 k2 之后，先【随机生成】第三个对称加密的密钥（简称 k）。  然后用 k2 加密 k，得到 k'（k' 是 k 的加密结果）  浏览器把 k' 发送给网站服务器。   由于 k1 和 k2 是成对的，所以只有 k1 才能解密 k2 的加密结果。  因此这个过程中，即使被第三方偷窥，第三方也【无法】从 k' 解密得到 k   
    第4步
     网站服务器拿到 k' 之后，用 k1 进行解密，得到 k  至此，浏览器和网站服务器就完成了密钥交换，双方都知道 k，而且【貌似】第三方无法拿到 k  然后，双方就可以用 k 来进行数据双向传输的加密。    
  
   现在，给大伙儿留一点【思考时间】——你觉得上述过程是否严密？如果不严密，漏洞在哪里？
     建   议   你   思   考   一   柱   香   的   时   间   ，   再   来   看   答   案   OK，现在俺来揭晓答案（希望你没有事先偷看）  
   “方案2”依然是【不】安全滴
   ——虽然“方案2”可以在一定程度上防止网络数据的“偷窥/嗅探”，但是【无法】防范网络数据的【篡改】。  假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间，并且这个攻击者具备“【修改】双方传输数据”的能力。那么，这个攻击者就可以攻破“方案2”。具体的攻击过程如下：       

    第1步
     这一步跟原先一样——服务器先随机生成一个“非对称的密钥对”k1 和 k2（此时只有网站知道 k1 和 k2）   
    第2步
     当网站发送 k2 给浏览器的时候，攻击者截获 k2，保留在自己手上。  然后攻击者自己生成一个【伪造的】密钥对（以下称为 pk1 和 pk2）。  攻击者把 pk2 发送给浏览器。   
    第3步
     浏览器收到 pk2，以为 pk2 就是网站发送的。  浏览器不知情，依旧随机生成一个对称加密的密钥 k，然后用 pk2 加密 k，得到密文的 k'  浏览器把 k' 发送给网站。  （以下是关键）  发送的过程中，再次被攻击者截获。  因为 pk1 pk2 都是攻击者自己生成的，所以攻击者自然就可以用 pk1 来解密 k' 得到 k  然后，攻击者拿到 k 之后，用之前截获的 k2 重新加密，得到 k''，并把 k'' 发送给网站。   
    第4步
     网站服务器收到了 k'' 之后，用自己保存的 k1 可以正常解密，所以网站方面不会起疑心。  至此，攻击者完成了一次漂亮的偷梁换柱，而且让双方都没有起疑心。    
  
   上述过程，也就是传说中大名鼎鼎的“中间人攻击”
   。洋文叫做“Man-In-The-Middle attack”。缩写是 MITM。  “中间人攻击”有很多种“类型”，刚才演示的是针对“【单纯的】非对称加密”的中间人攻击。至于“中间人攻击”的其它类型，俺在  本系列  的后续博文中，还会再提到。   为了更加形象，补充两张示意图，分别对应“偷窥模式”和“中间人模式”。让你更直观地体会两者的差异。        
      
        ★方案2失败的根源——缺乏【可靠的】身份认证 
  为啥“方案2”会失败？  除了俺在图中提到的“攻击者具备篡改数据的能力”，还有另一点关键点——“方案2缺乏身份认证机制”。  正是因为“缺乏身份认证机制”，所以当攻击者一开始截获 k2 并把自己伪造的 pk2 发送给浏览器时，浏览器无法鉴别：自己收到的密钥是不是真的来自于网站服务器。  假如具备某种【可靠的】身份认证机制，即使攻击者能够篡改数据，但是篡改之后的数据很容易被识破。那篡改也就失去了意义。         ★身份认证的几种方式 
  下面，俺来介绍几种常见的“身份认证原理”。        ◇基于某些“私密的共享信息” 
  为了解释“私密的共享信息”这个概念，咱们先抛开“信息安全”，谈谈日常生活中的某个场景。  假设你有一个久未联系的老朋友。因为时间久远，你已经没有此人的联系方式了。某天，此人突然给你发了一封电子邮件。  那么，你如何确保——发邮件的人确实是你的老朋友捏？  有一个办法就是：你用邮件向对方询问某个私密的事情（这个事情只有你和你的这个朋友知道，其他人不知道）。如果对方能够回答出来，那么对方【很有可能】确实是你的老朋友。  从这个例子可以看出，如果通讯双方具有某些“私密的共享信息”（只有双方知道，第三方不知道），就能以此为基础，进行身份认证，从而建立信任。        ◇基于双方都信任的“公证人” 
  “私密的共享信息”，通常需要双方互相比较熟悉，才行得通。如果双方本来就互不相识，如何进行身份认证以建立信任关系捏？  这时候还有另一个办法——依靠双方都信任的某个“公证人”来建立信任关系。  如今 C2C 模式的电子商务，其实用的就是这种方式——由电商平台充当公证人，让买家与卖家建立某种程度的信任关系。  考虑到如今的网购已经相当普及，大伙儿应该对这类模式很熟悉吧。所以俺就不浪费口水了。         ★如何解决 SSL 的【身份认证】问题——CA 的引入 
  说完身份认证的方式/原理，再回到 SSL/TLS 的话题上。  对于 SSL/TLS 的应用场景，由于双方（“浏览器”和“网站服务器”）通常都是素不相识滴，显然【不可能】采用第一种方式（私密的共享信息），而只能采用第二种方式（依赖双方都信任的“公证人”）。  那么，谁来充当这个公证人捏？这时候，CA 就华丽地登场啦。  所谓的 CA，就是“数字证书认证机构”的缩写，洋文全称叫做“Certificate Authority”。关于 CA 以及 CA 颁发的“CA 证书”，俺已经写过一篇教程：《  数字证书及 CA 的扫盲介绍  》，介绍其基本概念和功能。所以，此处就不再重复唠叨了。  如果你看完那篇 CA 的扫盲，你自然就明白——CA 完全有资格和能力，充当这个“公证人”的角色。         ★方案3——基于 CA 证书进行密钥交换 
  其实“方案3”跟“方案2”很像的，主要差别在于——“方案3”增加了“CA 数字证书”这个环节。所谓的数字证书，技术上依赖的还是前面提到的“非对称加密”。为了描述“CA 证书”在 SSL/TLS 中的作用，俺大致说一下原理（仅仅是原理，具体的技术实现要略复杂些）：      

    第1步（这是“一次性”的准备工作）
     网站方面首先要花一笔银子，在某个 CA 那里购买一个数字证书。  该证书通常会对应几个文件：其中一个文件包含公钥，还有一个文件包含私钥。  此处的“私钥”，相当于“方案2”里面的 k1；而“公钥”类似于“方案2”里面的 k2。  网站方面必须在 Web 服务器上部署这两个文件。   所谓的“公钥”，顾名思义就是可以公开的 key；而所谓的“私钥”就是私密的 key。  其实前面已经说过了，这里再唠叨一下：  “非对称加密算法”从数学上确保了——即使你知道某个公钥，也很难（不是不可能，是很难）根据此公钥推导出对应的私钥。   
    第2步
     当浏览器访问该网站，Web 服务器首先把包含公钥的证书发送给浏览器。   
    第3步
     浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。  由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。   为啥浏览器能发现 CA 证书是否有诈？  因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。  （比如 Windows 中就内置了几十个权威 CA 的根证书）  因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。  （关于“根证书”和“证书信任链”的概念，请参见之前的教程《  数字证书及CA的扫盲介绍  》）   
    第4步
     如果网站发过来的 CA 证书没有问题，那么浏览器就从该 CA 证书中提取出“公钥”。  然后浏览器随机生成一个“对称加密的密钥”（以下称为 k）。用 CA 证书的公钥加密 k，得到密文 k'  浏览器把 k' 发送给网站。   
    第5步
     网站收到浏览器发过来的 k'，用服务器上的私钥进行解密，得到 k。  至此，浏览器和网站都拥有 k，“密钥交换”大功告成啦。    
  可能有同学会问：那么“方案3”是否就足够严密，无懈可击了捏？  俺只能说，“方案3”【从理论上讲】没有明显的漏洞。实际上 SSL 的早期版本（SSLv2）使用 RSA 进行身份认知和密钥交换，其原理与这个“方案3”类似。  但是，“理论”一旦落实到“实践”，往往是有差距滴，会引出新的问题。套用某 IT 大牛的名言，就是：  In theory, there is no difference between theory and practice. But in practice, there is.   所以在本系列的后续博文，俺还会再来介绍“针对 SSL/TLS 的种种攻击方式”以及“对应的防范措施”。         ★关于“客户端证书”的补充说明 
  前面介绍的“方案3”仅仅使用了“服务端证书”——通过服务端证书来确保服务器不是假冒的。  除了“服务端证书”，在某些场合中还会涉及到“客户端证书”。所谓的“客户端证书”就是用来证明客户端（浏览器端）访问者的身份。  比如在某些金融公司的内网，你的电脑上必须部署“客户端证书”，才能打开重要服务器的页面。  由于本文主要介绍的是【公网】上的场景，这种场景下大都【不需要】“客户端证书”。所以，对“客户端证书”这个话题，俺就偷个懒，略过不提。         ★总结 
  在本文结尾，来稍微总结一下：  如果没有引入某种身份认证机制，必定会导致“中间人攻击”。这种情况下，加密算法搞得再强大，也是然并卵。  本文介绍了两种身份认证的思路，分别是：  1、基于私密的共享信息；  2、基于双方都信任的公证人。  前者【不】适合用于互联网通讯，所以必须采用后者。也就是如今广泛使用的 CA 证书体系。CA 就是上述所说的“双方都信任的公证人”。   下一篇，扫盲几种“  密钥交换协议的算法  ”。    回到本系列的目录      

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性&url=https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>扫盲 HTTPS 和 SSL-TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2014-11-15
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="1676644662498898143">
 </a>   <h1 class="post-title entry-title" id="https--ssltls-2--"> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html"> 扫盲 HTTPS 和 SSL/TLS 协议[2]：可靠密钥交换的难点，以及身份认证的必要性 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
    <h2 id="section"> ★先插播一个安全通告 </h2>
 <br /> 就在 <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html#index"> 本系列 </a> 刚开播之后没几天（11月11日），微软爆了一个 <a href="https://technet.microsoft.com/library/security/ms14-066" rel="nofollow" target="_blank"> 跟 SSL/TLS 相关的高危漏洞 </a> ， <b>
   影响【几乎所有的】Windows 平台
  </b> 。至此，【所有】主流的 SSL/TLS 协议栈（至少包括：开源的 OpenSSL、开源的 GnuTLS、微软的 SSP、苹果的 SecureTransport），全都在今年爆了高危漏洞。（看来俺这个系列生逢其时啊） <br /> 个人觉得：【2014年】必将在信息安全历史上留下醒目的记录。 <br /> 用 Windows 系统的同学，这几天要尽快升级微软的“安全更新”。因为该漏洞会导致“远程代码执行”，非常危险。 <br /> （微软的公告中没有提及 Win2000 和 WinXP 是因为这俩已经过了“产品支持周期”。【不】等于说这俩没问题） <br /> <br />     <hr />
 在 <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html"> 本系列的前一篇 </a> ，已经介绍了相关的背景知识以及设计 SSL 需要考虑的需求。当时俺提到：设计 HTTPS 的最大难点（没有之一）是——如何在互联网上进行安全的“密钥交换”。今天就来讲讲密钥交换的难点和解决方法（暂不谈技术实现）。 <br /> <a name="more">
  </a>     <!--program-think-->
 <br /> <br />     <h2 id="section-1"> ★方案1——单纯用“对称加密算法”的可行性 </h2>
 <br /> 首先简单阐述一下，“单纯用对称加密”为啥是【不可行】滴。 <br /> 如果“单纯用对称加密”，浏览器和网站之间势必先要交换“对称加密的密钥”。 <br /> 如果这个密钥直接用【明文】传输，很容易就会被第三方（有可能是“攻击者”）偷窥到；如果这个密钥用密文传输，那就再次引入了“如何交换加密密钥”的问题——这就变成“先有鸡还是先有蛋”的循环逻辑了。 <br /> 所以，【单纯用】对称加密，是没戏滴。 <br /> <br /> <br />     <h2 id="section-2"> ★方案2——单纯用“非对称加密算法”的风险 </h2>
 <br /> 说完“对称加密”，再来说说“非对称加密”。 <br /> 在前面的“ <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html"> 背景知识 </a> ”中，已经大致介绍过“非对称加密”的特点——“加密和解密采用不同的密钥”。基于这个特点，可以避开前面提到的“循环逻辑”的困境。大致的步骤如下： <br />     <blockquote>
<b>
    第1步
   </b> <br /> 网站服务器先基于“非对称加密算法”，随机生成一个“密钥对”（为叙述方便，称之为“k1 和 k2”）。因为是随机生成的，目前为止，只有网站服务器才知道 k1 和 k2。 <br /> <br /> <b>
    第2步
   </b> <br /> 网站把 k1 保留在自己手中，把 k2 用【明文】的方式发送给访问者的浏览器。 <br /> 因为 k2 是明文发送的，自然有可能被偷窥。不过不要紧。即使偷窥者拿到 k2，也【很难】根据 k2 推算出 k1 <br /> （这一点是由“非对称加密算法”从数学上保证的）。 <br /> <br /> <b>
    第3步
   </b> <br /> 浏览器拿到 k2 之后，先【随机生成】第三个对称加密的密钥（简称 k）。 <br /> 然后用 k2 加密 k，得到 k'（k' 是 k 的加密结果） <br /> 浏览器把 k' 发送给网站服务器。 <br /> <br /> 由于 k1 和 k2 是成对的，所以只有 k1 才能解密 k2 的加密结果。 <br /> 因此这个过程中，即使被第三方偷窥，第三方也【无法】从 k' 解密得到 k <br /> <br /> <b>
    第4步
   </b> <br /> 网站服务器拿到 k' 之后，用 k1 进行解密，得到 k <br /> 至此，浏览器和网站服务器就完成了密钥交换，双方都知道 k，而且【貌似】第三方无法拿到 k <br /> 然后，双方就可以用 k 来进行数据双向传输的加密。    </blockquote>
 <br /> <b>
   现在，给大伙儿留一点【思考时间】——你觉得上述过程是否严密？如果不严密，漏洞在哪里？
  </b> <br /> <br /> 建 <br /> <br /> 议 <br /> <br /> 你 <br /> <br /> 思 <br /> <br /> 考 <br /> <br /> 一 <br /> <br /> 柱 <br /> <br /> 香 <br /> <br /> 的 <br /> <br /> 时 <br /> <br /> 间 <br /> <br /> ， <br /> <br /> 再 <br /> <br /> 来 <br /> <br /> 看 <br /> <br /> 答 <br /> <br /> 案 <br /> <br /> OK，现在俺来揭晓答案（希望你没有事先偷看） <br /> <b>
   “方案2”依然是【不】安全滴
  </b> ——虽然“方案2”可以在一定程度上防止网络数据的“偷窥/嗅探”，但是【无法】防范网络数据的【篡改】。 <br /> 假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间，并且这个攻击者具备“【修改】双方传输数据”的能力。那么，这个攻击者就可以攻破“方案2”。具体的攻击过程如下： <br /> <br />     <blockquote>
<b>
    第1步
   </b> <br /> 这一步跟原先一样——服务器先随机生成一个“非对称的密钥对”k1 和 k2（此时只有网站知道 k1 和 k2） <br /> <br /> <b>
    第2步
   </b> <br /> 当网站发送 k2 给浏览器的时候，攻击者截获 k2，保留在自己手上。 <br /> 然后攻击者自己生成一个【伪造的】密钥对（以下称为 pk1 和 pk2）。 <br /> 攻击者把 pk2 发送给浏览器。 <br /> <br /> <b>
    第3步
   </b> <br /> 浏览器收到 pk2，以为 pk2 就是网站发送的。 <br /> 浏览器不知情，依旧随机生成一个对称加密的密钥 k，然后用 pk2 加密 k，得到密文的 k' <br /> 浏览器把 k' 发送给网站。 <br /> （以下是关键） <br /> 发送的过程中，再次被攻击者截获。 <br /> 因为 pk1 pk2 都是攻击者自己生成的，所以攻击者自然就可以用 pk1 来解密 k' 得到 k <br /> 然后，攻击者拿到 k 之后，用之前截获的 k2 重新加密，得到 k''，并把 k'' 发送给网站。 <br /> <br /> <b>
    第4步
   </b> <br /> 网站服务器收到了 k'' 之后，用自己保存的 k1 可以正常解密，所以网站方面不会起疑心。 <br /> 至此，攻击者完成了一次漂亮的偷梁换柱，而且让双方都没有起疑心。    </blockquote>
 <br /> <b>
   上述过程，也就是传说中大名鼎鼎的“中间人攻击”
  </b> 。洋文叫做“Man-In-The-Middle attack”。缩写是 MITM。 <br /> “中间人攻击”有很多种“类型”，刚才演示的是针对“【单纯的】非对称加密”的中间人攻击。至于“中间人攻击”的其它类型，俺在 <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html#index"> 本系列 </a> 的后续博文中，还会再提到。 <br /> <br /> 为了更加形象，补充两张示意图，分别对应“偷窥模式”和“中间人模式”。让你更直观地体会两者的差异。 <br />     <center> <img alt="不见图 请翻墙" src="https://lh6.googleusercontent.com/TgLYAxKnfpV6t0ytFvi9C4DOt5GsEgCvQ-PQzSfQ8QGdhjBOLaWLXBVuCTAd2IAmUnIgyaRPxqv49Prj02gw7K0BhKz-bHQWXCDOx_qH5KpXOAcCDixixeN1RNR3FOzbhsy9" /> </center>
    <center> <img alt="不见图 请翻墙" src="https://lh4.googleusercontent.com/Db13nQFIPF2NxJ518PjXpn24-qKPSTFdFE8tmQQBWOALwTVu6a8e-HILEaLli8SjxE-7AlW8eERL-5xPjCkp1UcH7NM3XPrgWhk0GEEd9w6jP2F3kkeBwxQdpVzxwxGW9S0j" /> </center>
 <br /> <br />     <h2 id="section-3"> ★方案2失败的根源——缺乏【可靠的】身份认证 </h2>
 <br /> 为啥“方案2”会失败？ <br /> 除了俺在图中提到的“攻击者具备篡改数据的能力”，还有另一点关键点——“方案2缺乏身份认证机制”。 <br /> 正是因为“缺乏身份认证机制”，所以当攻击者一开始截获 k2 并把自己伪造的 pk2 发送给浏览器时，浏览器无法鉴别：自己收到的密钥是不是真的来自于网站服务器。 <br /> 假如具备某种【可靠的】身份认证机制，即使攻击者能够篡改数据，但是篡改之后的数据很容易被识破。那篡改也就失去了意义。 <br /> <br /> <br />     <h2 id="section-4"> ★身份认证的几种方式 </h2>
 <br /> 下面，俺来介绍几种常见的“身份认证原理”。 <br /> <br />     <h3 id="section-5"> ◇基于某些“私密的共享信息” </h3>
 <br /> 为了解释“私密的共享信息”这个概念，咱们先抛开“信息安全”，谈谈日常生活中的某个场景。 <br /> 假设你有一个久未联系的老朋友。因为时间久远，你已经没有此人的联系方式了。某天，此人突然给你发了一封电子邮件。 <br /> 那么，你如何确保——发邮件的人确实是你的老朋友捏？ <br /> 有一个办法就是：你用邮件向对方询问某个私密的事情（这个事情只有你和你的这个朋友知道，其他人不知道）。如果对方能够回答出来，那么对方【很有可能】确实是你的老朋友。 <br /> 从这个例子可以看出，如果通讯双方具有某些“私密的共享信息”（只有双方知道，第三方不知道），就能以此为基础，进行身份认证，从而建立信任。 <br /> <br />     <h3 id="section-6"> ◇基于双方都信任的“公证人” </h3>
 <br /> “私密的共享信息”，通常需要双方互相比较熟悉，才行得通。如果双方本来就互不相识，如何进行身份认证以建立信任关系捏？ <br /> 这时候还有另一个办法——依靠双方都信任的某个“公证人”来建立信任关系。 <br /> 如今 C2C 模式的电子商务，其实用的就是这种方式——由电商平台充当公证人，让买家与卖家建立某种程度的信任关系。 <br /> 考虑到如今的网购已经相当普及，大伙儿应该对这类模式很熟悉吧。所以俺就不浪费口水了。 <br /> <br /> <br />     <h2 id="ssl-ca--"> ★如何解决 SSL 的【身份认证】问题——CA 的引入 </h2>
 <br /> 说完身份认证的方式/原理，再回到 SSL/TLS 的话题上。 <br /> 对于 SSL/TLS 的应用场景，由于双方（“浏览器”和“网站服务器”）通常都是素不相识滴，显然【不可能】采用第一种方式（私密的共享信息），而只能采用第二种方式（依赖双方都信任的“公证人”）。 <br /> 那么，谁来充当这个公证人捏？这时候，CA 就华丽地登场啦。 <br /> 所谓的 CA，就是“数字证书认证机构”的缩写，洋文全称叫做“Certificate Authority”。关于 CA 以及 CA 颁发的“CA 证书”，俺已经写过一篇教程：《 <a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html"> 数字证书及 CA 的扫盲介绍 </a> 》，介绍其基本概念和功能。所以，此处就不再重复唠叨了。 <br /> 如果你看完那篇 CA 的扫盲，你自然就明白——CA 完全有资格和能力，充当这个“公证人”的角色。 <br /> <br /> <br />     <h2 id="ca--"> ★方案3——基于 CA 证书进行密钥交换 </h2>
 <br /> 其实“方案3”跟“方案2”很像的，主要差别在于——“方案3”增加了“CA 数字证书”这个环节。所谓的数字证书，技术上依赖的还是前面提到的“非对称加密”。为了描述“CA 证书”在 SSL/TLS 中的作用，俺大致说一下原理（仅仅是原理，具体的技术实现要略复杂些）： <br />     <blockquote>
<b>
    第1步（这是“一次性”的准备工作）
   </b> <br /> 网站方面首先要花一笔银子，在某个 CA 那里购买一个数字证书。 <br /> 该证书通常会对应几个文件：其中一个文件包含公钥，还有一个文件包含私钥。 <br /> 此处的“私钥”，相当于“方案2”里面的 k1；而“公钥”类似于“方案2”里面的 k2。 <br /> 网站方面必须在 Web 服务器上部署这两个文件。 <br /> <br /> 所谓的“公钥”，顾名思义就是可以公开的 key；而所谓的“私钥”就是私密的 key。 <br /> 其实前面已经说过了，这里再唠叨一下： <br /> “非对称加密算法”从数学上确保了——即使你知道某个公钥，也很难（不是不可能，是很难）根据此公钥推导出对应的私钥。 <br /> <br /> <b>
    第2步
   </b> <br /> 当浏览器访问该网站，Web 服务器首先把包含公钥的证书发送给浏览器。 <br /> <br /> <b>
    第3步
   </b> <br /> 浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。 <br /> 由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。 <br /> <br /> 为啥浏览器能发现 CA 证书是否有诈？ <br /> 因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。 <br /> （比如 Windows 中就内置了几十个权威 CA 的根证书） <br /> 因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。 <br /> （关于“根证书”和“证书信任链”的概念，请参见之前的教程《 <a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html"> 数字证书及CA的扫盲介绍 </a> 》） <br /> <br /> <b>
    第4步
   </b> <br /> 如果网站发过来的 CA 证书没有问题，那么浏览器就从该 CA 证书中提取出“公钥”。 <br /> 然后浏览器随机生成一个“对称加密的密钥”（以下称为 k）。用 CA 证书的公钥加密 k，得到密文 k' <br /> 浏览器把 k' 发送给网站。 <br /> <br /> <b>
    第5步
   </b> <br /> 网站收到浏览器发过来的 k'，用服务器上的私钥进行解密，得到 k。 <br /> 至此，浏览器和网站都拥有 k，“密钥交换”大功告成啦。    </blockquote>
 <br /> 可能有同学会问：那么“方案3”是否就足够严密，无懈可击了捏？ <br /> 俺只能说，“方案3”【从理论上讲】没有明显的漏洞。实际上 SSL 的早期版本（SSLv2）使用 RSA 进行身份认知和密钥交换，其原理与这个“方案3”类似。 <br /> 但是，“理论”一旦落实到“实践”，往往是有差距滴，会引出新的问题。套用某 IT 大牛的名言，就是： <q> In theory, there is no difference between theory and practice. But in practice, there is. </q> <br /> 所以在本系列的后续博文，俺还会再来介绍“针对 SSL/TLS 的种种攻击方式”以及“对应的防范措施”。 <br /> <br /> <br />     <h2 id="section-7"> ★关于“客户端证书”的补充说明 </h2>
 <br /> 前面介绍的“方案3”仅仅使用了“服务端证书”——通过服务端证书来确保服务器不是假冒的。 <br /> 除了“服务端证书”，在某些场合中还会涉及到“客户端证书”。所谓的“客户端证书”就是用来证明客户端（浏览器端）访问者的身份。 <br /> 比如在某些金融公司的内网，你的电脑上必须部署“客户端证书”，才能打开重要服务器的页面。 <br /> 由于本文主要介绍的是【公网】上的场景，这种场景下大都【不需要】“客户端证书”。所以，对“客户端证书”这个话题，俺就偷个懒，略过不提。 <br /> <br /> <br />     <h2 id="section-8"> ★总结 </h2>
 <br /> 在本文结尾，来稍微总结一下： <br /> 如果没有引入某种身份认证机制，必定会导致“中间人攻击”。这种情况下，加密算法搞得再强大，也是然并卵。 <br /> 本文介绍了两种身份认证的思路，分别是： <br /> 1、基于私密的共享信息； <br /> 2、基于双方都信任的公证人。 <br /> 前者【不】适合用于互联网通讯，所以必须采用后者。也就是如今广泛使用的 CA 证书体系。CA 就是上述所说的“双方都信任的公证人”。 <br /> <br /> 下一篇，扫盲几种“ <a href="https://program-think.blogspot.com/2016/09/https-ssl-tls-3.html"> 密钥交换协议的算法 </a> ”。 <br /> <br /> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html#index"> 回到本系列的目录 </a>     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2014/11/https-ssl-tls-2.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2014-11-26</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-26/%E8%A2%AB%E5%88%A4-%E8%B0%8B%E5%8F%8D%E7%BD%AA-%E7%9A%84%E9%83%BD%E6%98%AF%E5%93%AA%E4%BA%9B%E4%BA%BA-%E5%8D%B1%E5%AE%B3%E5%9B%BD%E5%AE%B6%E5%AE%89%E5%85%A8%E7%BD%AA-%E5%87%BA%E7%AC%BC20%E5%B9%B4%E9%9A%8F%E6%83%B3/">
          被判“谋反罪”的都是哪些人？——“危害国家安全罪”出笼20年随想
        </a>
      </li>
    
    
      <li>
        <time>2014-11-19</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-19/%E5%90%84%E7%A7%8D%E8%BF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA-%E5%85%9A%E5%9B%BD%E5%96%89%E8%88%8C%E6%AD%A3%E9%80%90%E6%B8%90%E5%A4%B1%E5%8E%BB%E8%88%86%E8%AE%BA%E9%98%B5%E5%9C%B0/">
          各种迹象显示——党国喉舌正逐渐失去舆论阵地
        </a>
      </li>
    
    
      <li>
        <time>2014-11-08</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86-%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%9C%80%E6%B1%82-%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9A%BE%E7%82%B9/">
          扫盲 HTTPS 和 SSL-TLS 协议[1]：背景知识、协议的需求、设计的难点
        </a>
      </li>
    
    
      <li>
        <time>2014-11-08</time>
        <a href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-0-%E5%BC%95%E5%AD%90/">
          扫盲 HTTPS 和 SSL-TLS 协议[0]：引子
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2014-11-15/%E6%97%8F%E7%BE%A4%E6%94%BF%E6%B2%BB-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%89%E4%B8%81%E8%A3%94%E5%92%8C%E4%BA%9A%E8%A3%94%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%96%9C%E6%AC%A2%E6%8A%95%E7%A5%A8%E7%BB%99%E6%9C%AC%E6%97%8F%E5%80%99%E9%80%89%E4%BA%BA/">
            前一篇：族群政治 | 为什么拉丁裔和亚裔美国人喜欢投票给本族候选人？
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2014-11-16/%E8%B5%B5%E5%A3%AB%E5%85%B5-%E8%87%AA%E5%B9%B2%E4%BA%94-%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82%E7%9A%84%E5%9D%9A%E5%AE%9A%E8%B7%B5%E8%A1%8C%E8%80%85/">
            後一篇：赵士兵：“自干五”是社会主义核心价值观的坚定践行者
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2014-11-15/%E6%97%8F%E7%BE%A4%E6%94%BF%E6%B2%BB-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%89%E4%B8%81%E8%A3%94%E5%92%8C%E4%BA%9A%E8%A3%94%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%96%9C%E6%AC%A2%E6%8A%95%E7%A5%A8%E7%BB%99%E6%9C%AC%E6%97%8F%E5%80%99%E9%80%89%E4%BA%BA/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2014-11-16/%E8%B5%B5%E5%A3%AB%E5%85%B5-%E8%87%AA%E5%B9%B2%E4%BA%94-%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82%E7%9A%84%E5%9D%9A%E5%AE%9A%E8%B7%B5%E8%A1%8C%E8%80%85/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2014-11-19/%E5%90%84%E7%A7%8D%E8%BF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA-%E5%85%9A%E5%9B%BD%E5%96%89%E8%88%8C%E6%AD%A3%E9%80%90%E6%B8%90%E5%A4%B1%E5%8E%BB%E8%88%86%E8%AE%BA%E9%98%B5%E5%9C%B0/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86-%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%9C%80%E6%B1%82-%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9A%BE%E7%82%B9/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2014-11-15/%E6%97%8F%E7%BE%A4%E6%94%BF%E6%B2%BB-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%89%E4%B8%81%E8%A3%94%E5%92%8C%E4%BA%9A%E8%A3%94%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%96%9C%E6%AC%A2%E6%8A%95%E7%A5%A8%E7%BB%99%E6%9C%AC%E6%97%8F%E5%80%99%E9%80%89%E4%BA%BA/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2014-11-16/%E8%B5%B5%E5%A3%AB%E5%85%B5-%E8%87%AA%E5%B9%B2%E4%BA%94-%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82%E7%9A%84%E5%9D%9A%E5%AE%9A%E8%B7%B5%E8%A1%8C%E8%80%85/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2014-11-19/%E5%90%84%E7%A7%8D%E8%BF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA-%E5%85%9A%E5%9B%BD%E5%96%89%E8%88%8C%E6%AD%A3%E9%80%90%E6%B8%90%E5%A4%B1%E5%8E%BB%E8%88%86%E8%AE%BA%E9%98%B5%E5%9C%B0/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2014-11-08/%E6%89%AB%E7%9B%B2-HTTPS-%E5%92%8C-SSL-TLS-%E5%8D%8F%E8%AE%AE-1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86-%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%9C%80%E6%B1%82-%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9A%BE%E7%82%B9/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
