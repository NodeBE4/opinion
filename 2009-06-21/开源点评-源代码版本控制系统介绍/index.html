<!DOCTYPE html>
<html>
  <head>
  <title>开源点评：源代码版本控制系统介绍 – 觀點 – 從草根到大師 git.io/JJCxS</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="

      开源点评：源代码版本控制系统介绍  
  
    
      
    
  
  
本文是“  每日构建[4]：相关工具介绍  ”的第一部分。  由于源代码版本控制系统（Revision Control System，以下简称“RCS”）属于“  每日构建流程  ”的头一个环节，所以俺在介绍每日构建的相关工具时，先来聊一聊 RCS 类的软件。 
       
         ★老派的 RCS 
  在整个软件开发的生命周期中，RCS 处于一个很基础的位置。很多软件工程的环节都会依赖于它。所以，RCS 对于整个软件开发过程而言，是非常重要的。但是却有很多软件公司仍然在使用一些比较陈旧落后的 RCS。因此，有必要先抨击一下这些老古董的弊端。        ◇VSS 
  要说老派的 RCS，当仁不让的就是微软的 Visual Source Safe（简称“VSS”）。VSS 的设计是相当的老土，对源代码库的访问是基于局域网的共享文件夹方式。共享文件夹的方式那是要多土有多土：不光效率低下，而且容易产生安全隐患。  光是设计老土也就算了，毕竟人家是九十年代早期设计的，那会儿 TCP/IP 还没流行呢！VSS 还有更严重的问题，那就是：【误导】了开发人员的对于源代码管理的观念（比如它对文件的锁定模式）。估计有很多开发的新手就是这样被带到沟里去的，以至于长期以来，一直有人在为 VSS 的“锁定模式”进行辩护。  当然，VSS 还是有少量优点的，比如：捆绑在 Visual Studio 中，和 VS 的其它套件整合得比较好。但是这少数优点远远不能抵消它那些严重的缺点。因此俺强烈建议：那些还在用 VSS 的同学， 
   赶紧换掉吧
   ！万一让别人知道你还在用 VSS，以后上街都没脸跟人打招呼。如果大伙儿觉得俺说得太夸张，可以去看看牛人 Coding Horror 写的帖子（在“  这里  ”）。        ◇CVS 
  骂完 VSS，再稍微说一下曾经广为流行的 CVS，（官方站点在“  这里  ”）。  CVS 的优点显然比 VSS 多多了。曾几何时，CVS 几乎成了源代码版本管理的代名词。那会儿，大部分的开源项目都使用 CVS 进行代码管理。不过，用的人多了之后，大家开始发现 CVS 的一些弊端（比如不能改名文件/目录、比如不支持对目录的版本控制、比如对 Unicode/UTF8 支持不够好、比如版本提交的原子性、比如......）。  有些人受不了 CVS 的某些缺点，开发了一个改良版的  CVSNT  。这玩意儿俺曾经用过几年，比 CVS 好些，不过几个致命的缺点还在（比如上述提到的改名问题）；还有些人更加激进，干脆另起炉灶，搞出全新的 RCS（比如后面提到的 SVN，就是为了取代 CVS 而设计的）。  据俺的观察，目前 RCS 市场的趋势已经比较明显了：很多后来居上的 RCS 正在逐步侵占 CVS 的市场份额。长此以往，CVS 的人气和份额将会逐年下降。不过它暂时还不会消亡，毕竟还有很多老用户还在用它。  所以，俺对 CVS 的观点是：还在用 CVS 的同学也可以考虑换一换了。不过捏，假如你暂时不想换，问题也不算太大（至少CVS的问题没VSS那么严重 
   :-
   ）。        ★新潮的集中式 RCS 
  批完老派的 RCS，接着来说说近几年比较时髦的 RCS。为了循序渐进，俺先从集中式的 RCS 说起。  在新潮的集中式 RCS 软件中，SVN（全名叫“subversion”）是比较有代表性的（官方站点在"  这里  "）。俺就重点来说说它。        ◇SVN 的优点 
  其实 SVN 相对于 CVS 的优点很多，限于篇幅，俺只挑主要的优点介绍。   
   1、能够导入多种 RCS 的代码库
    稍微懂行的人都知道，RCS 迁移是一项很严肃的事情，不可等闲视之。如果新的 RCS 不能很好地导入原有 RCS 的代码库，那你肯定会死得很难看滴。  SVN 在这点上是比较成功的：由于它的影响力比较大，自然会有一些第三方的工具提供代码库的导入功能。比如  SVN Importer  ，可以把其它很多种 RCS（比如：CVS、PVCS、MKS、ClearCase、SourceSafe）的代码库迁移到 SVN。另外还有  cvs2svn  ，专门用来导入 CVS 代码库。通过这些工具，你可以完整地保留原有代码库的所有历史版本。   
   2、和 CVS 的使用类似
    另外，SVN 的一些常用命令、概念、操作习惯都比较类似于 CVS（当然，差别还是有的）。比如俺在 CVS 下经常使用的  TortoiseCVS  ，也有对应的 SVN 版本（  TortoiseSVN  ）。两者就像双胞胎，连界面风格都很像。所以，开发人员从CVS切换到SVN的学习周期会很短，阻力也会很小。   
   3、支持文件/目录改名
    这个问题一直是 CVS 的致命伤，SVN 没理由不搞定。  有了这个功能之后，就可以直接在客户端进行文件的改名操作。拥有新名称的文件，会继承原有文件的版本历史。   
   4、和Web密切整合
    这年头，Web越来越成为主流、B/S 的操作方式也开始深入人心。SVN 迎合了这种趋势，和 Apache 绑定在一起。由于深度整合了 Web，很多版本管理的操作都可以直接在浏览器上搞定，巨简单的说。另外，Apache 作为头号 Web Server，功能、性能、安全性自然无可挑剔。   
   5、能很好地整合其它的开发工具
    得益于 SVN 的设计理念和开源社区的人气，有越来越多的开发工具都可以和 SVN 无缝整合。比如在 Bug 管理方面，有：  Trac  、  Bugzilla  、  Mantis  ；至于各种编辑器或 IDE 的 SVN 插件，那就更多啦，俺就不一一列举了。        ◇SVN 有些啥缺点 
  
   1、不支持分布式
    这是比较明显的缺点。俺后面会提到，集中式相对于分布式具体有哪些缺点。   
   2、性能
    感觉 SVN 在性能方面不咋滴，包括操作速度和存储空间，都不太理想。如果和后面提到的分布式 RCS 相比，这个缺点会更加明显（尤其是在代码 commit 的时候）。   
   3、到处散落 .svn 目录
    其实这个问题倒不是什么大问题（CVS 也有此毛病）。或许某些有洁癖的人看着那么多 
   .svn
   会很不爽。俺自己倒是无所谓。        ★新潮的分布式 RCS 
       ◇集中式和分布式的区别 
  分布式 RCS 和集中式的主要区别在于：  对于集中式 RCS，只有一个中央代码仓库，每个开发人员自己机器上维护一个工作拷贝（working copy）。开发人员本地的代码在没有提交之前，是无法被RCS管理的，因此就无法进行各种操作（比如创建分支）。一旦你的开发机器和中央代码仓库的网络连接断掉（比如你把笔记本带回家写代码），你就只好干瞪眼，无法进行后续工作。  对于分布式 RCS，每一个开发人员的机器上都有一个代码仓库。你随时都可以提交到本地的代码仓库中。分布式 RCS 可以在网络连通的时候，再进行各个代码仓库之间的数据同步。  为啥这几年，分布式的 RCS 多起来捏？一个主要的推动力来自于开源社区。大部分开源项目的开发人员都分布在世界各地，有些人受限于网络因素，不能很流畅地和代码仓库交换数据。在这种情况下，分布式 RCS 的优点就体现出来了。        ◇哪些公司适合分布式的 RCS 
  俺个人认为，一般的软件公司，使用分布式 RCS 的优点不如开源团队那么明显。但是在如下几种情况，你可以考虑采用分布式 RCS。  1、开发团队的地域性分隔  比如公司的开发团队分散在不同的城市，而且互相之间的网络连接不稳定。这有点类似于开源项目的团队，因此可以考虑采用分布式 RCS。  2、在公司之外开发  所谓的“在公司之外开发”，主要有如下几种情况：比如开发人员喜欢在回家之后干活、比如开发人员经常去客户现场干活、比如公司雇佣兼职人员在家干活。  不过这些情况都有一个前提条件，那就是：公司既没有搭建 VPN，而 RCS 又无法从公网上访问。在这种情况下，才值得用分布式 RCS。        ◇几个常见的分布式 RCS 
  分布式的 RCS，名气比较大的有：Git、Mercurial、Monotone、Bazaar。下面俺大致说一下头两个。  
   1、Git
    （官方站点在“  这里  ”）  俺个人感觉，Git 的最大亮点和卖点就是：它的创始人是 Linus。单凭 Linus 这块金字招牌，Git 就吸引到很多人气。而且 Git 在各方面的功能还是比较齐全的。  它的主要缺点就是：对 Windows 系统支持不太好（想想也是，Linus 本人是 Linux 它爹，对 Windows 支持不好也在情理之中啊）。不过现在情况略有好转：Windows 下的 GUI 客户端  TortoiseGit  才刚出来不久，将来如果能做到像  TortoiseSVN  那么成功，那 Git 在 Windows 下就前途光明了。  Git 的成功应用案例，俺不说大伙儿应该猜得到是：Linux Kernel。光这一个就足够说明问题了。   
   2、Mercurial
    （官方站点在“  这里  ”）  Mercurial 是另一个比较牛的分布式 RCS。它还有一个绰号叫 Hg。化学比较好的同学，应该会立马联想到：Hg 是元素周期表中“水银”的缩写。  Mercurial 的特色是基于 Python 开发，所以它在跨平台方面，会比较有优势。另外，它在 Windows 上的 GUI 客户端  TortoiseHg  也比  TortoiseGit  要成熟一些。  Mercurial 相对于 Git 的缺点是性能不够好。没准和基于 Python 开发有关，不过也有可能是 Git 的性能太过优秀。  Mercurial 的成功应用案例有：Mozilla、OpenSolaris、NetBeans。这几个也都是重量级的项目。     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    <meta property="og:description" content="

      开源点评：源代码版本控制系统介绍  
  
    
      
    
  
  
本文是“  每日构建[4]：相关工具介绍  ”的第一部分。  由于源代码版本控制系统（Revision Control System，以下简称“RCS”）属于“  每日构建流程  ”的头一个环节，所以俺在介绍每日构建的相关工具时，先来聊一聊 RCS 类的软件。 
       
         ★老派的 RCS 
  在整个软件开发的生命周期中，RCS 处于一个很基础的位置。很多软件工程的环节都会依赖于它。所以，RCS 对于整个软件开发过程而言，是非常重要的。但是却有很多软件公司仍然在使用一些比较陈旧落后的 RCS。因此，有必要先抨击一下这些老古董的弊端。        ◇VSS 
  要说老派的 RCS，当仁不让的就是微软的 Visual Source Safe（简称“VSS”）。VSS 的设计是相当的老土，对源代码库的访问是基于局域网的共享文件夹方式。共享文件夹的方式那是要多土有多土：不光效率低下，而且容易产生安全隐患。  光是设计老土也就算了，毕竟人家是九十年代早期设计的，那会儿 TCP/IP 还没流行呢！VSS 还有更严重的问题，那就是：【误导】了开发人员的对于源代码管理的观念（比如它对文件的锁定模式）。估计有很多开发的新手就是这样被带到沟里去的，以至于长期以来，一直有人在为 VSS 的“锁定模式”进行辩护。  当然，VSS 还是有少量优点的，比如：捆绑在 Visual Studio 中，和 VS 的其它套件整合得比较好。但是这少数优点远远不能抵消它那些严重的缺点。因此俺强烈建议：那些还在用 VSS 的同学， 
   赶紧换掉吧
   ！万一让别人知道你还在用 VSS，以后上街都没脸跟人打招呼。如果大伙儿觉得俺说得太夸张，可以去看看牛人 Coding Horror 写的帖子（在“  这里  ”）。        ◇CVS 
  骂完 VSS，再稍微说一下曾经广为流行的 CVS，（官方站点在“  这里  ”）。  CVS 的优点显然比 VSS 多多了。曾几何时，CVS 几乎成了源代码版本管理的代名词。那会儿，大部分的开源项目都使用 CVS 进行代码管理。不过，用的人多了之后，大家开始发现 CVS 的一些弊端（比如不能改名文件/目录、比如不支持对目录的版本控制、比如对 Unicode/UTF8 支持不够好、比如版本提交的原子性、比如......）。  有些人受不了 CVS 的某些缺点，开发了一个改良版的  CVSNT  。这玩意儿俺曾经用过几年，比 CVS 好些，不过几个致命的缺点还在（比如上述提到的改名问题）；还有些人更加激进，干脆另起炉灶，搞出全新的 RCS（比如后面提到的 SVN，就是为了取代 CVS 而设计的）。  据俺的观察，目前 RCS 市场的趋势已经比较明显了：很多后来居上的 RCS 正在逐步侵占 CVS 的市场份额。长此以往，CVS 的人气和份额将会逐年下降。不过它暂时还不会消亡，毕竟还有很多老用户还在用它。  所以，俺对 CVS 的观点是：还在用 CVS 的同学也可以考虑换一换了。不过捏，假如你暂时不想换，问题也不算太大（至少CVS的问题没VSS那么严重 
   :-
   ）。        ★新潮的集中式 RCS 
  批完老派的 RCS，接着来说说近几年比较时髦的 RCS。为了循序渐进，俺先从集中式的 RCS 说起。  在新潮的集中式 RCS 软件中，SVN（全名叫“subversion”）是比较有代表性的（官方站点在"  这里  "）。俺就重点来说说它。        ◇SVN 的优点 
  其实 SVN 相对于 CVS 的优点很多，限于篇幅，俺只挑主要的优点介绍。   
   1、能够导入多种 RCS 的代码库
    稍微懂行的人都知道，RCS 迁移是一项很严肃的事情，不可等闲视之。如果新的 RCS 不能很好地导入原有 RCS 的代码库，那你肯定会死得很难看滴。  SVN 在这点上是比较成功的：由于它的影响力比较大，自然会有一些第三方的工具提供代码库的导入功能。比如  SVN Importer  ，可以把其它很多种 RCS（比如：CVS、PVCS、MKS、ClearCase、SourceSafe）的代码库迁移到 SVN。另外还有  cvs2svn  ，专门用来导入 CVS 代码库。通过这些工具，你可以完整地保留原有代码库的所有历史版本。   
   2、和 CVS 的使用类似
    另外，SVN 的一些常用命令、概念、操作习惯都比较类似于 CVS（当然，差别还是有的）。比如俺在 CVS 下经常使用的  TortoiseCVS  ，也有对应的 SVN 版本（  TortoiseSVN  ）。两者就像双胞胎，连界面风格都很像。所以，开发人员从CVS切换到SVN的学习周期会很短，阻力也会很小。   
   3、支持文件/目录改名
    这个问题一直是 CVS 的致命伤，SVN 没理由不搞定。  有了这个功能之后，就可以直接在客户端进行文件的改名操作。拥有新名称的文件，会继承原有文件的版本历史。   
   4、和Web密切整合
    这年头，Web越来越成为主流、B/S 的操作方式也开始深入人心。SVN 迎合了这种趋势，和 Apache 绑定在一起。由于深度整合了 Web，很多版本管理的操作都可以直接在浏览器上搞定，巨简单的说。另外，Apache 作为头号 Web Server，功能、性能、安全性自然无可挑剔。   
   5、能很好地整合其它的开发工具
    得益于 SVN 的设计理念和开源社区的人气，有越来越多的开发工具都可以和 SVN 无缝整合。比如在 Bug 管理方面，有：  Trac  、  Bugzilla  、  Mantis  ；至于各种编辑器或 IDE 的 SVN 插件，那就更多啦，俺就不一一列举了。        ◇SVN 有些啥缺点 
  
   1、不支持分布式
    这是比较明显的缺点。俺后面会提到，集中式相对于分布式具体有哪些缺点。   
   2、性能
    感觉 SVN 在性能方面不咋滴，包括操作速度和存储空间，都不太理想。如果和后面提到的分布式 RCS 相比，这个缺点会更加明显（尤其是在代码 commit 的时候）。   
   3、到处散落 .svn 目录
    其实这个问题倒不是什么大问题（CVS 也有此毛病）。或许某些有洁癖的人看着那么多 
   .svn
   会很不爽。俺自己倒是无所谓。        ★新潮的分布式 RCS 
       ◇集中式和分布式的区别 
  分布式 RCS 和集中式的主要区别在于：  对于集中式 RCS，只有一个中央代码仓库，每个开发人员自己机器上维护一个工作拷贝（working copy）。开发人员本地的代码在没有提交之前，是无法被RCS管理的，因此就无法进行各种操作（比如创建分支）。一旦你的开发机器和中央代码仓库的网络连接断掉（比如你把笔记本带回家写代码），你就只好干瞪眼，无法进行后续工作。  对于分布式 RCS，每一个开发人员的机器上都有一个代码仓库。你随时都可以提交到本地的代码仓库中。分布式 RCS 可以在网络连通的时候，再进行各个代码仓库之间的数据同步。  为啥这几年，分布式的 RCS 多起来捏？一个主要的推动力来自于开源社区。大部分开源项目的开发人员都分布在世界各地，有些人受限于网络因素，不能很流畅地和代码仓库交换数据。在这种情况下，分布式 RCS 的优点就体现出来了。        ◇哪些公司适合分布式的 RCS 
  俺个人认为，一般的软件公司，使用分布式 RCS 的优点不如开源团队那么明显。但是在如下几种情况，你可以考虑采用分布式 RCS。  1、开发团队的地域性分隔  比如公司的开发团队分散在不同的城市，而且互相之间的网络连接不稳定。这有点类似于开源项目的团队，因此可以考虑采用分布式 RCS。  2、在公司之外开发  所谓的“在公司之外开发”，主要有如下几种情况：比如开发人员喜欢在回家之后干活、比如开发人员经常去客户现场干活、比如公司雇佣兼职人员在家干活。  不过这些情况都有一个前提条件，那就是：公司既没有搭建 VPN，而 RCS 又无法从公网上访问。在这种情况下，才值得用分布式 RCS。        ◇几个常见的分布式 RCS 
  分布式的 RCS，名气比较大的有：Git、Mercurial、Monotone、Bazaar。下面俺大致说一下头两个。  
   1、Git
    （官方站点在“  这里  ”）  俺个人感觉，Git 的最大亮点和卖点就是：它的创始人是 Linus。单凭 Linus 这块金字招牌，Git 就吸引到很多人气。而且 Git 在各方面的功能还是比较齐全的。  它的主要缺点就是：对 Windows 系统支持不太好（想想也是，Linus 本人是 Linux 它爹，对 Windows 支持不好也在情理之中啊）。不过现在情况略有好转：Windows 下的 GUI 客户端  TortoiseGit  才刚出来不久，将来如果能做到像  TortoiseSVN  那么成功，那 Git 在 Windows 下就前途光明了。  Git 的成功应用案例，俺不说大伙儿应该猜得到是：Linux Kernel。光这一个就足够说明问题了。   
   2、Mercurial
    （官方站点在“  这里  ”）  Mercurial 是另一个比较牛的分布式 RCS。它还有一个绰号叫 Hg。化学比较好的同学，应该会立马联想到：Hg 是元素周期表中“水银”的缩写。  Mercurial 的特色是基于 Python 开发，所以它在跨平台方面，会比较有优势。另外，它在 Windows 上的 GUI 客户端  TortoiseHg  也比  TortoiseGit  要成熟一些。  Mercurial 相对于 Git 的缺点是性能不够好。没准和基于 Python 开发有关，不过也有可能是 Git 的性能太过优秀。  Mercurial 的成功应用案例有：Mozilla、OpenSolaris、NetBeans。这几个也都是重量级的项目。     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html 
    
    
  
  
    
         
    
    
    
 
    
  

" />
    
    <meta name="author" content="觀點" />

    
    <meta property="og:title" content="开源点评：源代码版本控制系统介绍" />
    <meta property="twitter:title" content="开源点评：源代码版本控制系统介绍" />
    

  <link rel="stylesheet" type="text/css" href="/opinion/style.css" />
  <link rel="alternate" type="application/rss+xml" title="觀點 - 從草根到大師 git.io/JJCxS" href="/opinion/feed.xml" />

  <!-- Social Share Kit CSS -->
  <link rel="stylesheet" href="/opinion/assets/css/social-share-kit.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/opinion/assets/css/bootstrap.min.css" type="text/css">
  <script type="text/javascript" src="/opinion/assets/js/jquery-3.5.1.js"></script>
  <script type="text/javascript" src="/opinion/assets/js/page.js"></script>

</head>

  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      

      <div class="site-info">
        <h1 class="site-name" style="display: inline-block;"><a href="/opinion/">觀點</a></h1>
        <i class="site-description" style="font-size: 12px;">從草根到大師 git.io/JJCxS</i>
      </div>

      <nav>
        <span id="search-container" >
          <a href="/opinion/tools"><i class="fa fa-bookmark twitter" title="百宝箱"></i></a>
        <a><i class="fa fa-search" title="限前100結果"></i></a><input type="text" id="search-input" placeholder="標題 作者 來源 日期 (17499)"
          style="margin: 10px 0px 0px 0px; height: 30px;width: auto" title="本站最正確的打開方式">
        </span>
        
        
        <a href="/opinion/categories" style="color: Tomato;"><i class="fa fa-tags" title="分类"></i></a>
        
        
        
        <a href="https://be4.herokuapp.com/" style="color: #003366;"><i class="fa fa-comments" title="论坛"></i></a>
        
        
        
        <a href="/opinion/about"><i class="fa fa-info-circle" title="关于"></i></a>
        
        
        <a title="电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇，del同来源旧一篇" onclick="toggle_visibility('help')"><i class="fa fa-question-circle"></i></a>
        <a id="fa-home" href="https://nodebe4.github.io" title="BE4服务列表" onclick="//toggle_visibility('site-list')"><i class="fa fa-home" aria-hidden="true"></i></a>
      </nav>

    </header>
    <div id="site-list" class="tags" style="display: block;text-align: right;border-bottom: 1px solid lightGray;"><noscript><span style="background-color: #e8e8e8;color: #d10000;font-size: 14px;">开启浏览器JavaScript以获取搜索功能和更好的浏览体验</span></noscript></div>
    <p id="help" style="font-size: 14px;display: none;text-align: right;"><span style="color:green;">电脑热键：&larr;上一篇(页), &rarr;下一篇(页), ins同来源新一篇, del同来源旧一篇</span>; <span style="color:orange">对应触屏FAB：上下右左</span>; 轉Markdown<a href="https://euangoddard.github.io/clipboard2markdown/"><i class="fa fa-file-text-o"></i></a></p>
  </div>
</div>

<script type="text/javascript" >
  function toggle_visibility(id){
    var help = document.getElementById(id)
    if (help.style.display=='none'){
      help.style.display='block';
    }else{
      help.style.display='none';
    }
  }

  const url = "https://nodebe4.github.io/sitelist.json"

  document.addEventListener("DOMContentLoaded", function(event){
    // var homebtn = document.getElementById("fa-home")
    // homebtn.removeAttribute("href")
    var content = document.getElementById("site-list");
    content.innerHTML = ''
    var ul = document.createElement("ul")
    ul.classList.add("label")
    content.appendChild(ul)
    var cnt = 0

    $.getJSON(url, function(allsites) {

      allsites.map(item =>{
        var li = document.createElement('li')
        li.classList.add("tag")
        li.id = 'site-' + cnt
        ul.appendChild(li)
        var a0 = document.createElement('a')
        li.appendChild(a0)
        a0.href = item.url[0]
        var span = document.createElement('span')
        a0.appendChild(span)
        span.innerText = item['name']
        // span.style.backgroundColor = item['background-color']
        // span.style.color='#E4CBC3'
        span.style.color = item['background-color']
        span.style['font-size'] = '14px'
        cnt += 1
        // test_alive(li.id, a0.href)
      })
    })
  })

function test_alive(id, url){
  var divstatus = document.getElementById(id)
  const base = 'https://textance.herokuapp.com/title/'
  var fullurl = base + url
  $.ajax({
      url: fullurl,
      complete: function(data) {
        if (data.responseText.includes('502')){
          // divstatus.style.color='#FBB7B7'
          // divstatus.style.color='gray'
          // divstatus.title = "服务器无响应"
          divstatus.parentNode.removeChild(divstatus)
        }else{
          // divstatus.style.color='#B6FAC8'
          divstatus.title = data.responseText
        }
      }
  });
  return divstatus
}
</script>



    <!-- Left & centered positioning -->

<div class="ssk-sticky ssk-right ssk-center ssk-sticky-hide-xs ssk-group ssk-round">
  
    <a href="https://be4news.pythonanywhere.com/archivenow/ia/https%3A%2F%2Fprogram-think.blogspot.com%2F2009%2F06%2Fopensource-review-revision-control.html" class="ssk ssk-link" title="存到互联网档案馆" target="_blank"></a>
    <a href="https://www.facebook.com/sharer.php?u=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html" class="ssk ssk-facebook"></a>
    <a href="https://twitter.com/intent/tweet?url=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html&text=开源点评：源代码版本控制系统介绍&hashtags=觀點" class="ssk ssk-twitter"></a>
    <a href="https://reddit.com/submit?url=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html&title=开源点评：源代码版本控制系统介绍" class="ssk ssk-reddit"></a>
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html&title=开源点评：源代码版本控制系统介绍" class="ssk ssk-linkedin"></a>
    <a href="mailto:{email_address}?subject=开源点评：源代码版本控制系统介绍&body=

      开源点评：源代码版本控制系统介绍  
  
    
      
    
  
  
本文是“  每日构建[4]：相关工具介绍  ”的第一部分。  由于源代码版本控制系统（Revision Control System，以下简称“RCS”）属于“  每日构建流程  ”的头一个环节，所以俺在介绍每日构建的相关工具时，先来聊一聊 RCS 类的软件。 
       
         ★老派的 RCS 
  在整个软件开发的生命周期中，RCS 处于一个很基础的位置。很多软件工程的环节都会依赖于它。所以，RCS 对于整个软件开发过程而言，是非常重要的。但是却有很多软件公司仍然在使用一些比较陈旧落后的 RCS。因此，有必要先抨击一下这些老古董的弊端。        ◇VSS 
  要说老派的 RCS，当仁不让的就是微软的 Visual Source Safe（简称“VSS”）。VSS 的设计是相当的老土，对源代码库的访问是基于局域网的共享文件夹方式。共享文件夹的方式那是要多土有多土：不光效率低下，而且容易产生安全隐患。  光是设计老土也就算了，毕竟人家是九十年代早期设计的，那会儿 TCP/IP 还没流行呢！VSS 还有更严重的问题，那就是：【误导】了开发人员的对于源代码管理的观念（比如它对文件的锁定模式）。估计有很多开发的新手就是这样被带到沟里去的，以至于长期以来，一直有人在为 VSS 的“锁定模式”进行辩护。  当然，VSS 还是有少量优点的，比如：捆绑在 Visual Studio 中，和 VS 的其它套件整合得比较好。但是这少数优点远远不能抵消它那些严重的缺点。因此俺强烈建议：那些还在用 VSS 的同学， 
   赶紧换掉吧
   ！万一让别人知道你还在用 VSS，以后上街都没脸跟人打招呼。如果大伙儿觉得俺说得太夸张，可以去看看牛人 Coding Horror 写的帖子（在“  这里  ”）。        ◇CVS 
  骂完 VSS，再稍微说一下曾经广为流行的 CVS，（官方站点在“  这里  ”）。  CVS 的优点显然比 VSS 多多了。曾几何时，CVS 几乎成了源代码版本管理的代名词。那会儿，大部分的开源项目都使用 CVS 进行代码管理。不过，用的人多了之后，大家开始发现 CVS 的一些弊端（比如不能改名文件/目录、比如不支持对目录的版本控制、比如对 Unicode/UTF8 支持不够好、比如版本提交的原子性、比如......）。  有些人受不了 CVS 的某些缺点，开发了一个改良版的  CVSNT  。这玩意儿俺曾经用过几年，比 CVS 好些，不过几个致命的缺点还在（比如上述提到的改名问题）；还有些人更加激进，干脆另起炉灶，搞出全新的 RCS（比如后面提到的 SVN，就是为了取代 CVS 而设计的）。  据俺的观察，目前 RCS 市场的趋势已经比较明显了：很多后来居上的 RCS 正在逐步侵占 CVS 的市场份额。长此以往，CVS 的人气和份额将会逐年下降。不过它暂时还不会消亡，毕竟还有很多老用户还在用它。  所以，俺对 CVS 的观点是：还在用 CVS 的同学也可以考虑换一换了。不过捏，假如你暂时不想换，问题也不算太大（至少CVS的问题没VSS那么严重 
   :-
   ）。        ★新潮的集中式 RCS 
  批完老派的 RCS，接着来说说近几年比较时髦的 RCS。为了循序渐进，俺先从集中式的 RCS 说起。  在新潮的集中式 RCS 软件中，SVN（全名叫“subversion”）是比较有代表性的（官方站点在"  这里  "）。俺就重点来说说它。        ◇SVN 的优点 
  其实 SVN 相对于 CVS 的优点很多，限于篇幅，俺只挑主要的优点介绍。   
   1、能够导入多种 RCS 的代码库
    稍微懂行的人都知道，RCS 迁移是一项很严肃的事情，不可等闲视之。如果新的 RCS 不能很好地导入原有 RCS 的代码库，那你肯定会死得很难看滴。  SVN 在这点上是比较成功的：由于它的影响力比较大，自然会有一些第三方的工具提供代码库的导入功能。比如  SVN Importer  ，可以把其它很多种 RCS（比如：CVS、PVCS、MKS、ClearCase、SourceSafe）的代码库迁移到 SVN。另外还有  cvs2svn  ，专门用来导入 CVS 代码库。通过这些工具，你可以完整地保留原有代码库的所有历史版本。   
   2、和 CVS 的使用类似
    另外，SVN 的一些常用命令、概念、操作习惯都比较类似于 CVS（当然，差别还是有的）。比如俺在 CVS 下经常使用的  TortoiseCVS  ，也有对应的 SVN 版本（  TortoiseSVN  ）。两者就像双胞胎，连界面风格都很像。所以，开发人员从CVS切换到SVN的学习周期会很短，阻力也会很小。   
   3、支持文件/目录改名
    这个问题一直是 CVS 的致命伤，SVN 没理由不搞定。  有了这个功能之后，就可以直接在客户端进行文件的改名操作。拥有新名称的文件，会继承原有文件的版本历史。   
   4、和Web密切整合
    这年头，Web越来越成为主流、B/S 的操作方式也开始深入人心。SVN 迎合了这种趋势，和 Apache 绑定在一起。由于深度整合了 Web，很多版本管理的操作都可以直接在浏览器上搞定，巨简单的说。另外，Apache 作为头号 Web Server，功能、性能、安全性自然无可挑剔。   
   5、能很好地整合其它的开发工具
    得益于 SVN 的设计理念和开源社区的人气，有越来越多的开发工具都可以和 SVN 无缝整合。比如在 Bug 管理方面，有：  Trac  、  Bugzilla  、  Mantis  ；至于各种编辑器或 IDE 的 SVN 插件，那就更多啦，俺就不一一列举了。        ◇SVN 有些啥缺点 
  
   1、不支持分布式
    这是比较明显的缺点。俺后面会提到，集中式相对于分布式具体有哪些缺点。   
   2、性能
    感觉 SVN 在性能方面不咋滴，包括操作速度和存储空间，都不太理想。如果和后面提到的分布式 RCS 相比，这个缺点会更加明显（尤其是在代码 commit 的时候）。   
   3、到处散落 .svn 目录
    其实这个问题倒不是什么大问题（CVS 也有此毛病）。或许某些有洁癖的人看着那么多 
   .svn
   会很不爽。俺自己倒是无所谓。        ★新潮的分布式 RCS 
       ◇集中式和分布式的区别 
  分布式 RCS 和集中式的主要区别在于：  对于集中式 RCS，只有一个中央代码仓库，每个开发人员自己机器上维护一个工作拷贝（working copy）。开发人员本地的代码在没有提交之前，是无法被RCS管理的，因此就无法进行各种操作（比如创建分支）。一旦你的开发机器和中央代码仓库的网络连接断掉（比如你把笔记本带回家写代码），你就只好干瞪眼，无法进行后续工作。  对于分布式 RCS，每一个开发人员的机器上都有一个代码仓库。你随时都可以提交到本地的代码仓库中。分布式 RCS 可以在网络连通的时候，再进行各个代码仓库之间的数据同步。  为啥这几年，分布式的 RCS 多起来捏？一个主要的推动力来自于开源社区。大部分开源项目的开发人员都分布在世界各地，有些人受限于网络因素，不能很流畅地和代码仓库交换数据。在这种情况下，分布式 RCS 的优点就体现出来了。        ◇哪些公司适合分布式的 RCS 
  俺个人认为，一般的软件公司，使用分布式 RCS 的优点不如开源团队那么明显。但是在如下几种情况，你可以考虑采用分布式 RCS。  1、开发团队的地域性分隔  比如公司的开发团队分散在不同的城市，而且互相之间的网络连接不稳定。这有点类似于开源项目的团队，因此可以考虑采用分布式 RCS。  2、在公司之外开发  所谓的“在公司之外开发”，主要有如下几种情况：比如开发人员喜欢在回家之后干活、比如开发人员经常去客户现场干活、比如公司雇佣兼职人员在家干活。  不过这些情况都有一个前提条件，那就是：公司既没有搭建 VPN，而 RCS 又无法从公网上访问。在这种情况下，才值得用分布式 RCS。        ◇几个常见的分布式 RCS 
  分布式的 RCS，名气比较大的有：Git、Mercurial、Monotone、Bazaar。下面俺大致说一下头两个。  
   1、Git
    （官方站点在“  这里  ”）  俺个人感觉，Git 的最大亮点和卖点就是：它的创始人是 Linus。单凭 Linus 这块金字招牌，Git 就吸引到很多人气。而且 Git 在各方面的功能还是比较齐全的。  它的主要缺点就是：对 Windows 系统支持不太好（想想也是，Linus 本人是 Linux 它爹，对 Windows 支持不好也在情理之中啊）。不过现在情况略有好转：Windows 下的 GUI 客户端  TortoiseGit  才刚出来不久，将来如果能做到像  TortoiseSVN  那么成功，那 Git 在 Windows 下就前途光明了。  Git 的成功应用案例，俺不说大伙儿应该猜得到是：Linux Kernel。光这一个就足够说明问题了。   
   2、Mercurial
    （官方站点在“  这里  ”）  Mercurial 是另一个比较牛的分布式 RCS。它还有一个绰号叫 Hg。化学比较好的同学，应该会立马联想到：Hg 是元素周期表中“水银”的缩写。  Mercurial 的特色是基于 Python 开发，所以它在跨平台方面，会比较有优势。另外，它在 Windows 上的 GUI 客户端  TortoiseHg  也比  TortoiseGit  要成熟一些。  Mercurial 相对于 Git 的缺点是性能不够好。没准和基于 Python 开发有关，不过也有可能是 Git 的性能太过优秀。  Mercurial 的成功应用案例有：Mozilla、OpenSolaris、NetBeans。这几个也都是重量级的项目。     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html 
    
    
  
  
    
         
    
    
    
 
    
  

" class="ssk ssk-email"></a>
    <a href="http://pinterest.com/pin/create/link/?url=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html" class="ssk ssk-pinterest"></a>
    <a href="https://www.tumblr.com/widgets/share/tool?canonicalUrl=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html&title=开源点评：源代码版本控制系统介绍&caption=

      开源点评：源代码版本控制系统介绍  
  
    
      
    
  
  
本文是“  每日构建[4]：相关工具介绍  ”的第一部分。  由于源代码版本控制系统（Revision Control System，以下简称“RCS”）属于“  每日构建流程  ”的头一个环节，所以俺在介绍每日构建的相关工具时，先来聊一聊 RCS 类的软件。 
       
         ★老派的 RCS 
  在整个软件开发的生命周期中，RCS 处于一个很基础的位置。很多软件工程的环节都会依赖于它。所以，RCS 对于整个软件开发过程而言，是非常重要的。但是却有很多软件公司仍然在使用一些比较陈旧落后的 RCS。因此，有必要先抨击一下这些老古董的弊端。        ◇VSS 
  要说老派的 RCS，当仁不让的就是微软的 Visual Source Safe（简称“VSS”）。VSS 的设计是相当的老土，对源代码库的访问是基于局域网的共享文件夹方式。共享文件夹的方式那是要多土有多土：不光效率低下，而且容易产生安全隐患。  光是设计老土也就算了，毕竟人家是九十年代早期设计的，那会儿 TCP/IP 还没流行呢！VSS 还有更严重的问题，那就是：【误导】了开发人员的对于源代码管理的观念（比如它对文件的锁定模式）。估计有很多开发的新手就是这样被带到沟里去的，以至于长期以来，一直有人在为 VSS 的“锁定模式”进行辩护。  当然，VSS 还是有少量优点的，比如：捆绑在 Visual Studio 中，和 VS 的其它套件整合得比较好。但是这少数优点远远不能抵消它那些严重的缺点。因此俺强烈建议：那些还在用 VSS 的同学， 
   赶紧换掉吧
   ！万一让别人知道你还在用 VSS，以后上街都没脸跟人打招呼。如果大伙儿觉得俺说得太夸张，可以去看看牛人 Coding Horror 写的帖子（在“  这里  ”）。        ◇CVS 
  骂完 VSS，再稍微说一下曾经广为流行的 CVS，（官方站点在“  这里  ”）。  CVS 的优点显然比 VSS 多多了。曾几何时，CVS 几乎成了源代码版本管理的代名词。那会儿，大部分的开源项目都使用 CVS 进行代码管理。不过，用的人多了之后，大家开始发现 CVS 的一些弊端（比如不能改名文件/目录、比如不支持对目录的版本控制、比如对 Unicode/UTF8 支持不够好、比如版本提交的原子性、比如......）。  有些人受不了 CVS 的某些缺点，开发了一个改良版的  CVSNT  。这玩意儿俺曾经用过几年，比 CVS 好些，不过几个致命的缺点还在（比如上述提到的改名问题）；还有些人更加激进，干脆另起炉灶，搞出全新的 RCS（比如后面提到的 SVN，就是为了取代 CVS 而设计的）。  据俺的观察，目前 RCS 市场的趋势已经比较明显了：很多后来居上的 RCS 正在逐步侵占 CVS 的市场份额。长此以往，CVS 的人气和份额将会逐年下降。不过它暂时还不会消亡，毕竟还有很多老用户还在用它。  所以，俺对 CVS 的观点是：还在用 CVS 的同学也可以考虑换一换了。不过捏，假如你暂时不想换，问题也不算太大（至少CVS的问题没VSS那么严重 
   :-
   ）。        ★新潮的集中式 RCS 
  批完老派的 RCS，接着来说说近几年比较时髦的 RCS。为了循序渐进，俺先从集中式的 RCS 说起。  在新潮的集中式 RCS 软件中，SVN（全名叫“subversion”）是比较有代表性的（官方站点在"  这里  "）。俺就重点来说说它。        ◇SVN 的优点 
  其实 SVN 相对于 CVS 的优点很多，限于篇幅，俺只挑主要的优点介绍。   
   1、能够导入多种 RCS 的代码库
    稍微懂行的人都知道，RCS 迁移是一项很严肃的事情，不可等闲视之。如果新的 RCS 不能很好地导入原有 RCS 的代码库，那你肯定会死得很难看滴。  SVN 在这点上是比较成功的：由于它的影响力比较大，自然会有一些第三方的工具提供代码库的导入功能。比如  SVN Importer  ，可以把其它很多种 RCS（比如：CVS、PVCS、MKS、ClearCase、SourceSafe）的代码库迁移到 SVN。另外还有  cvs2svn  ，专门用来导入 CVS 代码库。通过这些工具，你可以完整地保留原有代码库的所有历史版本。   
   2、和 CVS 的使用类似
    另外，SVN 的一些常用命令、概念、操作习惯都比较类似于 CVS（当然，差别还是有的）。比如俺在 CVS 下经常使用的  TortoiseCVS  ，也有对应的 SVN 版本（  TortoiseSVN  ）。两者就像双胞胎，连界面风格都很像。所以，开发人员从CVS切换到SVN的学习周期会很短，阻力也会很小。   
   3、支持文件/目录改名
    这个问题一直是 CVS 的致命伤，SVN 没理由不搞定。  有了这个功能之后，就可以直接在客户端进行文件的改名操作。拥有新名称的文件，会继承原有文件的版本历史。   
   4、和Web密切整合
    这年头，Web越来越成为主流、B/S 的操作方式也开始深入人心。SVN 迎合了这种趋势，和 Apache 绑定在一起。由于深度整合了 Web，很多版本管理的操作都可以直接在浏览器上搞定，巨简单的说。另外，Apache 作为头号 Web Server，功能、性能、安全性自然无可挑剔。   
   5、能很好地整合其它的开发工具
    得益于 SVN 的设计理念和开源社区的人气，有越来越多的开发工具都可以和 SVN 无缝整合。比如在 Bug 管理方面，有：  Trac  、  Bugzilla  、  Mantis  ；至于各种编辑器或 IDE 的 SVN 插件，那就更多啦，俺就不一一列举了。        ◇SVN 有些啥缺点 
  
   1、不支持分布式
    这是比较明显的缺点。俺后面会提到，集中式相对于分布式具体有哪些缺点。   
   2、性能
    感觉 SVN 在性能方面不咋滴，包括操作速度和存储空间，都不太理想。如果和后面提到的分布式 RCS 相比，这个缺点会更加明显（尤其是在代码 commit 的时候）。   
   3、到处散落 .svn 目录
    其实这个问题倒不是什么大问题（CVS 也有此毛病）。或许某些有洁癖的人看着那么多 
   .svn
   会很不爽。俺自己倒是无所谓。        ★新潮的分布式 RCS 
       ◇集中式和分布式的区别 
  分布式 RCS 和集中式的主要区别在于：  对于集中式 RCS，只有一个中央代码仓库，每个开发人员自己机器上维护一个工作拷贝（working copy）。开发人员本地的代码在没有提交之前，是无法被RCS管理的，因此就无法进行各种操作（比如创建分支）。一旦你的开发机器和中央代码仓库的网络连接断掉（比如你把笔记本带回家写代码），你就只好干瞪眼，无法进行后续工作。  对于分布式 RCS，每一个开发人员的机器上都有一个代码仓库。你随时都可以提交到本地的代码仓库中。分布式 RCS 可以在网络连通的时候，再进行各个代码仓库之间的数据同步。  为啥这几年，分布式的 RCS 多起来捏？一个主要的推动力来自于开源社区。大部分开源项目的开发人员都分布在世界各地，有些人受限于网络因素，不能很流畅地和代码仓库交换数据。在这种情况下，分布式 RCS 的优点就体现出来了。        ◇哪些公司适合分布式的 RCS 
  俺个人认为，一般的软件公司，使用分布式 RCS 的优点不如开源团队那么明显。但是在如下几种情况，你可以考虑采用分布式 RCS。  1、开发团队的地域性分隔  比如公司的开发团队分散在不同的城市，而且互相之间的网络连接不稳定。这有点类似于开源项目的团队，因此可以考虑采用分布式 RCS。  2、在公司之外开发  所谓的“在公司之外开发”，主要有如下几种情况：比如开发人员喜欢在回家之后干活、比如开发人员经常去客户现场干活、比如公司雇佣兼职人员在家干活。  不过这些情况都有一个前提条件，那就是：公司既没有搭建 VPN，而 RCS 又无法从公网上访问。在这种情况下，才值得用分布式 RCS。        ◇几个常见的分布式 RCS 
  分布式的 RCS，名气比较大的有：Git、Mercurial、Monotone、Bazaar。下面俺大致说一下头两个。  
   1、Git
    （官方站点在“  这里  ”）  俺个人感觉，Git 的最大亮点和卖点就是：它的创始人是 Linus。单凭 Linus 这块金字招牌，Git 就吸引到很多人气。而且 Git 在各方面的功能还是比较齐全的。  它的主要缺点就是：对 Windows 系统支持不太好（想想也是，Linus 本人是 Linux 它爹，对 Windows 支持不好也在情理之中啊）。不过现在情况略有好转：Windows 下的 GUI 客户端  TortoiseGit  才刚出来不久，将来如果能做到像  TortoiseSVN  那么成功，那 Git 在 Windows 下就前途光明了。  Git 的成功应用案例，俺不说大伙儿应该猜得到是：Linux Kernel。光这一个就足够说明问题了。   
   2、Mercurial
    （官方站点在“  这里  ”）  Mercurial 是另一个比较牛的分布式 RCS。它还有一个绰号叫 Hg。化学比较好的同学，应该会立马联想到：Hg 是元素周期表中“水银”的缩写。  Mercurial 的特色是基于 Python 开发，所以它在跨平台方面，会比较有优势。另外，它在 Windows 上的 GUI 客户端  TortoiseHg  也比  TortoiseGit  要成熟一些。  Mercurial 相对于 Git 的缺点是性能不够好。没准和基于 Python 开发有关，不过也有可能是 Git 的性能太过优秀。  Mercurial 的成功应用案例有：Mozilla、OpenSolaris、NetBeans。这几个也都是重量级的项目。     

    版权声明
     本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者  编程随想  和本文原始地址：   https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html 
    
    
  
  
    
         
    
    
    
 
    
  

&tags=觀點" class="ssk ssk-tumblr"></a>
    <a href="https://buffer.com/add?text=开源点评：源代码版本控制系统介绍&url=https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html" class="ssk ssk-buffer"></a>
</div>


    <div id="main" role="main" class="container">
      
  <!-- Html Elements for Search -->
  <ul id="results-container" class="searched" style="color: #2980B9;"></ul>

  <script src="/opinion/assets/js/simple-jekyll-search.min.js"></script>

  <!-- Configuration -->
  <script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/opinion/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a><time>{date}</time><a class="tag">{category}</a></li>',
    noResultsText: '没找到',
    limit: 100,
    fuzzy: false,
    exclude: ['Welcome']
  })

  </script>

      







  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    


  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
    



<article class="post">
  <h1>开源点评：源代码版本控制系统介绍</h1>
  <!-- Look the author details up from the site config. -->
  

  <div>
    <span class="date">
      2009-06-21
    </span>

    <!-- Output author details if some exist. -->
    
      
    


    <ul class="tag">
      <li>
        <a href="https://nodebe4.github.io/opinion/categories/#编程随想">
          编程随想
        </a>
      </li>
    </ul>

    
        <span>
            <!-- Personal Info. -->
            <a href="https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html" style="font-size:14px;">原文</a>
        </span>
    

    <span style="float: right;" title="编程随想的其它文章">
      <a style="font-size: 14px;" rel="nofollow" href="#sametag" class="tags">#编程随想 的其它文章</a>
    </span>

  </div>

  <div class="entry">
    
    
    
    <div class="post hentry uncustomized-post-template">
<a name="8982886493469757804">
 </a>   <h1 class="post-title entry-title" id="section"> <a href="https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html"> 开源点评：源代码版本控制系统介绍 </a> </h1>
  <div class="post-header">
    <div class="post-header-line-1">
      <div class="post-inner-index"></div>
    </div>
  </div>
  <div class="post-body entry-content">
本文是“ <a href="https://program-think.blogspot.com/2009/06/daily-build-4-tools.html"> 每日构建[4]：相关工具介绍 </a> ”的第一部分。 <br /> 由于源代码版本控制系统（Revision Control System，以下简称“RCS”）属于“ <a href="https://program-think.blogspot.com/2009/02/daily-build-3-proces.html"> 每日构建流程 </a> ”的头一个环节，所以俺在介绍每日构建的相关工具时，先来聊一聊 RCS 类的软件。 <a name="more">
  </a>     <!--program-think-->
 <br /> <br /> <br />     <h2 id="rcs-"> ★老派的 RCS </h2>
 <br /> 在整个软件开发的生命周期中，RCS 处于一个很基础的位置。很多软件工程的环节都会依赖于它。所以，RCS 对于整个软件开发过程而言，是非常重要的。但是却有很多软件公司仍然在使用一些比较陈旧落后的 RCS。因此，有必要先抨击一下这些老古董的弊端。 <br /> <br />     <h3 id="vss-"> ◇VSS </h3>
 <br /> 要说老派的 RCS，当仁不让的就是微软的 Visual Source Safe（简称“VSS”）。VSS 的设计是相当的老土，对源代码库的访问是基于局域网的共享文件夹方式。共享文件夹的方式那是要多土有多土：不光效率低下，而且容易产生安全隐患。 <br /> 光是设计老土也就算了，毕竟人家是九十年代早期设计的，那会儿 TCP/IP 还没流行呢！VSS 还有更严重的问题，那就是：【误导】了开发人员的对于源代码管理的观念（比如它对文件的锁定模式）。估计有很多开发的新手就是这样被带到沟里去的，以至于长期以来，一直有人在为 VSS 的“锁定模式”进行辩护。 <br /> 当然，VSS 还是有少量优点的，比如：捆绑在 Visual Studio 中，和 VS 的其它套件整合得比较好。但是这少数优点远远不能抵消它那些严重的缺点。因此俺强烈建议：那些还在用 VSS 的同学， <b>
   赶紧换掉吧
  </b> ！万一让别人知道你还在用 VSS，以后上街都没脸跟人打招呼。如果大伙儿觉得俺说得太夸张，可以去看看牛人 Coding Horror 写的帖子（在“ <a href="http://www.codinghorror.com/blog/archives/000660.html" rel="nofollow" target="_blank"> 这里 </a> ”）。 <br /> <br />     <h3 id="cvs-"> ◇CVS </h3>
 <br /> 骂完 VSS，再稍微说一下曾经广为流行的 CVS，（官方站点在“ <a href="http://www.nongnu.org/cvs" rel="nofollow" target="_blank"> 这里 </a> ”）。 <br /> CVS 的优点显然比 VSS 多多了。曾几何时，CVS 几乎成了源代码版本管理的代名词。那会儿，大部分的开源项目都使用 CVS 进行代码管理。不过，用的人多了之后，大家开始发现 CVS 的一些弊端（比如不能改名文件/目录、比如不支持对目录的版本控制、比如对 Unicode/UTF8 支持不够好、比如版本提交的原子性、比如......）。 <br /> 有些人受不了 CVS 的某些缺点，开发了一个改良版的 <a href="http://cvsnt.org/" rel="nofollow" target="_blank"> CVSNT </a> 。这玩意儿俺曾经用过几年，比 CVS 好些，不过几个致命的缺点还在（比如上述提到的改名问题）；还有些人更加激进，干脆另起炉灶，搞出全新的 RCS（比如后面提到的 SVN，就是为了取代 CVS 而设计的）。 <br /> 据俺的观察，目前 RCS 市场的趋势已经比较明显了：很多后来居上的 RCS 正在逐步侵占 CVS 的市场份额。长此以往，CVS 的人气和份额将会逐年下降。不过它暂时还不会消亡，毕竟还有很多老用户还在用它。 <br /> 所以，俺对 CVS 的观点是：还在用 CVS 的同学也可以考虑换一换了。不过捏，假如你暂时不想换，问题也不算太大（至少CVS的问题没VSS那么严重 <b>
   :-
  </b> ）。 <br /> <br />     <h2 id="rcs--1"> ★新潮的集中式 RCS </h2>
 <br /> 批完老派的 RCS，接着来说说近几年比较时髦的 RCS。为了循序渐进，俺先从集中式的 RCS 说起。 <br /> 在新潮的集中式 RCS 软件中，SVN（全名叫“subversion”）是比较有代表性的（官方站点在" <a href="http://subversion.tigris.org/" rel="nofollow" target="_blank"> 这里 </a> "）。俺就重点来说说它。 <br /> <br />     <h3 id="svn--"> ◇SVN 的优点 </h3>
 <br /> 其实 SVN 相对于 CVS 的优点很多，限于篇幅，俺只挑主要的优点介绍。 <br /> <br /> <b>
   1、能够导入多种 RCS 的代码库
  </b> <br /> 稍微懂行的人都知道，RCS 迁移是一项很严肃的事情，不可等闲视之。如果新的 RCS 不能很好地导入原有 RCS 的代码库，那你肯定会死得很难看滴。 <br /> SVN 在这点上是比较成功的：由于它的影响力比较大，自然会有一些第三方的工具提供代码库的导入功能。比如 <a href="http://www.subversionary.org/projects/svnimporter" rel="nofollow" target="_blank"> SVN Importer </a> ，可以把其它很多种 RCS（比如：CVS、PVCS、MKS、ClearCase、SourceSafe）的代码库迁移到 SVN。另外还有 <a href="http://cvs2svn.tigris.org/" rel="nofollow" target="_blank"> cvs2svn </a> ，专门用来导入 CVS 代码库。通过这些工具，你可以完整地保留原有代码库的所有历史版本。 <br /> <br /> <b>
   2、和 CVS 的使用类似
  </b> <br /> 另外，SVN 的一些常用命令、概念、操作习惯都比较类似于 CVS（当然，差别还是有的）。比如俺在 CVS 下经常使用的 <a href="http://www.tortoisecvs.org/" rel="nofollow" target="_blank"> TortoiseCVS </a> ，也有对应的 SVN 版本（ <a href="http://tortoisesvn.tigris.org/" rel="nofollow" target="_blank"> TortoiseSVN </a> ）。两者就像双胞胎，连界面风格都很像。所以，开发人员从CVS切换到SVN的学习周期会很短，阻力也会很小。 <br /> <br /> <b>
   3、支持文件/目录改名
  </b> <br /> 这个问题一直是 CVS 的致命伤，SVN 没理由不搞定。 <br /> 有了这个功能之后，就可以直接在客户端进行文件的改名操作。拥有新名称的文件，会继承原有文件的版本历史。 <br /> <br /> <b>
   4、和Web密切整合
  </b> <br /> 这年头，Web越来越成为主流、B/S 的操作方式也开始深入人心。SVN 迎合了这种趋势，和 Apache 绑定在一起。由于深度整合了 Web，很多版本管理的操作都可以直接在浏览器上搞定，巨简单的说。另外，Apache 作为头号 Web Server，功能、性能、安全性自然无可挑剔。 <br /> <br /> <b>
   5、能很好地整合其它的开发工具
  </b> <br /> 得益于 SVN 的设计理念和开源社区的人气，有越来越多的开发工具都可以和 SVN 无缝整合。比如在 Bug 管理方面，有： <a href="http://trac.edgewall.org/" rel="nofollow" target="_blank"> Trac </a> 、 <a href="http://www.bugzilla.org/" rel="nofollow" target="_blank"> Bugzilla </a> 、 <a href="http://www.mantisbt.org/" rel="nofollow" target="_blank"> Mantis </a> ；至于各种编辑器或 IDE 的 SVN 插件，那就更多啦，俺就不一一列举了。 <br /> <br />     <h3 id="svn---1"> ◇SVN 有些啥缺点 </h3>
 <br /> <b>
   1、不支持分布式
  </b> <br /> 这是比较明显的缺点。俺后面会提到，集中式相对于分布式具体有哪些缺点。 <br /> <br /> <b>
   2、性能
  </b> <br /> 感觉 SVN 在性能方面不咋滴，包括操作速度和存储空间，都不太理想。如果和后面提到的分布式 RCS 相比，这个缺点会更加明显（尤其是在代码 commit 的时候）。 <br /> <br /> <b>
   3、到处散落 .svn 目录
  </b> <br /> 其实这个问题倒不是什么大问题（CVS 也有此毛病）。或许某些有洁癖的人看着那么多 <b>
   .svn
  </b> 会很不爽。俺自己倒是无所谓。 <br /> <br />     <h2 id="rcs--2"> ★新潮的分布式 RCS </h2>
 <br />     <h3 id="section-1"> ◇集中式和分布式的区别 </h3>
 <br /> 分布式 RCS 和集中式的主要区别在于： <br /> 对于集中式 RCS，只有一个中央代码仓库，每个开发人员自己机器上维护一个工作拷贝（working copy）。开发人员本地的代码在没有提交之前，是无法被RCS管理的，因此就无法进行各种操作（比如创建分支）。一旦你的开发机器和中央代码仓库的网络连接断掉（比如你把笔记本带回家写代码），你就只好干瞪眼，无法进行后续工作。 <br /> 对于分布式 RCS，每一个开发人员的机器上都有一个代码仓库。你随时都可以提交到本地的代码仓库中。分布式 RCS 可以在网络连通的时候，再进行各个代码仓库之间的数据同步。 <br /> 为啥这几年，分布式的 RCS 多起来捏？一个主要的推动力来自于开源社区。大部分开源项目的开发人员都分布在世界各地，有些人受限于网络因素，不能很流畅地和代码仓库交换数据。在这种情况下，分布式 RCS 的优点就体现出来了。 <br /> <br />     <h3 id="rcs--3"> ◇哪些公司适合分布式的 RCS </h3>
 <br /> 俺个人认为，一般的软件公司，使用分布式 RCS 的优点不如开源团队那么明显。但是在如下几种情况，你可以考虑采用分布式 RCS。 <br /> 1、开发团队的地域性分隔 <br /> 比如公司的开发团队分散在不同的城市，而且互相之间的网络连接不稳定。这有点类似于开源项目的团队，因此可以考虑采用分布式 RCS。 <br /> 2、在公司之外开发 <br /> 所谓的“在公司之外开发”，主要有如下几种情况：比如开发人员喜欢在回家之后干活、比如开发人员经常去客户现场干活、比如公司雇佣兼职人员在家干活。 <br /> 不过这些情况都有一个前提条件，那就是：公司既没有搭建 VPN，而 RCS 又无法从公网上访问。在这种情况下，才值得用分布式 RCS。 <br /> <br />     <h3 id="rcs--4"> ◇几个常见的分布式 RCS </h3>
 <br /> 分布式的 RCS，名气比较大的有：Git、Mercurial、Monotone、Bazaar。下面俺大致说一下头两个。 <br /> <b>
   1、Git
  </b> <br /> （官方站点在“ <a href="http://git-scm.com/" rel="nofollow" target="_blank"> 这里 </a> ”） <br /> 俺个人感觉，Git 的最大亮点和卖点就是：它的创始人是 Linus。单凭 Linus 这块金字招牌，Git 就吸引到很多人气。而且 Git 在各方面的功能还是比较齐全的。 <br /> 它的主要缺点就是：对 Windows 系统支持不太好（想想也是，Linus 本人是 Linux 它爹，对 Windows 支持不好也在情理之中啊）。不过现在情况略有好转：Windows 下的 GUI 客户端 <a href="http://code.google.com/p/tortoisegit/" rel="nofollow" target="_blank"> TortoiseGit </a> 才刚出来不久，将来如果能做到像 <a href="http://tortoisesvn.tigris.org/" rel="nofollow" target="_blank"> TortoiseSVN </a> 那么成功，那 Git 在 Windows 下就前途光明了。 <br /> Git 的成功应用案例，俺不说大伙儿应该猜得到是：Linux Kernel。光这一个就足够说明问题了。 <br /> <br /> <b>
   2、Mercurial
  </b> <br /> （官方站点在“ <a href="http://www.selenic.com/mercurial/" rel="nofollow" target="_blank"> 这里 </a> ”） <br /> Mercurial 是另一个比较牛的分布式 RCS。它还有一个绰号叫 Hg。化学比较好的同学，应该会立马联想到：Hg 是元素周期表中“水银”的缩写。 <br /> Mercurial 的特色是基于 Python 开发，所以它在跨平台方面，会比较有优势。另外，它在 Windows 上的 GUI 客户端 <a href="http://tortoisehg.sourceforge.net/" rel="nofollow" target="_blank"> TortoiseHg </a> 也比 <a href="http://code.google.com/p/tortoisegit/" rel="nofollow" target="_blank"> TortoiseGit </a> 要成熟一些。 <br /> Mercurial 相对于 Git 的缺点是性能不够好。没准和基于 Python 开发有关，不过也有可能是 Git 的性能太过优秀。 <br /> Mercurial 的成功应用案例有：Mozilla、OpenSolaris、NetBeans。这几个也都是重量级的项目。     <div class="post-copyright">
<b>
    版权声明
   </b> <br /> 本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者 <a href="mailto:program.think@gmail.com"> 编程随想 </a> 和本文原始地址： <br /> <a href="https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html" id="OriginalPostUrl"> https://program-think.blogspot.com/2009/06/opensource-review-revision-control.html </a>
    </div>
    <div style="clear: both;"></div>
  </div>
  <div class="post-footer" style="margin-bottom:50px;">
    <div class="post-footer-line post-footer-line-1" style="display:none;">
<span class="post-author vcard"> </span> <span class="reaction-buttons"> </span> <span class="star-ratings"> </span> <span class="post-icons"> </span> <span class="post-backlinks post-comment-link"> </span>
    </div>
    <div class="post-footer-line post-footer-line-2 post-toolbar"></div>
    <div class="post-footer-line post-footer-line-3">
<span class="post-location"> </span>
    </div>
  </div>
</div>


  </div>

  <hr style="border-top:1px solid #28323C;"/>

<font size=2px>
  文章版权归原作者所有。
</font>

<div style="text-align:center"><img width="1px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站" style="text-align:center"/></div>

  <div id="sametag">
    <h4 style="display: inline-block;">#编程随想 的其它文章</h4>
    <span>--<a href="https://nodebe4.github.io/opinion/2021-05-09/%E5%88%86%E4%BA%AB%E5%90%84%E7%B1%BB%E7%94%B5%E5%AD%90%E4%B9%A6-%E6%94%BF%E6%B2%BB-IT-%E7%A7%91%E6%99%AE-%E5%8E%86%E5%8F%B2-%E7%AD%89-97%E6%9C%AC/">最新</a>-</span>
    <span>-<a href="https://nodebe4.github.io/opinion/2009-01-15/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%BC%A0%E5%8F%8A%E6%9C%AC%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/">最早</a>--</span>
    
      <li>
        <time>2009-07-01</time>
        <a href="https://nodebe4.github.io/opinion/2009-07-01/%E5%85%9A%E5%92%8C%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%BE%83%E9%87%8F/">
          党和互联网的较量
        </a>
      </li>
    
    
      <li>
        <time>2009-06-26</time>
        <a href="https://nodebe4.github.io/opinion/2009-06-26/Java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-4-%E5%85%B3%E4%BA%8E-finalize-%E5%87%BD%E6%95%B0/">
          Java 性能优化[4]：关于 finalize 函数
        </a>
      </li>
    
    
      <li>
        <time>2009-06-21</time>
        <a href="https://nodebe4.github.io/opinion/2009-06-21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%AF%8F%E6%97%A5%E6%9E%84%E5%BB%BA-4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">
          软件工程进阶之每日构建[4]：相关工具介绍
        </a>
      </li>
    
    
      <li>
        <time>2009-06-14</time>
        <a href="https://nodebe4.github.io/opinion/2009-06-14/%E4%B9%A6%E8%AF%84-%E4%B8%80%E4%B9%9D%E5%85%AB%E5%9B%9B-%E5%8F%8D%E4%B9%8C%E6%89%98%E9%82%A6%E7%9A%84%E4%BB%A3%E8%A1%A8%E4%BD%9C/">
          书评：《一九八四》——反乌托邦的代表作
        </a>
      </li>
    
  </div>


  <hr>
  <div class="pagination">
    
      <span class="prev" >
          <a href="https://nodebe4.github.io/opinion/2009-06-21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%AF%8F%E6%97%A5%E6%9E%84%E5%BB%BA-4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">
            前一篇：软件工程进阶之每日构建[4]：相关工具介绍
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://nodebe4.github.io/opinion/2009-06-24/%E5%BC%A0%E6%9B%99%E5%85%89-%E4%B8%A4%E7%A8%8E%E5%90%88%E5%B9%B6%E4%B8%8E%E5%85%AC%E5%85%B1%E7%A6%8F%E5%88%A9/">
            後一篇：张曙光：两税合并与公共福利
          </a>
      </span>
    

    <script>
    /* post pagination keyboard shortcuts */
    document.body.onkeyup = function(e){
      if (e.keyCode == '37') { window.location = 'https://nodebe4.github.io/opinion/2009-06-21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%AF%8F%E6%97%A5%E6%9E%84%E5%BB%BA-4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/'; } // left arrow key
      if (e.keyCode == '39') { window.location = 'https://nodebe4.github.io/opinion/2009-06-24/%E5%BC%A0%E6%9B%99%E5%85%89-%E4%B8%A4%E7%A8%8E%E5%90%88%E5%B9%B6%E4%B8%8E%E5%85%AC%E5%85%B1%E7%A6%8F%E5%88%A9/'; } // right arrow key
      if (e.keyCode == '45') { window.location = 'https://nodebe4.github.io/opinion/2009-06-26/Java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-4-%E5%85%B3%E4%BA%8E-finalize-%E5%87%BD%E6%95%B0/'; } // insert key
      if (e.keyCode == '46') { window.location = 'https://nodebe4.github.io/opinion/2009-06-21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%AF%8F%E6%97%A5%E6%9E%84%E5%BB%BA-4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/'; } // delete key
    };
    </script>
    <link rel="stylesheet" type="text/css" href="/opinion/assets/css/fab.css" />

<div class="fab-wrapper">
  <div class="fab-wheel">
    
    
    
    <a class="fab-action fab-action-1" title="上一篇(热键 &#8594;)" href="https://nodebe4.github.io/opinion/2009-06-21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%AF%8F%E6%97%A5%E6%9E%84%E5%BB%BA-4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">
      <i>后</i>
    </a>
    
    
    <a class="fab-action fab-action-2" title="下一篇(热键 &#8592;)" href="https://nodebe4.github.io/opinion/2009-06-24/%E5%BC%A0%E6%9B%99%E5%85%89-%E4%B8%A4%E7%A8%8E%E5%90%88%E5%B9%B6%E4%B8%8E%E5%85%AC%E5%85%B1%E7%A6%8F%E5%88%A9/">
      <i>前</i>
    </a>
    
    
    <a class="fab-action fab-action-3" title="<编程随想>上一篇(热键 ins)" href="https://nodebe4.github.io/opinion/2009-06-26/Java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-4-%E5%85%B3%E4%BA%8E-finalize-%E5%87%BD%E6%95%B0/">
      <i>左</i>
    </a>
    
    
    <a class="fab-action fab-action-4" title="<编程随想>下一篇(热键 del)" href="https://nodebe4.github.io/opinion/2009-06-21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%AF%8F%E6%97%A5%E6%9E%84%E5%BB%BA-4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">
      <i>右</i>
    </a>
    
  </div>
</div>


  </div>


  

</article>

    </div>

    <div style="z-index:2;">
<script src="/opinion/assets/js/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  cornerOffset: 20, // px
  id: 'back-to-top',
  backgroundColor: '#ddd',
  textColor: 'red'
})</script>
</div>


    <div class="wrapper-footer" id="footer">
      <div class="container">
        <footer class="footer">
          <img width="200px" src="https://i.imgur.com/HSw56Ez.png" alt="二维码分享本站"/>
<font size=2px>二维码分享本站</font>

<!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:beauti4@protonmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/NodeBE4/opinion" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  
  <li><a href="/opinion/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M201.8 347.2c0 20.3-16.5 36.8-36.8 36.8 -20.3 0-36.8-16.5-36.8-36.8s16.5-36.8 36.8-36.8C185.3 310.4 201.8 326.8 201.8 347.2zM128.2 204.7v54.5c68.5 0.7 124 56.3 124.7 124.7h54.5C306.7 285.3 226.9 205.4 128.2 204.7zM128.2 166.6c57.9 0.3 112.3 22.9 153.2 63.9 41 41 63.7 95.5 63.9 153.5h54.5c-0.3-149.9-121.7-271.4-271.6-271.9V166.6L128.2 166.6z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

    
</ul>





<p><span style="color:blue">内容每小时更新一次.</span> Powered by <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a> & <a href="https://github.com/gitalk/gitalk">Gitalk</a> & <a href="https://github.com/duty-machine/news">duty-machine</a>, 站务 <a href="https://be4.herokuapp.com">NodeBE4</a>（<span style="color:red">被墙</span>）</p>





        </footer>
      </div>
    </div>

    



  </body>
</html>
